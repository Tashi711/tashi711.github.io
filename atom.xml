<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tashi711的博客</title>
  
  <subtitle>過去（きのう）に傷付きながらも、信じ続ける理想（ゆめ）を求める。いつか無限（なないろ）に輝き放って、青空（そら）に橋を描く。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tashi711.xyz/"/>
  <updated>2018-12-24T17:24:20.384Z</updated>
  <id>http://tashi711.xyz/</id>
  
  <author>
    <name>Tashi711</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「LeetCode 97. Interleaving String」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-97/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-97/</id>
    <published>2018-12-25T03:57:03.000Z</published>
    <updated>2018-12-24T17:24:20.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/interleaving-string/description/" target="_blank" rel="noopener">LeetCode 97. Interleaving String</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p><p><strong>示例 1:</strong><br>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>输出: true</p><p><strong>示例 2:</strong><br>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”<br>输出: false</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>平方的算法基本还是秒想到了。<br>比较裸而且容易的DP吧，f[i][j]：s3的前i个字母用到s1的前j个字母是否可行。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N^2)$，认为字符串规模都是N的话。<br>空间复杂度为 $O(N^2)$，可以优化一维。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s1.size());</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s2.size());</span><br><span class="line"><span class="keyword">int</span> n3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s3.size());</span><br><span class="line"><span class="keyword">if</span> (n1 + n2 != n3) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; f(n3 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n1 + <span class="number">1</span>));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p3 = <span class="number">1</span>; p3 &lt;= n3; ++p3) &#123;</span><br><span class="line"><span class="keyword">int</span> max_p1 = min(p3, n1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>; p1 &lt;= max_p1; ++p1) &#123;</span><br><span class="line"><span class="keyword">int</span> p2 = p3 - p1;</span><br><span class="line"><span class="keyword">if</span> (p2 &gt; n2) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p1 != <span class="number">0</span> &amp;&amp; s3[p3 - <span class="number">1</span>] == s1[p1 - <span class="number">1</span>] &amp;&amp; f[p3 - <span class="number">1</span>][p1 - <span class="number">1</span>]) &#123;</span><br><span class="line">f[p3][p1] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p2 != <span class="number">0</span> &amp;&amp; s3[p3 - <span class="number">1</span>] == s2[p2 - <span class="number">1</span>] &amp;&amp; f[p3 - <span class="number">1</span>][p1]) &#123;</span><br><span class="line">f[p3][p1] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n3][n1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">string</span> s1, s2, s3;</span><br><span class="line">s1 = <span class="string">"aabcc"</span>;</span><br><span class="line">s2 = <span class="string">"dbbca"</span>;</span><br><span class="line">s3 = <span class="string">"aadbbcbcac"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;isInterleave(s1, s2, s3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s1 = <span class="string">"aabcc"</span>;</span><br><span class="line">s2 = <span class="string">"dbbca"</span>;</span><br><span class="line">s3 = <span class="string">"aadbbbaccc"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;isInterleave(s1, s2, s3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/interleaving-string/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 97. Interleaving String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”&lt;br&gt;输出: true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”&lt;br&gt;输出: false&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 84. Largest Rectangle in Histogram」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-84/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-84/</id>
    <published>2018-12-25T03:57:02.000Z</published>
    <updated>2018-12-24T16:51:48.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank" rel="noopener">LeetCode 84. Largest Rectangle in Histogram</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例:</strong><br>输入: [2,1,5,6,2,3]<br>输出: 10</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较值得思考的一道题，隐隐记得被人问过。<br>只是官方题解居然被抠掉了？可以看看高赞的几个回答。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N)$。<br>空间复杂度为 $O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">heights.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(heights.size());</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!s.empty() &amp;&amp; heights[s.top()] &gt;= heights[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> h = heights[s.top()];</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">int</span> bf = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">res = max(res, h * (i - bf - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj&#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;largestRectangleArea(adj) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 84. Largest Rectangle in Histogram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;br&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: [2,1,5,6,2,3]&lt;br&gt;输出: 10&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 76. Minimum Window Substring」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-76/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-76/</id>
    <published>2018-12-23T03:57:02.000Z</published>
    <updated>2018-12-23T15:02:14.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">LeetCode 76. Minimum Window Substring</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。</p><p><strong>示例：</strong><br>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”</p><p><strong>说明：</strong><br>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很裸的滑动窗口吧，当然说是O(n)的复杂度是认为了字母的个数为常数。<br>有几个题目没说清楚的坑点注意：<br>1、可能出现小写字母<br>2、包含的字母个数也要足够<br>另外题解的优化算法也很迷，没get到它的必要性（优化常数？）……</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N)$，如果认为字母种类为常数。<br>空间复杂度为 $O(1)$，如果认为字母种类为常数。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kInf = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> have[kMaxN];</span><br><span class="line"><span class="keyword">int</span> cnt[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">'A'</span>; i &lt;= <span class="string">'z'</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[i] &lt; have[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(have, <span class="number">0</span>, <span class="keyword">sizeof</span> have);</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">++have[c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ns = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">0</span>, v = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans_u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min_len = kInf;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">bool</span> over = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (v &lt; ns - <span class="number">1</span>) &#123;</span><br><span class="line">++cnt[s[++v]];</span><br><span class="line"><span class="keyword">if</span> (check()) &#123;</span><br><span class="line">over = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (over) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (v - u + <span class="number">1</span> &lt; min_len) &#123;</span><br><span class="line">min_len = v - u + <span class="number">1</span>;</span><br><span class="line">ans_u = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> rem = s[u++];</span><br><span class="line"><span class="keyword">if</span> (--cnt[rem] &lt; have[rem]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min_len == kInf ? <span class="string">""</span> : s.substr(ans_u, min_len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minWindow(<span class="string">"ADOBECODEBANC"</span>, <span class="string">"ABC"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/minimum-window-substring/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 76. Minimum Window Substring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br&gt;输入: S = “ADOBECODEBANC”, T = “ABC”&lt;br&gt;输出: “BANC”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br&gt;如果 S 中不存这样的子串，则返回空字符串 “”。&lt;br&gt;如果 S 中存在这样的子串，我们保证它是唯一的答案。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 72. Edit Distance」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-72/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-72/</id>
    <published>2018-12-23T03:57:02.000Z</published>
    <updated>2018-12-22T17:14:33.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">LeetCode 72. Edit Distance</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p><p><strong>示例 1:</strong><br>输入: word1 = “horse”, word2 = “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p><p><strong>示例 2:</strong><br>输入: word1 = “intention”, word2 = “execution”<br>输出: 5<br>解释:<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>算是DP的最经典的题了，不多说。<br>注意到如果word1[i]余word2[j]相同，其实f[i][j]可以直接等于f[i-1][j-1]。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(NM)$，其中N、M分别为两个字符串的长度。<br>空间复杂度为 $O(NM)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(word1.size());</span><br><span class="line"><span class="keyword">int</span> m = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(word2.size());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">f[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">f[<span class="number">0</span>][j] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f[i][j] = min(min(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]), f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minDistance(<span class="string">"horse"</span>, <span class="string">"ros"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minDistance(<span class="string">"intention"</span>, <span class="string">"execution"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/edit-distance/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 72. Edit Distance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;br&gt;你可以对一个单词进行如下三种操作：&lt;br&gt;插入一个字符&lt;br&gt;删除一个字符&lt;br&gt;替换一个字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: word1 = “horse”, word2 = “ros”&lt;br&gt;输出: 3&lt;br&gt;解释:&lt;br&gt;horse -&amp;gt; rorse (将 ‘h’ 替换为 ‘r’)&lt;br&gt;rorse -&amp;gt; rose (删除 ‘r’)&lt;br&gt;rose -&amp;gt; ros (删除 ‘e’)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: word1 = “intention”, word2 = “execution”&lt;br&gt;输出: 5&lt;br&gt;解释:&lt;br&gt;intention -&amp;gt; inention (删除 ‘t’)&lt;br&gt;inention -&amp;gt; enention (将 ‘i’ 替换为 ‘e’)&lt;br&gt;enention -&amp;gt; exention (将 ‘n’ 替换为 ‘x’)&lt;br&gt;exention -&amp;gt; exection (将 ‘n’ 替换为 ‘c’)&lt;br&gt;exection -&amp;gt; execution (插入 ‘u’)&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「KMP算法」浅析</title>
    <link href="http://tashi711.xyz/programming/dsaa/kmp/"/>
    <id>http://tashi711.xyz/programming/dsaa/kmp/</id>
    <published>2018-12-23T03:17:59.000Z</published>
    <updated>2018-12-23T10:35:29.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>Note：本文转自Matrix67博客，有改动。</p><h3 id="KMP思想"><a href="#KMP思想" class="headerlink" title="KMP思想"></a>KMP思想</h3><p>A = “abababaababacb”；<br>B = “ababacb”。</p><p>我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]!=B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B = a b a b a c bj = 1 2 3 4 5 6 7</code></pre><a id="more"></a><p>此时，A[6]!=B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j’。j’可能是多少呢？仔细想一下，我们发现，j’必须要使得B[1..j]中的头j’个字母和末j’个字母完全相等（这样j变成了j’后才能继续保持i和j的性质）。这个j’当然要越大越好。在这里，B [1..5]=”ababa”，头3个字母和末3个字母都是”aba”。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =     a b a b a c bj =     1 2 3 4 5 6 7</code></pre><p>从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]!=B[j+1]的情况：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =     a b a b a c bj =     1 2 3 4 5 6 7</code></pre><p>由于P[5]=3，因此新的j=3：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =         a b a b a c bj =         1 2 3 4 5 6 7</code></pre><p>这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =             a b a b a c bj =             1 2 3 4 5 6 7</code></pre><p>现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =               a b a b a c bj =             0 1 2 3 4 5 6 7</code></pre><p>终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]=”d”时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。</p><p>这个过程的代码很短（真的很短），我们在这里给出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">j=0;</span><br><span class="line">for i=1 to n do</span><br><span class="line">begin</span><br><span class="line">   while (j&gt;0) and (B[j+1]!=A[i]) do j=P[j];</span><br><span class="line">   if B[j+1]=A[i] then j=j+1;</span><br><span class="line">   if j=m then</span><br><span class="line">   begin</span><br><span class="line">      writeln(&apos;Pattern occurs with shift &apos;,i-m);</span><br><span class="line">      j=P[j];</span><br><span class="line">   end;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>最后的j=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。</p><p>这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。</p><p>现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。</p><p>为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。</p><p>预处理不需要按照P的定义写成O(m^2)甚至O(m^3)的。我们可以通过P[1],P[2],…,P[j-1]的值来获得P[j]的值。对于刚才的B=”ababacb”，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]!=B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：</p><pre><code>    1 2 3 4 5 6 7B = a b a b a c bP = 0 0 1 2 3 ?</code></pre><p>P[5]=3是因为B[1..3]和B[3..5]都是”aba”；而P[3]=1则告诉我们，B[1]、B[3]和B[5]都是”a”。既然P[6]不能由P[5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]!=B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。</p><p>怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P[1]=0;</span><br><span class="line">j=0;</span><br><span class="line">for i=2 to m do</span><br><span class="line">begin</span><br><span class="line">   while (j&gt;0) and (B[j+1]!=B[i]) do j=P[j];</span><br><span class="line">   if B[j+1]=B[i] then j=j+1;</span><br><span class="line">   P[i]=j;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。</p><h3 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h3><p>Note：下面代码实现是考虑下标从0开始，与上述代码略有差别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">bool</span> inited = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">string</span> sp;</span><br><span class="line"><span class="keyword">int</span> nsp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matched_idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">inited = <span class="literal">true</span>;</span><br><span class="line">sp = s;</span><br><span class="line">nsp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sp.size());</span><br><span class="line">p.resize(nsp);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nsp; ++i) &#123;</span><br><span class="line"><span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sp[j + <span class="number">1</span>] != sp[i]) &#123;</span><br><span class="line">j = p[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sp[j + <span class="number">1</span>] == sp[i]) &#123;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">p[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!inited) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not inited!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">matched_idx.clear();</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sp[j + <span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">j = p[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sp[j + <span class="number">1</span>] == s[i]) &#123;</span><br><span class="line">++j;</span><br><span class="line"><span class="keyword">if</span> (j == nsp - <span class="number">1</span>) &#123;</span><br><span class="line">matched_idx.push_back(i - nsp + <span class="number">1</span>);</span><br><span class="line">j = p[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_matched_idx</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(matched_idx.size()); ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; matched_idx[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *kmp = <span class="keyword">new</span> KMP;</span><br><span class="line">kmp-&gt;init(<span class="string">"ababacb"</span>);</span><br><span class="line">kmp-&gt;match(<span class="string">"abababaababacb"</span>);</span><br><span class="line">kmp-&gt;show_matched_idx();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;p&gt;Note：本文转自Matrix67博客，有改动。&lt;/p&gt;
&lt;h3 id=&quot;KMP思想&quot;&gt;&lt;a href=&quot;#KMP思想&quot; class=&quot;headerlink&quot; title=&quot;KMP思想&quot;&gt;&lt;/a&gt;KMP思想&lt;/h3&gt;&lt;p&gt;A = “abababaababacb”；&lt;br&gt;B = “ababacb”。&lt;/p&gt;
&lt;p&gt;我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]!=B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 1 2 3 4 5 6 7 8 9 ……
A = a b a b a b a a b a b …
B = a b a b a c b
j = 1 2 3 4 5 6 7
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="KMP" scheme="http://tashi711.xyz/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 952. Largest Component Size by Common Factor」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-952/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-952/</id>
    <published>2018-12-22T14:57:02.000Z</published>
    <updated>2018-12-21T17:43:15.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/largest-component-size-by-common-factor/description/" target="_blank" rel="noopener">LeetCode 952. Largest Component Size by Common Factor</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个由不同正整数的组成的非空数组 A，考虑下面的图：<br>有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；<br>只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。<br>返回图中最大连通组件的大小。</p><p><strong>示例 1：</strong><br>输入：[4,6,15,35]<br>输出：4</p><p><strong>示例 2：</strong><br>输入：[20,50,9,63]<br>输出：2</p><p><strong>示例 3：</strong><br>输入：[2,3,6,7,4,12,21,39]<br>输出：8</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= 100000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很简单的一道题，将一个数的所有因数用并查集合并一下就好。<br>求因数就根号的时间就好（不一定非要是质因数）。<br>最后统计一下。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N\sqrt{M})$，其中M为数值范围，考虑并查集复杂度为常数。<br>空间复杂度为$O(M)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">110000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[kMaxN];</span><br><span class="line"><span class="keyword">int</span> s[kMaxN];</span><br><span class="line"><span class="keyword">int</span> fact[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_p</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[k] != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> p[k] = find_p(p[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pu = find_p(u);</span><br><span class="line"><span class="keyword">int</span> pv = find_p(v);</span><br><span class="line"><span class="keyword">if</span> (pu != pv) &#123;</span><br><span class="line">p[pv] = pu;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestComponentSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : A) &#123;</span><br><span class="line"><span class="keyword">int</span> rt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(k + <span class="number">0.5</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= rt; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (k % i == <span class="number">0</span>) &#123;</span><br><span class="line">adj.push_back(i);</span><br><span class="line">adj.push_back(k / i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (adj.empty()) &#123;</span><br><span class="line">adj.push_back(k);</span><br><span class="line">&#125;</span><br><span class="line">fact[k] = adj[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(adj.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">merge(adj[<span class="number">0</span>], adj[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : A) &#123;</span><br><span class="line"><span class="keyword">int</span> u = find_p(fact[k]);</span><br><span class="line"><span class="keyword">if</span> (++s[u] &gt; ans) &#123;</span><br><span class="line">ans = s[u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1&#123; <span class="number">4</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">35</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2&#123; <span class="number">20</span>, <span class="number">50</span>, <span class="number">9</span>, <span class="number">63</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a3&#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">39</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;largestComponentSize(a1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;largestComponentSize(a2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;largestComponentSize(a3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/largest-component-size-by-common-factor/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 952. Largest Component Size by Common Factor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个由不同正整数的组成的非空数组 A，考虑下面的图：&lt;br&gt;有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；&lt;br&gt;只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。&lt;br&gt;返回图中最大连通组件的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[4,6,15,35]&lt;br&gt;输出：4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[20,50,9,63]&lt;br&gt;输出：2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：[2,3,6,7,4,12,21,39]&lt;br&gt;输出：8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;br&gt;1 &amp;lt;= A[i] &amp;lt;= 100000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://tashi711.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 956. Tallest Billboard」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-956/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-956/</id>
    <published>2018-12-16T14:57:02.000Z</published>
    <updated>2018-12-21T17:18:59.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/tallest-billboard/description/" target="_blank" rel="noopener">LeetCode 956. Tallest Billboard</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。<br>你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。<br>返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。</p><p><strong>示例 1：</strong><br>输入：[1,2,3,6]<br>输出：6<br>解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。</p><p><strong>示例 2：</strong><br>输入：[1,2,3,4,5,6]<br>输出：10<br>解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。</p><p><strong>示例 3：</strong><br>输入：[1,2]<br>输出：0<br>解释：没法安装广告牌，所以返回 0。</p><p><strong>提示：</strong><br>0 &lt;= rods.length &lt;= 20<br>1 &lt;= rods[i] &lt;= 1000<br>钢筋的最大长度最多为 5000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>蛮不错的一道题，先说说暴力的改良，也就是官方第二种题解。<br>这种解法很神奇之处在于不需要题目中后两个限制。<br>之前有一道题跟这个很类似，也是全部枚举会超时，枚举一半不超时。<br>最后根据相等转换为和为0来线性合并。<br>当然这道题标准解法应该是DP，毕竟给了容量限制。<br>一个$O(NS^2)$的算法很容易想到，不过会超时。<br>其实也是通过和为0这种思想去优化了一维，具体看题解就会很明白了。<br>注意C++负下标处理一下。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(NS)$，其中S为和的限制。<br>空间复杂度为$O(NS)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxM = <span class="number">11000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kBias = <span class="number">5500</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxSum = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> k + kBias;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rods)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][idx(<span class="number">0</span>)] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rods.size());</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> r = rods[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = max(-sum, -kMaxSum); j &lt;= min(sum, kMaxSum); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[i - <span class="number">1</span>][idx(j)] != <span class="number">-1</span>) &#123;</span><br><span class="line">f[i][idx(j)] = max(f[i][idx(j)], f[i - <span class="number">1</span>][idx(j)]);</span><br><span class="line">f[i][idx(j + r)] = max(f[i][idx(j + r)], f[i - <span class="number">1</span>][idx(j)] + r);</span><br><span class="line">f[i][idx(j - r)] = max(f[i][idx(j - r)], f[i - <span class="number">1</span>][idx(j)]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum += r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n][idx(<span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a3&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;tallestBillboard(a1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;tallestBillboard(a2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;tallestBillboard(a3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/tallest-billboard/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 956. Tallest Billboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。&lt;br&gt;你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。&lt;br&gt;返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[1,2,3,6]&lt;br&gt;输出：6&lt;br&gt;解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[1,2,3,4,5,6]&lt;br&gt;输出：10&lt;br&gt;解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：[1,2]&lt;br&gt;输出：0&lt;br&gt;解释：没法安装广告牌，所以返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;0 &amp;lt;= rods.length &amp;lt;= 20&lt;br&gt;1 &amp;lt;= rods[i] &amp;lt;= 1000&lt;br&gt;钢筋的最大长度最多为 5000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「安田レイ - きみのうた」</title>
    <link href="http://tashi711.xyz/nihongo/uta/yasudarei-kiminouta/"/>
    <id>http://tashi711.xyz/nihongo/uta/yasudarei-kiminouta/</id>
    <published>2018-12-16T11:03:54.000Z</published>
    <updated>2018-12-16T11:24:57.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="歌曲信息"><a href="#歌曲信息" class="headerlink" title="歌曲信息"></a>歌曲信息</h2><blockquote><ul><li>歌曲：きみのうた</li><li>歌手：安田レイ</li><li>作词：安田レイ、玉井健二、石原理酉</li><li>作曲：飞内将大</li><li>编曲：玉井健二、飞内将大　</li><li>专辑：きみのうた（2017年5月24日发行）</li><li>其他：「夏目友人帳 陸」 ED</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>夏目友人帐第六季的ED，非常好听。<br>算是安田レイ继「Mirror」后的又一金曲吧。</p><a id="more"></a><h2 id="假名歌词"><a href="#假名歌词" class="headerlink" title="假名歌词"></a>假名歌词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">夜明（よあ）けを待（ま）ちながら</span><br><span class="line">静（しず）かに目（め）を閉（と）じて</span><br><span class="line">新（あたら）しい風（かぜ）待（ま）ってただけの</span><br><span class="line">心（こころ）に光（ひかり）さしてく</span><br><span class="line"></span><br><span class="line">おやすみ私（わたし）の一番星（いちばんぼし）</span><br><span class="line">ずっと輝（かがや）き続（つづ）けて</span><br><span class="line">願（ねが）いを叶（かな）えてなんて</span><br><span class="line">言（い）わないよ</span><br><span class="line">そっと見守（みまも）ってるだから</span><br><span class="line"></span><br><span class="line">答（こた）えなんていらないから</span><br><span class="line">ただ聞（き）いて欲（ほ）しい</span><br><span class="line">さよならじゃない</span><br><span class="line">最後（さいご）の言葉（ことば）</span><br><span class="line">きみのうたをきみがいない街（まち）で</span><br><span class="line">歌（うた）い続（つづ）ける</span><br><span class="line"></span><br><span class="line">吹（ふ）く風（かぜ）にさらわれた</span><br><span class="line">きみの匂（にお）いを探（さが）してしまうよ</span><br><span class="line">記憶（きおく）の中（なか）できっと出会（であ）える</span><br><span class="line">どこか遠（とお）い空（そら）で</span><br><span class="line">あの日（ひ）のように</span><br><span class="line">夢（ゆめ）の中（なか）枯（か）れない花（はな）</span><br><span class="line"></span><br><span class="line">駅（えき）のホームの景色（けしき）も</span><br><span class="line">あの日（ひ）から変（か）わったけど</span><br><span class="line">きみが好（す）きだった</span><br><span class="line">赤（あか）いベンチは</span><br><span class="line">冷（つめ）たいままそこにある</span><br><span class="line"></span><br><span class="line">「会（あ）いたい」</span><br><span class="line">何度（なんど）も送（おく）った言葉（ことば）</span><br><span class="line">つぶやくのはもうやめるね</span><br><span class="line">きみの声（こえ）が聞（き）こえるの</span><br><span class="line">前（まえ）に進（すす）めと笑（わら）っていろと</span><br><span class="line"></span><br><span class="line">寂（さび）しくて泣（な）きたくて</span><br><span class="line">でも笑（わら）ってる</span><br><span class="line">誰（だれ）も知（し）らない</span><br><span class="line">ただ2人（ふたり）だけの</span><br><span class="line">あの約束（やくそく）ずっと守（まも）っていよう</span><br><span class="line">どんな時（とき）でも</span><br><span class="line"></span><br><span class="line">今日（きょう）もまた</span><br><span class="line">夢（ゆめ）の中（なか）会（あ）えますように</span><br><span class="line">そこでしか</span><br><span class="line">聞（き）けないかすれた笑（わら）い声（ごえ）</span><br><span class="line">いつか2人（ふたり）で歌（うた）った鼻歌（はなうた）を</span><br><span class="line">胸（むね）に刻（きざ）むよ</span><br><span class="line">瞳（ひとみ）を閉（と）じれば ずっと</span><br><span class="line"></span><br><span class="line">涙（なみだ）に溺（おぼ）れる私（わたし）を包（つつ）んで</span><br><span class="line">おどけてくれたね</span><br><span class="line">「何（なに）泣（な）いてんだよ</span><br><span class="line">大丈夫（だいじょうぶ）だよ」</span><br><span class="line">宝物（たからもの）だよ今（いま）も聞（き）こえる</span><br><span class="line">ほら聞（き）こえてくる</span><br><span class="line"></span><br><span class="line">会（あ）いたくて会（あ）いたくて</span><br><span class="line">胸（むね）が痛（いた）くて</span><br><span class="line">探（さが）してしまうきみによく似（に）た</span><br><span class="line">急（いそ）ぎ足（あし）の広（ひろ）い背中（せなか）を</span><br><span class="line">またあの日（ひ）のように</span><br><span class="line"></span><br><span class="line">答（こた）えなんていらないから</span><br><span class="line">ただ聞（き）いて欲（ほ）しい</span><br><span class="line">さよならなんかじゃない</span><br><span class="line">笑顔（えがお）のありがとう</span><br><span class="line">きみのうたをきみがいない街（まち）で</span><br><span class="line">歌い続（つづ）ける</span><br><span class="line">夢（ゆめ）の中（なか）枯（か）れない花（はな）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;歌曲信息&quot;&gt;&lt;a href=&quot;#歌曲信息&quot; class=&quot;headerlink&quot; title=&quot;歌曲信息&quot;&gt;&lt;/a&gt;歌曲信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌曲：きみのうた&lt;/li&gt;
&lt;li&gt;歌手：安田レイ&lt;/li&gt;
&lt;li&gt;作词：安田レイ、玉井健二、石原理酉&lt;/li&gt;
&lt;li&gt;作曲：飞内将大&lt;/li&gt;
&lt;li&gt;编曲：玉井健二、飞内将大　&lt;/li&gt;
&lt;li&gt;专辑：きみのうた（2017年5月24日发行）&lt;/li&gt;
&lt;li&gt;其他：「夏目友人帳 陸」 ED&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;夏目友人帐第六季的ED，非常好听。&lt;br&gt;算是安田レイ继「Mirror」后的又一金曲吧。&lt;/p&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ウタ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%82%A6%E3%82%BF/"/>
    
    
      <category term="夏目友人帳" scheme="http://tashi711.xyz/tags/%E5%A4%8F%E7%9B%AE%E5%8F%8B%E4%BA%BA%E5%B8%B3/"/>
    
      <category term="安田レイ" scheme="http://tashi711.xyz/tags/%E5%AE%89%E7%94%B0%E3%83%AC%E3%82%A4/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 42. Trapping Rain Water」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-42/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-42/</id>
    <published>2018-12-16T03:57:02.000Z</published>
    <updated>2018-12-16T11:02:59.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LeetCode 42. Trapping Rain Water</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p><strong>示例:</strong><br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较水，基本稍微想想就能想到最优解，一开始还想过NlogN用RMQ来解，结果其实没必要。<br>官方题解没看了，因为对于在短时间内能想到最优解的水题，复杂度更高的解法就没什么意义了。<br>找到最高点，分别从左和从右扫到最高点，记录当前扫过的最高值，遇到更高就更新，遇到更低就填到目前的高度。<br>线性时间，且仅需要常数额外空间。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N)$。<br>（额外）空间复杂度为 $O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(height.size());</span><br><span class="line"><span class="keyword">int</span> maxh = <span class="number">-1</span>, p = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (height[i] &gt; maxh) &#123;</span><br><span class="line">maxh = height[i];</span><br><span class="line">p = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (height[i] &lt;= cur) &#123;</span><br><span class="line">res += cur - height[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur = height[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; p; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (height[i] &lt;= cur) &#123;</span><br><span class="line">res += cur - height[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur = height[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;trap(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 42. Trapping Rain Water&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;br&gt;数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，可以接 6 个单位的雨水（蓝色部分表示雨水）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br&gt;输出: 6&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 32. Longest Valid Parentheses」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-32/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-32/</id>
    <published>2018-12-13T03:57:02.000Z</published>
    <updated>2018-12-12T17:28:24.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">LeetCode 32. Longest Valid Parentheses</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><p><strong>示例 1:</strong></p><p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”</p><p><strong>示例 2:</strong></p><p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>基本按照官方题解走就行了，对于额外优化空间不考虑的话，推荐栈的做法。<br>考虑一个子问题：假如知道起点，那么从起点开始扫，看到‘(’就++，‘)’就--，减到负数停止。<br>那么枚举起点，就有了一个n方的算法，也是我最先能想到的，官方题解直接忽略了这个级别的复杂度。<br>其实最后优化空间的做法就是在这个算法的基础上，某些子串因为‘(’过多而计算不到。<br>那么这些子串在反向扫的时候一定能算到，因此只需做来回两次扫描。<br>每次不光以最开始为起点，如果中间断掉了，新的‘(’开始也要继续扫下去，最优解一定在这种情况下能找到。<br>下面的解法换一种记录方式，也就是官方题解中left与right的差，与起始位置。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>（额外）空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, now = <span class="number">0</span>, st = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">++now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">--now;</span><br><span class="line"><span class="keyword">if</span> (now == <span class="number">0</span>) &#123;</span><br><span class="line">ans = max(ans, i - st + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (now &lt; <span class="number">0</span>) &#123;</span><br><span class="line">now = <span class="number">0</span>;</span><br><span class="line">st = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">now = <span class="number">0</span>;</span><br><span class="line">st = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">++now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">--now;</span><br><span class="line"><span class="keyword">if</span> (now == <span class="number">0</span>) &#123;</span><br><span class="line">ans = max(ans, st - i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (now &lt; <span class="number">0</span>) &#123;</span><br><span class="line">now = <span class="number">0</span>;</span><br><span class="line">st = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"(()"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">")()())"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;longestValidParentheses(s1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;longestValidParentheses(s2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/longest-valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 32. Longest Valid Parentheses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入: “(()”&lt;br&gt;输出: 2&lt;br&gt;解释: 最长有效括号子串为 “()”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入: “)()())”&lt;br&gt;输出: 4&lt;br&gt;解释: 最长有效括号子串为 “()()”&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 23. Merge k Sorted Lists」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-23/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-23/</id>
    <published>2018-12-04T03:57:02.000Z</published>
    <updated>2018-12-12T17:22:04.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">LeetCode 23. Merge k Sorted Lists</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]</p><p>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>官方的solution基本给出了所有思路和复杂度分析了。<br>最快的方法是$O(N\log K)$的，最容易想到的就是用优先队列了，也是这里给出的解法。<br>当然用类似于归并排序中的归并思路，也可以做到这个复杂度，官方题解也给出了，不过显然没有直接用优先队列优雅。<br>优先队列直接用STL自带的就好，当然也可以用堆实现。<br>之后的代码我都给出可以本地直接运行的完整版，把样例都放进去。<br>注意两个坑：<br>1、输入的某链表可能为空；<br>2、输入的vector本身可能为空。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N\log K)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode * <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; q;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(lists.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (lists[i]) &#123;</span><br><span class="line">q.push(make_pair(lists[i]-&gt;val, i));</span><br><span class="line">lists[i] = lists[i]-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> u = q.top().first, p = q.top().second;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">auto</span> *res = <span class="keyword">new</span> ListNode(u);</span><br><span class="line"><span class="keyword">auto</span> *tail = res;</span><br><span class="line"><span class="keyword">if</span> (lists[p]) &#123;</span><br><span class="line">q.push(make_pair(lists[p]-&gt;val, p));</span><br><span class="line">lists[p] = lists[p]-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">u = q.top().first, p = q.top().second;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">auto</span> *tmp = <span class="keyword">new</span> ListNode(u);</span><br><span class="line">tail-&gt;next = tmp;</span><br><span class="line">tail = tmp;</span><br><span class="line"><span class="keyword">if</span> (lists[p]) &#123;</span><br><span class="line">q.push(make_pair(lists[p]-&gt;val, p));</span><br><span class="line">lists[p] = lists[p]-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="keyword">auto</span> x1 = ListNode(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> x2 = ListNode(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">auto</span> x3 = ListNode(<span class="number">5</span>);</span><br><span class="line">x1.next = &amp;x2;</span><br><span class="line">x2.next = &amp;x3;</span><br><span class="line"><span class="keyword">auto</span> x4 = ListNode(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> x5 = ListNode(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> x6 = ListNode(<span class="number">4</span>);</span><br><span class="line">x4.next = &amp;x5;</span><br><span class="line">x5.next = &amp;x6;</span><br><span class="line"><span class="keyword">auto</span> x7 = ListNode(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> x8 = ListNode(<span class="number">6</span>);</span><br><span class="line">x7.next = &amp;x8;</span><br><span class="line"><span class="built_in">vector</span>&lt;ListNode*&gt; adj = &#123; &amp;x1, &amp;x4, &amp;x7 &#125;;</span><br><span class="line"><span class="keyword">auto</span> ans = s-&gt;mergeKLists(adj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ans; p; p = p-&gt;next) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/merge-k-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 23. Merge k Sorted Lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;[&lt;br&gt;  1-&amp;gt;4-&amp;gt;5,&lt;br&gt;  1-&amp;gt;3-&amp;gt;4,&lt;br&gt;  2-&amp;gt;6&lt;br&gt;]&lt;/p&gt;
&lt;p&gt;输出: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="链表" scheme="http://tashi711.xyz/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="优先队列" scheme="http://tashi711.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 10. Regular Expression Matching」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-10/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-10/</id>
    <published>2018-11-25T03:57:02.000Z</published>
    <updated>2018-12-12T17:23:25.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">LeetCode 10. Regular Expression Matching</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符。<br>‘*‘ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</p><p><strong>说明:</strong></p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p><p><strong>示例 1:</strong></p><p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p><p><strong>示例 2:</strong></p><p>输入:<br>s = “aa”<br>p = “a*“<br>输出: true<br>解释: ‘*‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。</p><p><strong>示例 3:</strong></p><p>输入:<br>s = “ab”<br>p = “.*“<br>输出: true<br>解释: “.*“ 表示可匹配零个或多个(‘*‘)任意字符(‘.’)。</p><p><strong>示例 4:</strong></p><p>输入:<br>s = “aab”<br>p = “c*a*b”<br>输出: true<br>解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p><p><strong>示例 5:</strong></p><p>输入:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>输出: false</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>基本按照官方题解走就行了。虽然比较坑没有给数据范围，不过想到平方的算法基本想到是最优解了。<br>由于不知道规模，用vector开动态空间了。<br>DP思路很简单，布尔量dp(i, j)表示分别到i和j为止有没有匹配。<br>官方给的解答很别扭，正向推导用的是记忆化搜索，其实完全没必要，这里给出直接迭代的正向推导：<br>首先初始状态，dp(0, 0)为0，表示两个空串可以匹配。<br>注意DP范围，由于星号*的存在，s空串可能与p非空串匹配，因此i从0到size(s)，j从1到size(p)。<br>如果p的当前位不是星号，简单判断能否匹配。<br>如果p的当前位是星号，有两种情况转移到子状态：<br>一是p中的这两位（不妨令为c*，c可能是.）不匹配任何s中的符号，那么只用看dp(i, j-2)<br>二是p中的这两位匹配了至少s中一个的符号（当然s[j]必须是c或者c为.）。<br>那么在s中把这个符号去掉应该依然匹配，于是看dp(i-1, j)<br>计算过程注意下标是否有效即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(NM)$，其中N、M分别为两个字符串的长度范围。<br>空间复杂度为$O(NM)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_match_char</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">char</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == y || y == <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line"><span class="keyword">int</span> m = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(p.size());</span><br><span class="line">s = <span class="string">'\0'</span> + s;</span><br><span class="line">p = <span class="string">'\0'</span> + p;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line"><span class="keyword">bool</span> cur = i &gt; <span class="number">0</span> &amp;&amp; is_match_char(s[i], p[j]);</span><br><span class="line"><span class="keyword">if</span> (p[j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">f[i][j] = f[i][j - <span class="number">2</span>] ||</span><br><span class="line">i &gt; <span class="number">0</span> &amp;&amp; is_match_char(s[i], p[j - <span class="number">1</span>]) &amp;&amp; f[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f[i][j] = cur &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n][m];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/regular-expression-matching/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 10. Regular Expression Matching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。&lt;/p&gt;
&lt;p&gt;‘.’ 匹配任意单个字符。&lt;br&gt;‘*‘ 匹配零个或多个前面的元素。&lt;br&gt;匹配应该覆盖整个字符串 (s) ，而不是部分字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;s 可能为空，且只包含从 a-z 的小写字母。&lt;br&gt;p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;s = “aa”&lt;br&gt;p = “a”&lt;br&gt;输出: false&lt;br&gt;解释: “a” 无法匹配 “aa” 整个字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;s = “aa”&lt;br&gt;p = “a*“&lt;br&gt;输出: true&lt;br&gt;解释: ‘*‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;s = “ab”&lt;br&gt;p = “.*“&lt;br&gt;输出: true&lt;br&gt;解释: “.*“ 表示可匹配零个或多个(‘*‘)任意字符(‘.’)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 4:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;s = “aab”&lt;br&gt;p = “c*a*b”&lt;br&gt;输出: true&lt;br&gt;解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 5:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入:&lt;br&gt;s = “mississippi”&lt;br&gt;p = “mis*is*p*.”&lt;br&gt;输出: false&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「PSYCHIC LOVER - タギルチカラ！」</title>
    <link href="http://tashi711.xyz/nihongo/uta/psychic-lover-tagiruchikara/"/>
    <id>http://tashi711.xyz/nihongo/uta/psychic-lover-tagiruchikara/</id>
    <published>2018-11-24T17:03:54.000Z</published>
    <updated>2018-11-25T10:11:12.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="歌曲信息"><a href="#歌曲信息" class="headerlink" title="歌曲信息"></a>歌曲信息</h2><blockquote><ul><li>歌曲：タギルチカラ！</li><li>歌手：PSYCHIC LOVER</li><li>作词：YOFFY</li><li>作曲：YOFFY</li><li>专辑：Dアニメ「デジモンクロスウォーズ 時を駆ける少年ハンターたち」挿入歌 タギルチカラ！（2012年2月29日发行）</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数码宝贝6比较后面的进化曲，很燃，算是6系列最喜欢的歌了。</p><a id="more"></a><h2 id="假名歌词"><a href="#假名歌词" class="headerlink" title="假名歌词"></a>假名歌词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">火花散（ひばなち）らして</span><br><span class="line">デッドヒート</span><br><span class="line">気（き）は抜（ぬ）けないぜ</span><br><span class="line">DANGER ZONE</span><br><span class="line">燃（も）える闘志（とうし）</span><br><span class="line">熱（あつ）く響（ひび）きあってるんだ</span><br><span class="line">気分最強（きぶんさいきょう）</span><br><span class="line">スーパースター</span><br><span class="line">ギリギリ攻（せ）める</span><br><span class="line">HUNTING TIME</span><br><span class="line">行（い）くぜ</span><br><span class="line">オレの挑戦（ちょうせん）がはじまる</span><br><span class="line"></span><br><span class="line">狙（ねら）いを定（さだ）めるのさ</span><br><span class="line">はなて今（いま）</span><br><span class="line">情熱（じょうねつ）で溶（と）けちゃいそうな</span><br><span class="line">あふれるオレのパワー</span><br><span class="line"></span><br><span class="line">タギルチカラ</span><br><span class="line">止（と）められない</span><br><span class="line">無限（むげん）のエナジー</span><br><span class="line">渦巻（うずま）くよ</span><br><span class="line">今世界（いませかい）は</span><br><span class="line">オレを待（ま）ってる</span><br><span class="line">ヒートアップ</span><br><span class="line">急上昇突（きゅうじょうしょうつ）きぬけろ</span><br><span class="line">全（すべ）てを賭（か）けて</span><br><span class="line">挑（いど）むバトル</span><br><span class="line">一（ひと）つになれ</span><br><span class="line">HEART &amp; HEART</span><br><span class="line"></span><br><span class="line">チョットつまづいたって</span><br><span class="line">ヘコたれんな ココから</span><br><span class="line">一発逆転（いっぱつぎゃくてん）</span><br><span class="line">それが合言葉（あいことば）なんだ</span><br><span class="line">カッコつけて転（ころ）んでも</span><br><span class="line">笑（わら）い合（あ）える仲間（なかま）が</span><br><span class="line">いればできる</span><br><span class="line">前（まえ）だけ向（む）いて</span><br><span class="line">さぁダッシュ</span><br><span class="line"></span><br><span class="line">時間（じかん）の壁（かべ）を超（こ）えて</span><br><span class="line">繋（つな）がったこのキズナ</span><br><span class="line">見（み）えないシンパシー</span><br><span class="line">全（すべ）てを変（か）えるパワー</span><br><span class="line"></span><br><span class="line">タギル（たぎる）血潮高鳴（ちしおたかな）る胸（むね）</span><br><span class="line">キラめく閃光（せんこう） 引（ひ）き裂（さ）くよ</span><br><span class="line">この宇宙（うちゅう）のド真（ま）ん中（なか）で</span><br><span class="line">HOLD UP</span><br><span class="line">拳（こぶし）を振（ふ）り上（あ）げろ</span><br><span class="line">暗闇（くらやみ）の中希望求（なかきぼうもと）め</span><br><span class="line">一（ひと）つになれ</span><br><span class="line">BURNING HEART</span><br><span class="line"></span><br><span class="line">真（ま）っ直ぐに届（とど）け</span><br><span class="line">未来（みらい）のメッセージ</span><br><span class="line">光射（ひかりさ）す場所（ばしょ）を探（さが）してるんだ</span><br><span class="line">夢追（ゆめお）いかけて</span><br><span class="line">自由（じゆう）に飛（と）べるまで</span><br><span class="line"></span><br><span class="line">タギルタギルチカラ</span><br><span class="line">止（と）められない</span><br><span class="line">無限（むげん）のエナジー渦巻（うずま）くよ</span><br><span class="line">今世界（いませかい）はオレを待ってる</span><br><span class="line">ヒートアップ</span><br><span class="line">急上昇（きゅうじょうしょう） 突（つ）きぬけろ</span><br><span class="line">この宇宙（うちゅう）のド真（ま）ん中（なか）で</span><br><span class="line">HOLD UP</span><br><span class="line">振（ふ）り上（あ）げろ</span><br><span class="line">今世界（いませかい）はオレを待（ま）ってる</span><br><span class="line">ヒートアップ</span><br><span class="line">突（つ）きぬけろ</span><br><span class="line">全（すべ）てを賭けて挑（いど）むバトル</span><br><span class="line">一（ひと）つになれ</span><br><span class="line">HEART &amp; HEART</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;歌曲信息&quot;&gt;&lt;a href=&quot;#歌曲信息&quot; class=&quot;headerlink&quot; title=&quot;歌曲信息&quot;&gt;&lt;/a&gt;歌曲信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌曲：タギルチカラ！&lt;/li&gt;
&lt;li&gt;歌手：PSYCHIC LOVER&lt;/li&gt;
&lt;li&gt;作词：YOFFY&lt;/li&gt;
&lt;li&gt;作曲：YOFFY&lt;/li&gt;
&lt;li&gt;专辑：Dアニメ「デジモンクロスウォーズ 時を駆ける少年ハンターたち」挿入歌 タギルチカラ！（2012年2月29日发行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;数码宝贝6比较后面的进化曲，很燃，算是6系列最喜欢的歌了。&lt;/p&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ウタ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%82%A6%E3%82%BF/"/>
    
    
      <category term="PSYCHIC LOVER" scheme="http://tashi711.xyz/tags/PSYCHIC-LOVER/"/>
    
      <category term="数码宝贝" scheme="http://tashi711.xyz/tags/%E6%95%B0%E7%A0%81%E5%AE%9D%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>「二分图匹配算法」浅析</title>
    <link href="http://tashi711.xyz/programming/dsaa/bipartite-graph-matching/"/>
    <id>http://tashi711.xyz/programming/dsaa/bipartite-graph-matching/</id>
    <published>2018-11-13T03:15:34.000Z</published>
    <updated>2018-12-12T16:41:49.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>二分图（Bipartite Graph）又叫二部图，是图的一种。</p><h3 id="二分图的定义"><a href="#二分图的定义" class="headerlink" title="二分图的定义"></a>二分图的定义</h3><p>设 G = (V, E) 是一个无向图。如果顶点集 V 可分割为两个互不相交的子集 X 和 Y，并且图中每条边连接的两个顶点一个在 X 中，另一个在 Y 中，则称图 G 为二分图。</p><h3 id="二分图的匹配"><a href="#二分图的匹配" class="headerlink" title="二分图的匹配"></a>二分图的匹配</h3><p>给定一个二分图 G，在 G 的某个子图 M 中，任意两条边都不依附于同一个顶点，则称 M 是 G 的一个匹配（Matching）。</p><a id="more"></a><h2 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h2><p>匹配的边数尽量多</p><p>选择边数最大的匹配称为二分图的最大匹配问题（Maximal Matching Problem）</p><h3 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h3><p>增广路径（Augmenting Path）的定义：设 M 为二分图 G 已匹配边的集合，若 P 是图 G 中一条连通两个未匹配顶点的路径（P 的起点在 X 部，终点在 Y 部，反之亦可），并且属 M 的边和不属 M 的边（即已匹配和待匹配的边）在 P 上交替出现，则称 P 为相对于 M 的一条增广路径。</p><p>单独的一条连接两个未匹配点的边显然也是增广路径。</p><p>不属于匹配的边要多一条</p><p>如果从 M 中抽走增广路径 P 中属于匹配的边，并在 M 中加入 P 中不属于匹配的边，也就是将增广路所有的边进行“反色”，则可以得到匹配 M’</p><p>容易发现这样修改以后，匹配仍然是合法的，但是匹配数增加了一对。</p><p>当不能再找到增广路径时，就得到了一个最大匹配，这就是匈牙利算法的思路。</p><h3 id="匈牙利算法（Hungarian-Algorithm）"><a href="#匈牙利算法（Hungarian-Algorithm）" class="headerlink" title="匈牙利算法（Hungarian Algorithm）"></a>匈牙利算法（Hungarian Algorithm）</h3><p>匈牙利数学家Edmonds于1965年提出</p><p>算法步骤：<br>(1) 置 M 为空<br>(2) 找出一条增广路径 P，通过取反操作获得更大的匹配 M’ 代替 M<br>(3) 重复 (2) 操作直到找不出增广路径为止</p><h3 id="如何寻找增广路径"><a href="#如何寻找增广路径" class="headerlink" title="如何寻找增广路径"></a>如何寻找增广路径</h3><p>dfs（深度优先搜索）</p><p>从 X 部一个未匹配的顶点 u 开始，找一个未访问的邻接点 v（v 一定是 Y 部顶点）。对于 v，分两种情况：<br>(1) 如果 v 未匹配，则已经找到一条增广路<br>(2) 如果 v 已经匹配，则取出 v 的匹配顶点 w（w 一定是 X 部顶点)，边 (w, v) 目前是匹配的，根据“取反”的想法，要将 (w, v) 改为未匹配，(u, v) 改为匹配，能实现这一点的条件是看从 w 为起点能否新找到一条增广路径 P’。如果行，则 u – v – P’ 就是一条以 u 为起点的增广路径。每个起点找一次，最多找 O(V) 次。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>在dfs时，注意标记访问过的 Y 部的顶点，这样如果一个 Y 部的点 v 被证实无法增广后，后面 X 部有连向 v 的边就不用再访问了，可以保证每次dfs最多只将整张图访问一次，时间复杂度为 O(E)  ，每次在主过程中开始一次dfs前，所有的顶点都是未标记的。</p><p>总的时间复杂度：O(VE) </p><h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><p>1957年，Kuhn和Munkras提出（居然比匈牙利算法早？？？）</p><p>解决最佳完美匹配（最佳完备匹配可以等价转换）</p><p>最佳：权值和最大</p><p>匹配数最大：完备匹配；X 部点数等于 Y 部的完备匹配：完美匹配</p><p>通常要求完全二分图（任意 (x, y) 间一定有边，完备匹配一定存在，用虚拟点补足，添加权值为 0 的边，则完美匹配一定存在）</p><h3 id="可行顶标"><a href="#可行顶标" class="headerlink" title="可行顶标"></a>可行顶标</h3><p>对于原图中的任意一个结点定义一个顶标值。一般用数组 lx(x) 记录集合 X 中的结点顶标值，用数组 ly(y) 记录集合 Y 中的结点顶标值。 </p><p>可行顶标：对于原图中任意一条边 (x, y) 都有：lx(x) + ly(y) &gt;= w(x, y)</p><p>如果原图一个完美匹配 M 中所有的边 (i, j) 都有 lx[i] + ly[j] = w[i,j] 成立，则 M 是图 G 的一个最佳匹配（因为任意一个匹配的权值之和肯定小于等于所有结点的顶标之和）。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>算法步骤：<br>(1) 初始化可行顶标的值<br>(2) 用匈牙利算法寻找完美匹配<br>(3) 若未找到完美匹配则修改可行顶标的值<br>(4) 重复 (2) (3) 直到找到完美匹配为止</p><p>初始化：<br>l(x) = maxw(x, y)<br>l(y) = 0<br>一定可行</p><h3 id="如何修改顶标"><a href="#如何修改顶标" class="headerlink" title="如何修改顶标"></a>如何修改顶标</h3><p>对于正在增广的增广路径上属于集合 X 的所有点减去一个常数delta，属于集合 Y 的所有点加上一个常数delta。<br>考虑图中任意一条边 (i, j) ，i∈X，j∈Y，有以下4种情况：<br>i 和 j 都属于增广路，那么 lx[i] − delta + ly[j] + delta = lx[i] + ly[j]，值不变，(i, j) 可行性不变，能匹配的还能，不能的还不能<br>i 属于增广路，j 不属于增广路，那么 lx[i] − delta + ly[j] 的值减小，也就是原来不能匹配的现在可能匹配了。<br>i 不属于增广路，j 属于增广路，那么 lx[i] + ly[j] + delta 的值增大，也就是说原来不能匹配的现在也不能匹配。<br>i, j 都不属于增广路，那么 lx[i] 和 ly[j] 都不会加减常数delta值不变， (i, j) 可行性不变，能匹配的还能，不能的还不能。</p><h3 id="如何取delta"><a href="#如何取delta" class="headerlink" title="如何取delta"></a>如何取delta</h3><p>为了保证 lx(i) + ly(j) &gt;= w(i, j)，取第二种情况的 lx[i] + ly[j] − w(i, j) 的最小值作为delta。（寻找复杂度：完全图 O(E) = O(V^2)）</p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>每次标号一定有一条边加入可匹配，即每次增广最多标号 O(V) 次 </p><p>总体：增广 O(V) 次 * 标号 O(V) 次 * 找 delta O(V^2) = O(V^4) </p><p>优化：找 delta 的边正好是匈牙利算法访问时不能匹配的边，因此在做匈牙利算法时记录更新跟当前节点 j 相连的节点 i 的 lx[i] + ly[j] − w(i, j) 的最小值，找 delta O(V) 遍历没有在增广路径上的 j 即可。</p><p>总体：增广 O(V) 次 * 标号 O(V) 次 * 找 delta O(V) = O(V^3) </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题提出&quot;&gt;&lt;a href=&quot;#问题提出&quot; class=&quot;headerlink&quot; title=&quot;问题提出&quot;&gt;&lt;/a&gt;问题提出&lt;/h2&gt;&lt;p&gt;二分图（Bipartite Graph）又叫二部图，是图的一种。&lt;/p&gt;
&lt;h3 id=&quot;二分图的定义&quot;&gt;&lt;a href=&quot;#二分图的定义&quot; class=&quot;headerlink&quot; title=&quot;二分图的定义&quot;&gt;&lt;/a&gt;二分图的定义&lt;/h3&gt;&lt;p&gt;设 G = (V, E) 是一个无向图。如果顶点集 V 可分割为两个互不相交的子集 X 和 Y，并且图中每条边连接的两个顶点一个在 X 中，另一个在 Y 中，则称图 G 为二分图。&lt;/p&gt;
&lt;h3 id=&quot;二分图的匹配&quot;&gt;&lt;a href=&quot;#二分图的匹配&quot; class=&quot;headerlink&quot; title=&quot;二分图的匹配&quot;&gt;&lt;/a&gt;二分图的匹配&lt;/h3&gt;&lt;p&gt;给定一个二分图 G，在 G 的某个子图 M 中，任意两条边都不依附于同一个顶点，则称 M 是 G 的一个匹配（Matching）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分图匹配" scheme="http://tashi711.xyz/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>「ササノマリイ - タカラバコ」</title>
    <link href="http://tashi711.xyz/nihongo/uta/sasanomaly-takarabako/"/>
    <id>http://tashi711.xyz/nihongo/uta/sasanomaly-takarabako/</id>
    <published>2018-11-12T16:15:55.000Z</published>
    <updated>2018-11-25T10:02:18.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="歌曲信息"><a href="#歌曲信息" class="headerlink" title="歌曲信息"></a>歌曲信息</h2><blockquote><ul><li>歌曲：タカラバコ</li><li>歌手：ササノマリイ</li><li>作词：ササノマリイ</li><li>作曲：ササノマリイ</li><li>专辑：タカラバコ(期間生産限定盤)（2016年11月30日发行）</li><li>其他：「夏目友人帳 伍」 OP</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>夏目友人帐第五季的OP，挺暖的一首歌。</p><a id="more"></a><h2 id="假名歌词"><a href="#假名歌词" class="headerlink" title="假名歌词"></a>假名歌词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">空（うつ）ろに空見（そらみ）た</span><br><span class="line">君（きみ）はまだ覚（おぼ）えてるかな</span><br><span class="line">見過（みす）ごした季節（きせつ）も</span><br><span class="line">不確（ふたし）かな感情（かんじょう）で</span><br><span class="line"></span><br><span class="line">心（こころ）の隅（すみ）っこでも</span><br><span class="line">欠片（かけら）になれたなら</span><br><span class="line">君（きみ）のあの笑顔（えがお）が</span><br><span class="line">あるべき場所（ばしょ）にあるといいな</span><br><span class="line"></span><br><span class="line">この時間（じかん）が　過（す）ぎてゆくなら</span><br><span class="line">君（きみ）と共（とも）に　いられたのなら</span><br><span class="line">見（み）たことのない世界（せかい）</span><br><span class="line">見（み）られるような気（き）がして</span><br><span class="line"></span><br><span class="line">いつかこの言葉（ことば）も　伝（つた）わるのなら</span><br><span class="line">空（そら）へ落（お）ちて　しまわぬように</span><br><span class="line">何処（どこ）かの裏（うら）に残（のこ）した思（おも）い出（で）も</span><br><span class="line">宝箱（たからばこ）にしまって</span><br><span class="line"></span><br><span class="line">夕暮夢見（ゆうぐれゆめみ）た</span><br><span class="line">今（いま）はもう望（のぞ）まない夢（ゆめ）</span><br><span class="line">変（か）わってく感覚（かんかく）も</span><br><span class="line">置（お）いてかないように</span><br><span class="line"></span><br><span class="line">未（ま）だ見（み）ぬ不安（ふあん）ならば</span><br><span class="line">立（た）ち止（ど）まればいいの</span><br><span class="line">君（きみ）のその心（こころ）が</span><br><span class="line">あるべき場所（ばしょ）にあればいいよ</span><br><span class="line"></span><br><span class="line">声繋（こえつな）いで　願（ねが）い届（とど）いて</span><br><span class="line">へたくそでも　少（すこ）しずつでも</span><br><span class="line">描（えか）いた想（おも）いも明日（あす）も</span><br><span class="line">ひとつになると信（しん）じて</span><br><span class="line"></span><br><span class="line">いつかその言葉（ことば）も　きっと届（とど）くよ</span><br><span class="line">空（そら）にとけて　忘（わす）れぬように</span><br><span class="line">思（おも）い出（だ）す声（こえ）も色（いろ）も褪（あ）せないように</span><br><span class="line">宝箱（たからばこ）にしまって</span><br><span class="line"></span><br><span class="line">ひとりぼっちにしてほしい僕（ぼく）が</span><br><span class="line">消（き）えてしまいたいと願（ねが）ったあの日（ひ）も</span><br><span class="line">悲（かな）しみで染（そ）まる記憶（きおく）も抱（だ）きしめて</span><br><span class="line">そっと未来（みらい）を書（か）き足（た）すよ</span><br><span class="line"></span><br><span class="line">きっと空落（そらお）ちてく僕（ぼく）を</span><br><span class="line">笑（わら）っている君（きみ）のことも</span><br><span class="line">居（い）ない僕（ぼく）が遺（のこ）せたもの</span><br><span class="line">居（い）ない君（きみ）が伝（つた）えたこと</span><br><span class="line"></span><br><span class="line">この時間（じかん）が　いつか消（き）えても</span><br><span class="line">君（きみ）と共（とも）に　いられたのなら</span><br><span class="line">まだ見（み）えない世界（せかい）も</span><br><span class="line">見（み）られる気（き）がしてるよ</span><br><span class="line"></span><br><span class="line">きっとその想（おも）いも　届（とど）けにゆくよ</span><br><span class="line">もう落（お）として　しまわぬように</span><br><span class="line">芽生（めば）え始（はじ）めた心（こころ）のありったけを</span><br><span class="line">宝箱（たからばこ）にしまって</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;歌曲信息&quot;&gt;&lt;a href=&quot;#歌曲信息&quot; class=&quot;headerlink&quot; title=&quot;歌曲信息&quot;&gt;&lt;/a&gt;歌曲信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌曲：タカラバコ&lt;/li&gt;
&lt;li&gt;歌手：ササノマリイ&lt;/li&gt;
&lt;li&gt;作词：ササノマリイ&lt;/li&gt;
&lt;li&gt;作曲：ササノマリイ&lt;/li&gt;
&lt;li&gt;专辑：タカラバコ(期間生産限定盤)（2016年11月30日发行）&lt;/li&gt;
&lt;li&gt;其他：「夏目友人帳 伍」 OP&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;夏目友人帐第五季的OP，挺暖的一首歌。&lt;/p&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ウタ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%82%A6%E3%82%BF/"/>
    
    
      <category term="ササノマリイ" scheme="http://tashi711.xyz/tags/%E3%82%B5%E3%82%B5%E3%83%8E%E3%83%9E%E3%83%AA%E3%82%A4/"/>
    
      <category term="夏目友人帳" scheme="http://tashi711.xyz/tags/%E5%A4%8F%E7%9B%AE%E5%8F%8B%E4%BA%BA%E5%B8%B3/"/>
    
  </entry>
  
  <entry>
    <title>「Effective C++ (3rd) 第四部分」小结</title>
    <link href="http://tashi711.xyz/programming/others/effective-cpp-4/"/>
    <id>http://tashi711.xyz/programming/others/effective-cpp-4/</id>
    <published>2018-10-21T03:17:59.000Z</published>
    <updated>2018-12-12T16:42:35.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-C-3rd"><a href="#Effective-C-3rd" class="headerlink" title="Effective C++ (3rd)"></a>Effective C++ (3rd)</h2><blockquote><ul><li>第四部分：Designs and Declarations</li></ul></blockquote><a id="more"></a><h3 id="第四部分：Designs-and-Declarations"><a href="#第四部分：Designs-and-Declarations" class="headerlink" title="第四部分：Designs and Declarations"></a>第四部分：Designs and Declarations</h3><ul><li><p>shared_ptr支持定制删除器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;XXX&gt; create() &#123;</span><br><span class="line">  shared_ptr ret(static_cast&lt;XXX*&gt;(0), getRidOfXXX);</span><br><span class="line">  ret = ...;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pass-by-reference-to-const是有多态的</p></li><li>pass-by-reference-to-const不适用于内置类型、STL迭代器以及函数对象</li><li>不能返回指针或者引用：局部stack、heap、可能同时需要多个的局部static对象</li><li>不使用protected，因为一旦去掉这个变量，所有派生类都会遭到破坏</li><li>用non-member non-friend函数替换member函数可以增加封装性（更少的代码访问private），将便利函数放在不同文件同一命名空间中</li><li>只有当参数在参数列表中才可能被隐式转换，因此如果需要为某个函数的所有参数（包括被this指针所指的隐喻参数）进行类型转换，这个函数必须是non-member的。</li></ul><p>107</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Effective-C-3rd&quot;&gt;&lt;a href=&quot;#Effective-C-3rd&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ (3rd)&quot;&gt;&lt;/a&gt;Effective C++ (3rd)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第四部分：Designs and Declarations&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「hihoCoder - 1848, 1849」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/others/hihocoder-1848-1849/"/>
    <id>http://tashi711.xyz/programming/reports/others/hihocoder-1848-1849/</id>
    <published>2018-10-13T16:11:04.000Z</published>
    <updated>2018-10-19T18:07:40.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="http://hihocoder.com/problemset/problem/1848" target="_blank" rel="noopener">hihoCoder - 1848</a>，<a href="http://hihocoder.com/problemset/problem/1849" target="_blank" rel="noopener">hihoCoder - 1849</a></li><li>来源：hihoCoder</li><li>场次：飞步无人驾驶2018届校园招聘在线笔试A轮</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><h4 id="1848-子数组的和"><a href="#1848-子数组的和" class="headerlink" title="1848 - 子数组的和"></a>1848 - 子数组的和</h4><p>给定一个包含N个整数的数组A = [A1, A2, … AN]，请你计算有多少个子数组B = [Ai, Ai+1, … Aj] (i ≤ j) 满足B中所有整数的和小于K。</p><p><strong>输入</strong><br>第一行包含两个整数N和K。<br>第二行包含N个整数A1, A2, … AN。<br>对于30%的数据，1 ≤ N ≤ 1000<br>对于另外30%的数据，0 &lt; Ai ≤ 100000<br>对于100%的数据，1 ≤ N ≤ 100000 -100000 ≤ Ai ≤ 100000</p><p><strong>输出</strong><br>一个整数，代表答案。</p><p><strong>样例输入</strong><br>4 -1<br>-2 1 -2 3</p><p><strong>样例输出</strong><br>3</p><p><strong>时间限制</strong><br>10000ms</p><p><strong>单点时限</strong><br>1000ms</p><p><strong>内存限制</strong><br>256MB</p><a id="more"></a><h4 id="1849-子数组的中位数"><a href="#1849-子数组的中位数" class="headerlink" title="1849 - 子数组的中位数"></a>1849 - 子数组的中位数</h4><p>给定一个包含N个整数的数组A = [A1, A2, … AN]，请你计算有多少个子数组B = [Ai, Ai+1, … Aj] (i ≤ j) 满足B的中位数是K。<br>注意，本题中位数的定义是：假设子数组B长度为m，那么B的中位数是将B从小到大排序后，第[(m+1)/2]小的数([x]指对x下取整)。这个定义与通常的中位数定义略有不同。</p><p><strong>输入</strong><br>第一行包含两个整数N和K。<br>第二行包含N个整数A1, A2, … AN。<br>对于30%的数据，1 ≤ N ≤ 100<br>对于60%的数据，1 ≤ N ≤ 5000<br>对于100%的数据，1 ≤ N ≤ 100000 -100000 ≤ Ai ≤ 100000</p><p><strong>输出</strong><br>一个整数，代表答案。</p><p><strong>样例输入</strong><br>5 2<br>1 9 2 8 10</p><p><strong>样例输出</strong><br>5</p><p><strong>时间限制</strong><br>10000ms</p><p><strong>单点时限</strong><br>1000ms</p><p><strong>内存限制</strong><br>256MB</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>两道题如出一辙，都是可以转换成动态单点更新询问前缀和的模型，因此考虑树状数组。<br>关于树状数组，可以参见<a href="http://tashi711.xyz/programming/tech-and-algos/binary-indexed-tree/">「树状数组」浅析</a>。</p><p><strong>1848 - 子数组的和</strong><br>这样子区间的个数其实就是前缀和的差小于k的个数。<br>与求逆序对很像，遍历一遍前缀和，当前前缀和为s[i]时，统计前面前缀和有多少个大于s[i]-k的。<br>由于树状数组也是求前缀和的过程（注意这里说的前缀和是树状数组的前缀和，不是前面说的题目中原数组的前缀和，为了区别，后面都将树状数组的前缀和叫做“bit前缀和”），因此可以先求出有多少个小于等于s[i]-k的前缀和（设为cnt），最后累加到答案上的为i-cnt。<br>然后在s[i]的位置加个1就好。<br>注意下面几个细节：<br>1、前缀和的范围太大，不能直接用作树状数组的下标，因此需要离散化的过程，但是又不能完全像求逆序对那样完全利用离散化的结果，因为这些前缀和的绝对大小关系是有用的，因此两个信息（大小和顺序位置）都要保留。<br>2、求小于等于的时候s[i]-k的位置的时候要用upper_bound的前一个位置，因为“等于”的时候是要去掉的（其实分别模拟一下s[i]-k存在与不存在两种情况就知道该用lower_bound的当前位置还是upper_bound的前一个位置）。当然这个时候就会出现取bit前缀和sum(0)的情况，注意边界。<br>3、注意前缀和的边界，因为这里所有的区间都是两个前缀和的差得到的，注意到当一个区间从数组头开始，那么其实会出现“空前缀和”的情况，因此总共应该有n+1个前缀和，其中包含一个和为0的“空前缀和”，这个0也要参与排序离散化，这也是为什么每次统计bit前缀和之后累加到答案上的为i-cnt而不是i-1-cnt，因为位置i前面本来就应该产生i个前缀和而不是i-1个。下面的代码中直接用了前缀和s[0]=0作为“空前缀和”，那么要注意下标范围，因为前缀和的下标为0到n，而树状数组的下标范围为1到n+1。<br>复杂度也就排序、离散化、树状数组的复杂度$O(N\log N)$。</p><p><strong>1849 - 子数组的中位数</strong><br>满足要求的子区间有这样的性质：如果将小于等于k的数看成1，大于k的数看成-1，那么这个区间的和一定大于等于0（条件1），且如果将小于k的数看成1，大于等于k的数看成-1，那么这个区间的和一定小于0（条件2）。<br>那么很容易受到上一道题的启发，先求满足条件1的区间：首先按照将小于等于k的数看成1，大于k的数看成-1求出前缀和s[i]，以这个前缀和为下标（不用离散化，因为范围最多是-n到n，可以统一加上n+1使得下标均为正数，即开一个2n+1大小的树状数组），有多少个小于等于s[i]的前缀和就有多少个这样的区间，然后在s[i]的位置加个1就好。<br>跟上一道题一样，注意“空前缀和”，一开始先在0的位置（即n+1）加1。<br>对于条件2，其实有个小trick，满足条件2的，其实等价于去掉如果将小于k的数看成1，大于等于k的数看成-1，区间和大于等于0的，而将小于k的数看成1，大于等于k的数看成-1又等价于将小于等于k-1的数看成1，大于k-1的数看成-1，也就正好是条件1中将k改为k-1，这样就可以减少一半的代码量。<br>复杂度为树状数组的复杂度$O(N\log N)$。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度均为$O(N\log N)$。<br>空间复杂度均为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><h3 id="1848-子数组的和-1"><a href="#1848-子数组的和-1" class="headerlink" title="1848 - 子数组的和"></a>1848 - 子数组的和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxN = <span class="number">110000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">BinaryIndexedTree(<span class="keyword">int</span> n)</span><br><span class="line">: n(n), a(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= <span class="number">0</span> || p &gt; n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"add("</span> &lt;&lt; p &lt;&lt; <span class="string">", "</span> &lt;&lt; k &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">a[p] += k;</span><br><span class="line">p += lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"get_sum("</span> &lt;&lt; p &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">sum += a[p];</span><br><span class="line">p ^= lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> s[kMaxN];</span><br><span class="line"><span class="keyword">int</span> c[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">c[i] = s[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(c, c + n + <span class="number">1</span>);</span><br><span class="line"><span class="function">BinaryIndexedTree <span class="title">bit</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">int</span> pos_0 = lower_bound(c, c + n + <span class="number">1</span>, <span class="number">0</span>) - c;</span><br><span class="line">bit.add(pos_0 + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> u = upper_bound(c, c + n + <span class="number">1</span>, s[i] - k) - c - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = bit.get_sum(u + <span class="number">1</span>);</span><br><span class="line">ans += i - cnt;</span><br><span class="line"><span class="keyword">int</span> v = lower_bound(c, c + n + <span class="number">1</span>, s[i]) - c;</span><br><span class="line">bit.add(v + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1849-子数组的中位数-1"><a href="#1849-子数组的中位数-1" class="headerlink" title="1849 - 子数组的中位数"></a>1849 - 子数组的中位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxN = <span class="number">110000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">BinaryIndexedTree(<span class="keyword">int</span> n)</span><br><span class="line">: n(n), a(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= <span class="number">0</span> || p &gt; n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"add("</span> &lt;&lt; p &lt;&lt; <span class="string">", "</span> &lt;&lt; k &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">a[p] += k;</span><br><span class="line">p += lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"get_sum("</span> &lt;&lt; p &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">sum += a[p];</span><br><span class="line">p ^= lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> s[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="keyword">sizeof</span> s, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + (a[i] &lt;= k ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinaryIndexedTree <span class="title">bit</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span></span>;</span><br><span class="line">bit.add(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">ans += bit.get_sum(s[i] + n + <span class="number">1</span>);</span><br><span class="line">bit.add(s[i] + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; calc(k) - calc(k - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;http://hihocoder.com/problemset/problem/1848&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hihoCoder - 1848&lt;/a&gt;，&lt;a href=&quot;http://hihocoder.com/problemset/problem/1849&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hihoCoder - 1849&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：hihoCoder&lt;/li&gt;
&lt;li&gt;场次：飞步无人驾驶2018届校园招聘在线笔试A轮&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;h4 id=&quot;1848-子数组的和&quot;&gt;&lt;a href=&quot;#1848-子数组的和&quot; class=&quot;headerlink&quot; title=&quot;1848 - 子数组的和&quot;&gt;&lt;/a&gt;1848 - 子数组的和&lt;/h4&gt;&lt;p&gt;给定一个包含N个整数的数组A = [A1, A2, … AN]，请你计算有多少个子数组B = [Ai, Ai+1, … Aj] (i ≤ j) 满足B中所有整数的和小于K。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;br&gt;第一行包含两个整数N和K。&lt;br&gt;第二行包含N个整数A1, A2, … AN。&lt;br&gt;对于30%的数据，1 ≤ N ≤ 1000&lt;br&gt;对于另外30%的数据，0 &amp;lt; Ai ≤ 100000&lt;br&gt;对于100%的数据，1 ≤ N ≤ 100000 -100000 ≤ Ai ≤ 100000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;br&gt;一个整数，代表答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样例输入&lt;/strong&gt;&lt;br&gt;4 -1&lt;br&gt;-2 1 -2 3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样例输出&lt;/strong&gt;&lt;br&gt;3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间限制&lt;/strong&gt;&lt;br&gt;10000ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单点时限&lt;/strong&gt;&lt;br&gt;1000ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存限制&lt;/strong&gt;&lt;br&gt;256MB&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="树状数组" scheme="http://tashi711.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「POJ 2299 - Ultra-QuickSort」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/others/poj-2299/"/>
    <id>http://tashi711.xyz/programming/reports/others/poj-2299/</id>
    <published>2018-10-12T16:11:04.000Z</published>
    <updated>2018-10-19T17:59:49.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="http://poj.org/problem?id=2299" target="_blank" rel="noopener">POJ 2299 - Ultra-QuickSort</a></li><li>来源：POJ</li><li>场次：Waterloo local 2005.02.05</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给出n个不重复的整数，现在你可以交换任意相邻的两个数，使得最后这n个数保持递增的顺序，求你需要的最少的交换次数。<br>输入数据包含多组测试数据：每一组数据以n开始，（n &lt; 500000，表示这组数据的个数），接下来n个数，表示这一组数据。这些数都是不大于999999999的非负整数。如果n为0，表示结束。这组数据不需处理。</p><p><strong>输入样例：</strong><br>5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0</p><p><strong>输出样例：</strong><br>6<br>0</p><p><strong>时间限制：</strong><br>7s</p><p><strong>空间限制：</strong><br>64M</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题其实是求逆序对的个数。<br>给出两个思路：</p><p><strong>1、归并排序</strong><br>做一次归并排序的过程即可求得所有逆序对的个数，方法就是在合并的过程中如果发现还未合并的前半已序段的首元素比后半已序段的首元素大的话，那么一定会产生目前未合并的前半已序段的个数个逆序对（因为这未合并的前半已序段的元素都比这个后半已序段的首元素大），且很容易发现任何逆序对一定在这两个元素被合并的时候有且仅有一次被统计到（注意到任何两个元素有且仅有一次被合并）。<br>代码就是普通的归并排序加一行代码（下面的“ans += mid - l + 1;”）即可，复杂度也就是排序的复杂度$O(N\log N)$。</p><p><strong>2、树状数组</strong><br>关于树状数组，可以参见<a href="http://tashi711.xyz/programming/tech-and-algos/binary-indexed-tree/">「树状数组」浅析</a>。<br>先将数据离散化，这样不影响结果，既能保证树状数组存的下，又能有意义（数值大小同时也是顺序序号）。<br>遍历一遍数组，那么如果将出现过的数字的位置都放一个1的话，当前数字（a[i]）所能产生的逆序对即为a[i] - 1 - sum(a[i] - 1)，其中sum为前缀和，因为a[i]前面的a[i] - 1个数的位置没有放1的话意味着那个数出现在i后面。<br>然后在a[i]的位置放上1。<br>复杂度为排序、离散化、树状数组的复杂度，即$O(N\log N)$。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度均为$O(N\log N)$。<br>空间复杂度均为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><h3 id="1、归并排序"><a href="#1、归并排序" class="headerlink" title="1、归并排序"></a>1、归并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxN = <span class="number">550000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> c[kMaxN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> mid, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = u;</span><br><span class="line"><span class="keyword">int</span> l = u, r = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= v) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[l] &lt;= a[r]) &#123;</span><br><span class="line">c[p++] = a[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans += mid - l + <span class="number">1</span>;</span><br><span class="line">c[p++] = a[r++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">c[p++] = a[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (r &lt;= v) &#123;</span><br><span class="line">c[p++] = a[r++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt;= v; ++i) &#123;</span><br><span class="line">a[i] = c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == v) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> mid = u + (v - u) / <span class="number">2</span>;</span><br><span class="line">merge_sort(u, mid);</span><br><span class="line">merge_sort(mid + <span class="number">1</span>, v);</span><br><span class="line">merge(u, mid, v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">0L</span>L;</span><br><span class="line">merge_sort(<span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、树状数组"><a href="#2、树状数组" class="headerlink" title="2、树状数组"></a>2、树状数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxN = <span class="number">550000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">BinaryIndexedTree(<span class="keyword">int</span> n)</span><br><span class="line">: n(n), a(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">a[p] += k;</span><br><span class="line">p += lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">sum += a[p];</span><br><span class="line">p ^= lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> c[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">c[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">a[i] = lower_bound(c + <span class="number">1</span>, c + n + <span class="number">1</span>, a[i]) - c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinaryIndexedTree <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">ans += a[i] - <span class="number">1</span> - bit.get_sum(a[i] - <span class="number">1</span>);</span><br><span class="line">bit.add(a[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;http://poj.org/problem?id=2299&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 2299 - Ultra-QuickSort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：POJ&lt;/li&gt;
&lt;li&gt;场次：Waterloo local 2005.02.05&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给出n个不重复的整数，现在你可以交换任意相邻的两个数，使得最后这n个数保持递增的顺序，求你需要的最少的交换次数。&lt;br&gt;输入数据包含多组测试数据：每一组数据以n开始，（n &amp;lt; 500000，表示这组数据的个数），接下来n个数，表示这一组数据。这些数都是不大于999999999的非负整数。如果n为0，表示结束。这组数据不需处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;br&gt;5&lt;br&gt;9&lt;br&gt;1&lt;br&gt;0&lt;br&gt;5&lt;br&gt;4&lt;br&gt;3&lt;br&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;br&gt;6&lt;br&gt;0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间限制：&lt;/strong&gt;&lt;br&gt;7s&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间限制：&lt;/strong&gt;&lt;br&gt;64M&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="树状数组" scheme="http://tashi711.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="归并排序" scheme="http://tashi711.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="逆序对" scheme="http://tashi711.xyz/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
  </entry>
  
  <entry>
    <title>「树状数组」浅析</title>
    <link href="http://tashi711.xyz/programming/dsaa/binary-indexed-tree/"/>
    <id>http://tashi711.xyz/programming/dsaa/binary-indexed-tree/</id>
    <published>2018-10-10T03:15:34.000Z</published>
    <updated>2018-12-12T16:41:44.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>已知数组a[]，元素个数为n，现在要求a数组中i到j区间内的和(1&lt;=i&lt;=j&lt;=n)。</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>我们完全可以存储sum[1,k]，其中k=1,2,……，然后对任意给定的查找区间[i,j]，返回sum[1,j]-sum[1,i-1]。<br>当然这只是没有元素改变的情况下的比较优化的解法，那么对于对于数组中的元素随时变更的情况下呢？</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如果仍然采取这样的方法，则每次数据有更新，则需要将更新的元素后的sum值全部再求一次。假设有m次查询或者更新操作，则时间复杂度将达到m*n了。<br>可以想一下，每次更改的元素可能是比较少的，有时候甚至每次只改变一个元素，但是在用暴力方法求区间和的时候，却对区间内所有的元素都累加了一遍，这样其实造成了许多无谓的运算。这时候也许会想到如果能把一些结果存起来会不会减少很多运算。</p><a id="more"></a><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>构造一种树：Binary Index Tree。</p><h3 id="树的构造"><a href="#树的构造" class="headerlink" title="树的构造"></a>树的构造</h3><p>令这棵树的结点编号为C1,C2,……,Cn，令每个结点的值为如下值的总和：<br>C1 = A1<br>C2 = A1 + A2<br>C3 = A3<br>C4 = A1 + A2 + A3 + A4<br>C5 = A5<br>C6 = A5 + A6<br>C7 = A7<br>C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8<br>……<br>C16 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10 + A11 + A12 + A13 + A14 + A15 + A16<br>其中A为原数组，C为树状数组。<br>这里有一个有趣的性质：设节点编号为x，那么这个节点管辖的区间为2^k（其中k为x二进制末尾0的个数）个元素。<br>因为这个区间最后一个元素必然为Ax，所以有：<br>Cn = A(n – 2^k + 1) + …… + An<br>算这个2^k有一个快捷的办法，即经典的lowbit操作（取最后一个1的位置）：<br>x &amp; (x ^ (x – 1)) 或者 x &amp; -x （通常使用后者）</p><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>当想要查询一个前缀和sum[1,n]时，可以依据如下算法即可：<br>step1：令sum = 0，转到step2；<br>step2：假如n &lt;= 0，算法结束，返回sum值，否则sum = sum + Cn，转到step3；<br>step3：令n = n – lowbit(n)，转到step2。（这里可以用异或运算加快速度。）<br>可以看出，这个算法就是将这一个个区间的和全部加起来，因为n的二进制里最多有log(n)个1，所以查询效率是log(n)的。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>如果更新一个节点，必须更新其所有祖先，最坏情况下为更新第一个元素，最多有log(n)的祖先。<br>给某个结点i加上x的算法如下：<br>step1：当i &gt; n时，算法结束，否则转到step2；<br>step2：Ci = Ci + x，i = i + lowbit(i)，转到step1。</p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">BinaryIndexedTree(<span class="keyword">int</span> n)</span><br><span class="line">: n(n), a(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">a[p] += k;</span><br><span class="line">p += lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">sum += a[p];</span><br><span class="line">p ^= lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他拓展"><a href="#其他拓展" class="headerlink" title="其他拓展"></a>其他拓展</h2><p>树状数组虽然只是解决一类问题（单点更新与区间求和询问），但是由于许多问题都可以巧妙的转变成动态的在单点插值（通常为1）然后随时询问区间和（1的个数）（可以参见<a href="http://tashi711.xyz/programming/reports/others/hihocoder-1848-1849/">「hihoCoder - 1848, 1849」解题报告</a>），并且虽然类似线段树之类的数据结构能够以相同的复杂度处理同样甚至更复杂的问题，但是相比之下树状数组更为简洁，方便coding，因此能够使用到树状数组的地方还是有很多的。<br>可以利用树状数组在O(NlogN)的时间复杂度内巧妙地求出一个规模为N的数组中逆序对的个数（可以参见<a href="http://tashi711.xyz/programming/reports/others/poj-2299/">「POJ 2299 - Ultra-QuickSort」解题报告</a>，解法2），此外，树状数组也可以方便的拓展到二维，感兴趣的话可以多多探索。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题提出&quot;&gt;&lt;a href=&quot;#问题提出&quot; class=&quot;headerlink&quot; title=&quot;问题提出&quot;&gt;&lt;/a&gt;问题提出&lt;/h2&gt;&lt;p&gt;已知数组a[]，元素个数为n，现在要求a数组中i到j区间内的和(1&amp;lt;=i&amp;lt;=j&amp;lt;=n)。&lt;/p&gt;
&lt;h3 id=&quot;前缀和&quot;&gt;&lt;a href=&quot;#前缀和&quot; class=&quot;headerlink&quot; title=&quot;前缀和&quot;&gt;&lt;/a&gt;前缀和&lt;/h3&gt;&lt;p&gt;我们完全可以存储sum[1,k]，其中k=1,2,……，然后对任意给定的查找区间[i,j]，返回sum[1,j]-sum[1,i-1]。&lt;br&gt;当然这只是没有元素改变的情况下的比较优化的解法，那么对于对于数组中的元素随时变更的情况下呢？&lt;/p&gt;
&lt;h3 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h3&gt;&lt;p&gt;如果仍然采取这样的方法，则每次数据有更新，则需要将更新的元素后的sum值全部再求一次。假设有m次查询或者更新操作，则时间复杂度将达到m*n了。&lt;br&gt;可以想一下，每次更改的元素可能是比较少的，有时候甚至每次只改变一个元素，但是在用暴力方法求区间和的时候，却对区间内所有的元素都累加了一遍，这样其实造成了许多无谓的运算。这时候也许会想到如果能把一些结果存起来会不会减少很多运算。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树状数组" scheme="http://tashi711.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 4. Median of Two Sorted Arrays」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-4/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-4/</id>
    <published>2018-10-09T03:57:02.000Z</published>
    <updated>2018-12-12T17:23:21.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">LeetCode 4. Median of Two Sorted Arrays</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。<br>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。<br>你可以假设 nums1 和 nums2 不同时为空。</p><p><strong>示例 1:</strong><br>nums1 = [1, 3]<br>nums2 = [2]<br>中位数是 2.0</p><p><strong>示例 2:</strong><br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>中位数是 (2 + 3)/2 = 2.5</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>基本按照官方题解走就行了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(\log(m+n))$。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(nums1.size());</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(nums2.size());</span><br><span class="line"><span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">swap(nums1, nums2);</span><br><span class="line">swap(m, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">0</span>, v = m, mid = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (u &lt;= v) &#123;</span><br><span class="line"><span class="keyword">int</span> i = (u + v) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j = mid - i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; m &amp;&amp; nums2[j - <span class="number">1</span>] &gt; nums1[i]) &#123;</span><br><span class="line">u = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">v = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ml = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">ml = nums2[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">ml = nums1[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ml = max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">mr = nums2[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">mr = nums1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">mr = min(nums1[i], nums2[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ml + mr) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 4. Median of Two Sorted Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。&lt;br&gt;请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。&lt;br&gt;你可以假设 nums1 和 nums2 不同时为空。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;nums1 = [1, 3]&lt;br&gt;nums2 = [2]&lt;br&gt;中位数是 2.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;nums1 = [1, 2]&lt;br&gt;nums2 = [3, 4]&lt;br&gt;中位数是 (2 + 3)/2 = 2.5&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="二分查找" scheme="http://tashi711.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
