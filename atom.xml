<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tashi711的博客</title>
  
  <subtitle>過去（きのう）に傷付きながらも、信じ続ける理想（ゆめ）を求める。いつか無限（なないろ）に輝き放って、青空（そら）に橋を描く。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tashi711.top/"/>
  <updated>2019-02-20T08:04:12.862Z</updated>
  <id>http://tashi711.top/</id>
  
  <author>
    <name>Tashi711</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「LeetCode 996. Number of Squareful Arrays」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-996/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-996/</id>
    <published>2019-02-22T03:57:03.000Z</published>
    <updated>2019-02-20T08:04:12.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/number-of-squareful-arrays/description/" target="_blank" rel="noopener">LeetCode 996. Number of Squareful Arrays</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。<br>返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。</p><p><strong>示例 1：</strong><br>输入：[1,17,8]<br>输出：2<br>解释：<br>[1,8,17] 和 [17,8,1] 都是有效的排列。</p><p><strong>示例 2：</strong><br>输入：[2,2,2]<br>输出：1</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 12<br>0 &lt;= A[i] &lt;= 1e9</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实应该是标准的状压DP，参考标解2，这里使用暴力枚举也做出来了，当然加了点优化。<br>一开始先建图，用纯暴力枚举所有哈密顿路径，然后分别除以每个重复数字个数的阶乘，TLE。<br>尝试直接在dfs时判断，当前走过某个数字时，不在同一步尝试走跟它相同数值的结点（两个结点完全等价），AC。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N!)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numSquarefulPerms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    ans_ = <span class="number">0</span>;</span><br><span class="line">    n_ = A.size();</span><br><span class="line">    adj_.assign(n_ + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    vst_.assign(n_ + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    f_.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k : A) &#123;</span><br><span class="line">      ++f_[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n_; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsSquare(A[i] + A[j])) &#123;</span><br><span class="line">          adj_[i].push_back(j);</span><br><span class="line">          adj_[j].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; ++i) &#123;</span><br><span class="line">      adj_[n_].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Dfs(<span class="number">0</span>, n_, A);</span><br><span class="line">    <span class="keyword">return</span> ans_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsSquare</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(k) + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">if</span> (rt * rt == k) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> u, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    vst_[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == n_) &#123;</span><br><span class="line">      ++ans_;</span><br><span class="line">      vst_[u] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : adj_[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vst_[v] &amp;&amp; s.find(A[v]) == s.end()) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, v, A);</span><br><span class="line">        s.insert(A[v]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vst_[u] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vst_;</span><br><span class="line">  <span class="keyword">int</span> ans_;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input1 = &#123;<span class="number">1</span>, <span class="number">17</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input2 = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  PrintAns(solution-&gt;numSquarefulPerms(input1));</span><br><span class="line">  PrintAns(solution-&gt;numSquarefulPerms(input2));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/number-of-squareful-arrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 996. Number of Squareful Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="状态压缩DP" scheme="http://tashi711.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    
      <category term="TSP问题" scheme="http://tashi711.top/tags/TSP%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 995. Minimum Number of K Consecutive Bit Flips」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-995/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-995/</id>
    <published>2019-02-21T03:57:03.000Z</published>
    <updated>2019-02-20T08:03:55.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/" target="_blank" rel="noopener">LeetCode 995. Minimum Number of K Consecutive Bit Flips</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。<br>返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。</p><p><strong>示例 1：</strong><br>输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。</p><p><strong>示例 2：</strong><br>输入：A = [1,1,0], K = 2<br>输出：-1<br>解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。</p><p><strong>示例 3：</strong><br>输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 30000<br>1 &lt;= K &lt;= A.length</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很容易想到一个n方的贪心，从左扫到右，如果当前是0，就一定要变成1。<br>可以参考下题解的“开关事件”思路，非常巧妙，可以优化一维复杂度。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      cur ^= flag[i];</span><br><span class="line">      <span class="keyword">if</span> (A[i] == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ans;</span><br><span class="line">        flag[i + K] = <span class="number">1</span>;</span><br><span class="line">        cur ^= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a3 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  PrintAns(solution-&gt;minKBitFlips(a1, <span class="number">1</span>));</span><br><span class="line">  PrintAns(solution-&gt;minKBitFlips(a2, <span class="number">2</span>));</span><br><span class="line">  PrintAns(solution-&gt;minKBitFlips(a3, <span class="number">3</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 995. Minimum Number of K Consecutive Bit Flips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="巧妙" scheme="http://tashi711.top/tags/%E5%B7%A7%E5%A6%99/"/>
    
      <category term="贪心" scheme="http://tashi711.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 301. Remove Invalid Parentheses」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-301/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-301/</id>
    <published>2019-02-20T03:57:03.000Z</published>
    <updated>2019-02-20T07:29:06.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/remove-invalid-parentheses/description/" target="_blank" rel="noopener">LeetCode 301. Remove Invalid Parentheses</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。<br>说明: 输入可能包含了除 ( 和 ) 以外的字符。</p><p><strong>示例 1:</strong><br>输入: “()())()”<br>输出: [“()()()”, “(())()”]</p><p><strong>示例 2:</strong><br>输入: “(a)())()”<br>输出: [“(a)()()”, “(a())()”]</p><p><strong>示例 3:</strong><br>输入: “)(“<br>输出: [“”]</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题解太长就没看了，但是看到复杂度还是放心去码了（所以题目不给数据规模真的有时候挺难受）。首先有一点，括号除外的字母一定不用删掉，因此只需着眼于括号。</p><p>考虑纯暴力回溯，左括号多于右括号时才考虑添加，最坏2^N，记录答案时遇到更长的直接替换掉。我这里使用了一个小小的优化，先求出最优解的长度，然后用这个数据进行可行性剪枝。（或者这个属于最优化剪枝？看怎么理解。）当然了最坏复杂度还是2^N，比如一半左括号接一半右括号：(((…)))…。不过这个剪枝一般情况下可以节省大量时间（至少不用考虑长度了，因为经过可行性剪枝之后到达最后的一定是最长的）。</p><p>那么最优解的长度怎么求呢，其实很简单，线性的遍历一次即可，开一个计数器。遇到左括号计数器+1，遇到右括号如果计数器不为0则-1，最优解多匹配一组括号。</p><p>最后去重用unordered_set即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(2^N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; removeInvalidParentheses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    ans_.clear();</span><br><span class="line">    s_ = s;</span><br><span class="line">    n_ = s_.size();</span><br><span class="line">    CalcLongestLen();</span><br><span class="line">    Dfs(<span class="number">0</span>, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(ans_.begin(), ans_.end());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CalcLongestLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    len_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">          --cnt;</span><br><span class="line">          ++len_;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> <span class="built_in">string</span>&amp; cur, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == n_) &#123;</span><br><span class="line">      ans_.insert(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s_[p] == <span class="string">'('</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; len_) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, cur + <span class="string">'('</span>, left + <span class="number">1</span>, right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n_ - <span class="number">1</span> - p &gt;= len_ * <span class="number">2</span> - left - right) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, cur, left, right);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s_[p] == <span class="string">')'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, cur + <span class="string">')'</span>, left, right + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n_ - <span class="number">1</span> - p &gt;= len_ * <span class="number">2</span> - left - right) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, cur, left, right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n_ - <span class="number">1</span> - p &gt;= len_ * <span class="number">2</span> - left - right) &#123;</span><br><span class="line">      Dfs(p + <span class="number">1</span>, cur + s_[p], left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; ans_;</span><br><span class="line">  <span class="built_in">string</span> s_;</span><br><span class="line">  <span class="keyword">int</span> n_ = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> len_ = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">  ostream_iterator&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt; out_it(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line">  copy(ans.cbegin(), ans.cend(), out_it);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  PrintAns(solution-&gt;removeInvalidParentheses(<span class="string">"()())()"</span>));</span><br><span class="line">  PrintAns(solution-&gt;removeInvalidParentheses(<span class="string">"(a)())()"</span>));</span><br><span class="line">  PrintAns(solution-&gt;removeInvalidParentheses(<span class="string">")("</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/remove-invalid-parentheses/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 301. Remove Invalid Parentheses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="回溯" scheme="http://tashi711.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 295. Find Median from Data Stream」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-295/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-295/</id>
    <published>2019-02-19T03:57:03.000Z</published>
    <updated>2019-02-19T11:16:14.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/find-median-from-data-stream/description/" target="_blank" rel="noopener">LeetCode 295. Find Median from Data Stream</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。<br>例如，<br>[2,3,4] 的中位数是 3<br>[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br>设计一个支持以下两种操作的数据结构：<br>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><p><strong>示例：</strong><br>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p><p><strong>进阶:</strong><br>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？<br>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>不超时的算法，一是用两个堆（优先队列，题解方法3），插入是log时间，可能会移来移去，查找是常数时间，比较清晰。<br>这里主要说说第二种解法，其实就是裸的平衡树，单次插入都是log时间。<br>一般平衡树都可以实现求第k大数的功能，这样查找为log时间，可以优化，因为插入前后求第k大的位置相差不会超过1。<br>仅需判断插入后中间值往哪里移，（如果这个操作被认为是常数时间）插入操作仅需常数时间。<br>考虑使用STL的平衡树（multiset），代码基本与题解相同，使用一个迭代器。<br>要注意这段代码能够运行正确必须保证两点，一是插入操作不影响原先保存的迭代器位置（multiset满足）。<br>二是当插入重复元素时的位置是确定的，multiset在C++11之后是保证插入到相同元素的最后。<br>因此在C++11之前下面的代码其实是不保证正确的，需要注意。<br>至于进阶考虑的问题，如果整数值的规模只有100，可以开100个计数器。<br>维护前缀和在一半以前的位置，这样插入与查找的复杂度都是常数。<br>如果绝大部分数据满足这个，那么可以考虑绝大部分数据用计数器，其他数据再用平衡树。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N \log N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MedianFinder() : ptr_(data_.end()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = data_.size();</span><br><span class="line">    data_.insert(num);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">      ptr_ = data_.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; *ptr_) &#123;</span><br><span class="line">      ptr_ = (n &amp; <span class="number">1</span> ? ptr_ : prev(ptr_));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ptr_ = (n &amp; <span class="number">1</span> ? next(ptr_) : ptr_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = data_.size();</span><br><span class="line">    <span class="keyword">return</span> (*ptr_ + *next(ptr_, n % <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; data_;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MedianFinder obj;</span><br><span class="line">  obj.addNum(<span class="number">1</span>);</span><br><span class="line">  obj.addNum(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; obj.findMedian() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  obj.addNum(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; obj.findMedian() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/find-median-from-data-stream/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 295. Find Median from Data Stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="平衡树" scheme="http://tashi711.top/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 282. Expression Add Operators」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-282/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-282/</id>
    <published>2019-02-18T03:57:03.000Z</published>
    <updated>2019-02-18T11:58:14.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/expression-add-operators/description/" target="_blank" rel="noopener">LeetCode 282. Expression Add Operators</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个仅包含数字 0-9 的字符串和一个目标值，在数字之间添加二元运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。</p><p><strong>示例 1:</strong><br>输入: num = “123”, target = 6<br>输出: [“1+2+3”, “1*2*3”] </p><p><strong>示例 2:</strong><br>输入: num = “232”, target = 8<br>输出: [“2*3+2”, “2+3*2”]</p><p><strong>示例 3:</strong><br>输入: num = “105”, target = 5<br>输出: [“1*0+5”,”10-5”]</p><p><strong>示例 4:</strong><br>输入: num = “00”, target = 0<br>输出: [“0+0”, “0-0”, “0*0”]</p><p><strong>示例 5:</strong><br>输入: num = “3456237490”, target = 9191<br>输出: []</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>标准的回溯题，直接做就好。<br>注意两点，一是题目隐含前导0是不满足要求的，需要处理一下（否则105可以有1*05）。<br>二是可能爆int，比如样例的最后一个，用long long即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>官方给出了$O(N^2 \cdot 3^N)$的推导，当然有一维N是因为拷贝导致的，可以优化掉，不过需要更复杂的处理。<br>时间复杂度为$O(N^2 \cdot 3^N)$。<br>空间复杂度为$O(N^2 \cdot 3^N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">long</span> <span class="keyword">long</span> pre, <span class="keyword">const</span> <span class="built_in">string</span>&amp; cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == n_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sum == target_) &#123;</span><br><span class="line">        ans_.push_back(cur);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val_now = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str_now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt; n_; ++i) &#123;</span><br><span class="line">      val_now = val_now * <span class="number">10</span> + num_[i] - <span class="string">'0'</span>;</span><br><span class="line">      str_now += num_[i];</span><br><span class="line">      <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        Dfs(i + <span class="number">1</span>, val_now, val_now, str_now);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Dfs(i + <span class="number">1</span>, sum - pre + pre * val_now, pre * val_now, cur + <span class="string">'*'</span> + str_now);</span><br><span class="line">        Dfs(i + <span class="number">1</span>, sum + val_now, val_now, cur + <span class="string">'+'</span> + str_now);</span><br><span class="line">        Dfs(i + <span class="number">1</span>, sum - val_now, -val_now, cur + <span class="string">'-'</span> + str_now);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (num_[p] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; addOperators(<span class="built_in">string</span> num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    num_ = num;</span><br><span class="line">    n_ = num.size();</span><br><span class="line">    target_ = target;</span><br><span class="line">    ans_.clear();</span><br><span class="line">    Dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> ans_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans_;</span><br><span class="line">  <span class="built_in">string</span> num_;</span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> target_ = <span class="number">-1L</span>L;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s : ans) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"123"</span>, <span class="number">6</span>));</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"232"</span>, <span class="number">8</span>));</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"105"</span>, <span class="number">5</span>));</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"00"</span>, <span class="number">0</span>));</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"3456237490"</span>, <span class="number">9191</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/expression-add-operators/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 282. Expression Add Operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="回溯" scheme="http://tashi711.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 992. Subarrays with K Different Integers」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-992/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-992/</id>
    <published>2019-02-10T03:57:03.000Z</published>
    <updated>2019-02-17T12:53:02.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/description/" target="_blank" rel="noopener">LeetCode 992. Subarrays with K Different Integers</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。<br>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）<br>返回 A 中好子数组的数目。</p><p><strong>示例 1：</strong><br>输出：A = [1,2,1,2,3], K = 2<br>输入：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</p><p><strong>示例 2：</strong><br>输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= A.length<br>1 &lt;= K &lt;= A.length</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>维护两个窗口，一个是到目前为止个数不超过K的，一个是到目前为止个数小于K的。<br>两者长度相减就是以当前结尾满足要求的个数。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt_long(n + <span class="number">1</span>, <span class="number">0</span>), cnt_short(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> num_long = <span class="number">0</span>, num_short = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx_long = <span class="number">0</span>, idx_short = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> cur = A[i];</span><br><span class="line">      <span class="keyword">if</span> (cnt_long[cur]++ == <span class="number">0</span>) &#123;</span><br><span class="line">        ++num_long;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (num_long &gt; K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt_long[A[idx_long++]] == <span class="number">0</span>) &#123;</span><br><span class="line">          --num_long;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cnt_short[cur]++ == <span class="number">0</span>) &#123;</span><br><span class="line">        ++num_short;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (num_short &gt;= K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt_short[A[idx_short++]] == <span class="number">0</span>) &#123;</span><br><span class="line">          --num_short;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ans += idx_short - idx_long;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; solution-&gt;subarraysWithKDistinct(input1, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; solution-&gt;subarraysWithKDistinct(input2, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/subarrays-with-k-different-integers/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 992. Subarrays with K Different Integers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。&lt;br&gt;（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）&lt;br&gt;返回 A 中好子数组的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输出：A = [1,2,1,2,3], K = 2&lt;br&gt;输入：7&lt;br&gt;解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：A = [1,2,1,3,4], K = 3&lt;br&gt;输出：3&lt;br&gt;解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;br&gt;1 &amp;lt;= A[i] &amp;lt;= A.length&lt;br&gt;1 &amp;lt;= K &amp;lt;= A.length&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://tashi711.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>「Kick Start 2018 Round H」试水</title>
    <link href="http://tashi711.top/programming/reports/others/kick-start-2018-h/"/>
    <id>http://tashi711.top/programming/reports/others/kick-start-2018-h/</id>
    <published>2019-02-09T01:57:24.000Z</published>
    <updated>2019-02-09T11:27:28.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2" target="_blank" rel="noopener">Kick Start 2018 Round H</a></li><li>来源：Google</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="1-Big-Buttons-9pts-13pts"><a href="#1-Big-Buttons-9pts-13pts" class="headerlink" title="1. Big Buttons (9pts, 13pts)"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2/0000000000051136" target="_blank" rel="noopener">1. Big Buttons (9pts, 13pts)</a></h3><h4 id="大致描述"><a href="#大致描述" class="headerlink" title="大致描述"></a>大致描述</h4><p>给定长度N和P个前缀，求只由“R”“B”组成的长度为N的且不以这P个前缀开头的字符串有多少种。<br>T组数据，范围1到100，P范围1到min(2^N, 100)，N范围小数据1到10，大数据1到50。</p><a id="more"></a><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很容易就能想出大数据的解法了，先去掉被其他前缀包含的前缀，保证前缀两两不冲突。<br>然后去掉每个前缀产生的个数（2^(N-L)），L为当前前缀长度。每次去掉的个数一定不会与其他前缀冲突。<br>因此复杂度其实主要是预处理的时间，O(P^2·N)，题解给出了更优的解法：字典树，可以优化一维P。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度为$O(P^2N)$（以下代码）。<br>空间复杂度为$O(PN)$。</p><h4 id="AC代码（C-G-）"><a href="#AC代码（C-G-）" class="headerlink" title="AC代码（C++ (G++)）"></a>AC代码（C++ (G++)）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KickStartSolver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  KickStartSolver() : po2(kMaxN + <span class="number">1</span>) &#123;</span><br><span class="line">    Init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnlineJudge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">      InputAndSolveSingleCase();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LocalTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    po2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kMaxN; ++i) &#123;</span><br><span class="line">      po2[i] = po2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InputAndSolveSingleCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input;</span><br><span class="line">    <span class="keyword">int</span> n, p;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">      input.emplace_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Solve(n, input);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; input)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">char</span> delimiter, <span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++case_cnt &lt;&lt; <span class="string">":"</span> &lt;&lt; delimiter &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputSameLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">' '</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputNewLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">'\n'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> case_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; po2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::Solve(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; input) &#123;</span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; diff;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; si : input) &#123;</span><br><span class="line">    <span class="keyword">bool</span> need_insert = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; to_erase;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; sd : diff) &#123;</span><br><span class="line">      <span class="keyword">bool</span> same = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">int</span> ssi = si.size(), ssd = sd.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ssi &amp;&amp; i &lt; ssd; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si[i] != sd[i]) &#123;</span><br><span class="line">          same = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (same) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssi &lt; ssd) &#123;</span><br><span class="line">          to_erase.push_back(sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          need_insert = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (need_insert) &#123;</span><br><span class="line">      diff.insert(si);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; st : to_erase) &#123;</span><br><span class="line">      diff.erase(st);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = po2[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; sd : diff) &#123;</span><br><span class="line">    ans -= po2[n - sd.size()];</span><br><span class="line">  &#125;</span><br><span class="line">  ss &lt;&lt; ans;</span><br><span class="line">  OutputSameLine(ss.str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::LocalTest() &#123;</span><br><span class="line">  <span class="keyword">int</span> n1 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> n2 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> n3 = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> n4 = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input1&#123;<span class="string">"BBB"</span>, <span class="string">"RB"</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input2&#123;<span class="string">"R"</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input3&#123;<span class="string">"R"</span>, <span class="string">"B"</span>, <span class="string">"RBRB"</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input4&#123;<span class="string">"BRBRBBBRBRRRBBB"</span>, <span class="string">"BRBRBRRRBRRRBRB"</span>,</span><br><span class="line">    <span class="string">"BBBRBBBRBRRRBBB"</span>,<span class="string">"BRBRBRRRBRRRB"</span>, <span class="string">"BRBRBBBRBBBRB"</span>&#125;;</span><br><span class="line">  Solve(n1, input1);</span><br><span class="line">  Solve(n2, input2);</span><br><span class="line">  Solve(n3, input3);</span><br><span class="line">  Solve(n4, input4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;KickStartSolver&gt; solver(<span class="keyword">new</span> KickStartSolver);</span><br><span class="line">  <span class="comment">// solver-&gt;LocalTest();</span></span><br><span class="line">  solver-&gt;OnlineJudge();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Mural-14pts-19pts"><a href="#2-Mural-14pts-19pts" class="headerlink" title="2. Mural (14pts, 19pts)"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2/000000000005118a" target="_blank" rel="noopener">2. Mural (14pts, 19pts)</a></h3><h4 id="大致描述-1"><a href="#大致描述-1" class="headerlink" title="大致描述"></a>大致描述</h4><p>给定N个一位数排成一排，每天先取一个数，第一天任意取，后面只能挨着取过的数取。<br>然后每天会丢一个数，只能从两边随机丢一个且不能是已经取的数，丢掉的数不能再取。<br>问最多得到的数和为多少。<br>1到100组数据，N范围小数据2到100，大数据有一个5×10^6，其余同小数据。</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>其实很容易就能想出大数据的解法了，想到一定能取到任意ceil(N/2)个连续的数就解决了。<br>可以这么取：第一天一定取使得想取的分开两边不长于不想取的长度（有两个的话任意取）。<br>比如下面，x代表不想取的，o代表想取的，#代表最先取的：<br>8个： xxxoooox -&gt; xxxoo##x （均可）<br>9个： xxxooooox -&gt; xxxooo#ox<br>后面当天丢掉哪边，第二天就往哪边取（或者那边已经取完了，此时往剩的一边一直取完到结束）。<br>那么抽象一下，最终问题就是求定长最大子序列和了，O(N)就可以解决。</p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h4 id="AC代码（C-G-）-1"><a href="#AC代码（C-G-）-1" class="headerlink" title="AC代码（C++ (G++)）"></a>AC代码（C++ (G++)）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KickStartSolver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnlineJudge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LocalTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InputAndSolveSingleCase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span>&amp; input)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">char</span> delimiter, <span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++seq_case &lt;&lt; <span class="string">":"</span> &lt;&lt; delimiter &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputSameLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">' '</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputNewLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">'\n'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> seq_case = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::OnlineJudge() &#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    InputAndSolveSingleCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::InputAndSolveSingleCase() &#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  Solve(n, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::Solve(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span>&amp; input) &#123;</span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line">  <span class="keyword">int</span> half = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">  transform(input.cbegin(), input.cend(), back_inserter(val), [](<span class="keyword">char</span> c) &#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">int</span> cur = accumulate(val.cbegin(), val.cbegin() + half, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> ans = cur;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &lt; n; ++i) &#123;</span><br><span class="line">    cur += val[i] - val[i - half];</span><br><span class="line">    ans = max(ans, cur);</span><br><span class="line">  &#125;</span><br><span class="line">  ss &lt;&lt; ans;</span><br><span class="line">  OutputSameLine(ss.str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::LocalTest() &#123;</span><br><span class="line">  Solve(<span class="number">4</span>, <span class="string">"1332"</span>);</span><br><span class="line">  Solve(<span class="number">4</span>, <span class="string">"9583"</span>);</span><br><span class="line">  Solve(<span class="number">3</span>, <span class="string">"616"</span>);</span><br><span class="line">  Solve(<span class="number">10</span>, <span class="string">"1029384756"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;KickStartSolver&gt; solver(<span class="keyword">new</span> KickStartSolver);</span><br><span class="line">  <span class="comment">// solver-&gt;LocalTest();</span></span><br><span class="line">  solver-&gt;OnlineJudge();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Let-Me-Count-The-Ways-20pts-25pts"><a href="#3-Let-Me-Count-The-Ways-20pts-25pts" class="headerlink" title="3. Let Me Count The Ways (20pts, 25pts)"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2/0000000000051189" target="_blank" rel="noopener">3. Let Me Count The Ways (20pts, 25pts)</a></h3><h4 id="大致描述-2"><a href="#大致描述-2" class="headerlink" title="大致描述"></a>大致描述</h4><p>给定N对人排一排，其中M对人不能挨在一起，有多少种方案。<br>1到100组数据，小数据1 ≤ M ≤ N ≤ 100，大数据1 ≤ M ≤ N ≤ 100000。</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>其实比较容易就想到了容斥原理加上一点组合数学求解，只是瓶颈在求组合数需要线性复杂度。<br>哪怕预处理组合数，时间和空间也不够（n方），看了题解恍然大悟，还能用模逆元，就能O(1)求出组合数。<br>预处理阶乘与其模逆元也就O(NlogN)复杂度。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度为$O(N)$（不计预处理复杂度）。<br>空间复杂度为$O(N)$。</p><h4 id="AC代码（C-G-）-2"><a href="#AC代码（C-G-）-2" class="headerlink" title="AC代码（C++ (G++)）"></a>AC代码（C++ (G++)）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KickStartSolver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">200000</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">long</span> <span class="keyword">long</span> kModulus = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">  KickStartSolver() : po2(kMaxN + <span class="number">1</span>), fact(kMaxN + <span class="number">1</span>), fact_inv(kMaxN + <span class="number">1</span>) &#123;</span><br><span class="line">    po2[<span class="number">0</span>] = fact[<span class="number">0</span>] = fact_inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kMaxN; ++i) &#123;</span><br><span class="line">      po2[i] = (po2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % kModulus;</span><br><span class="line">      fact[i] = (fact[i - <span class="number">1</span>] * i) % kModulus;</span><br><span class="line">      fact_inv[i] = ModularInverse(fact[i], kModulus);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnlineJudge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LocalTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InputAndSolveSingleCase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T <span class="title">ExtendedEuclidean</span><span class="params">(T a, T b, T* x, T* y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">      *x = <span class="number">1</span>;</span><br><span class="line">      *y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      T gcd = ExtendedEuclidean(b, a % b, y, x);</span><br><span class="line">      *y -= *x * (a / b);</span><br><span class="line">      <span class="keyword">return</span> gcd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T <span class="title">ModularInverse</span><span class="params">(T a, T n)</span> </span>&#123;</span><br><span class="line">    T x, y;</span><br><span class="line">    T gcd = ExtendedEuclidean(a, n, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span> (gcd != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gcd of "</span> &lt;&lt; a &lt;&lt; <span class="string">" and "</span> &lt;&lt; n &lt;&lt; <span class="string">" is "</span> &lt;&lt; gcd &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fact[n] * fact_inv[k] % kModulus * fact_inv[n - k] % kModulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">char</span> delimiter, <span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++seq_case &lt;&lt; <span class="string">":"</span> &lt;&lt; delimiter &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputCurrentLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">' '</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputNewLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">'\n'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> seq_case = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; po2;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fact;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fact_inv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::OnlineJudge() &#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    InputAndSolveSingleCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::InputAndSolveSingleCase() &#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  Solve(n, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::Solve(<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> cur_sign = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    ans = (ans + cur_sign * Combination(<span class="number">2</span> * n - i, i) * fact[i] % kModulus *</span><br><span class="line">      po2[i] % kModulus * fact[<span class="number">2</span> * (n - i)] % kModulus * Combination(m, i) %</span><br><span class="line">      kModulus) % kModulus;</span><br><span class="line">    cur_sign = -cur_sign;</span><br><span class="line">  &#125;</span><br><span class="line">  ss &lt;&lt; (ans + kModulus) % kModulus;</span><br><span class="line">  OutputCurrentLine(ss.str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::LocalTest() &#123;</span><br><span class="line">  Solve(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  Solve(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  Solve(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">  Solve(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">  Solve(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;KickStartSolver&gt; solver(<span class="keyword">new</span> KickStartSolver);</span><br><span class="line">  <span class="comment">// solver-&gt;LocalTest();</span></span><br><span class="line">  solver-&gt;OnlineJudge();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="试水心得"><a href="#试水心得" class="headerlink" title="试水心得"></a>试水心得</h2><p>之前没刷过Kick Start，只刷过Code Jam，做下最新的题试下水。<br>感觉Kick Start整体难度比Code Jam简单不少。（大概是取样不够？）<br>最大的收获就是完善了这个KickStartSolver的类了，之后实操可以方便很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kick Start 2018 Round H&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：Google&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;1-Big-Buttons-9pts-13pts&quot;&gt;&lt;a href=&quot;#1-Big-Buttons-9pts-13pts&quot; class=&quot;headerlink&quot; title=&quot;1. Big Buttons (9pts, 13pts)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2/0000000000051136&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1. Big Buttons (9pts, 13pts)&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&quot;大致描述&quot;&gt;&lt;a href=&quot;#大致描述&quot; class=&quot;headerlink&quot; title=&quot;大致描述&quot;&gt;&lt;/a&gt;大致描述&lt;/h4&gt;&lt;p&gt;给定长度N和P个前缀，求只由“R”“B”组成的长度为N的且不以这P个前缀开头的字符串有多少种。&lt;br&gt;T组数据，范围1到100，P范围1到min(2^N, 100)，N范围小数据1到10，大数据1到50。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="其他" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Google" scheme="http://tashi711.top/tags/Google/"/>
    
      <category term="扩展欧几里得" scheme="http://tashi711.top/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="容斥原理" scheme="http://tashi711.top/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
      <category term="Kick Start" scheme="http://tashi711.top/tags/Kick-Start/"/>
    
      <category term="字典树" scheme="http://tashi711.top/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="组合数学" scheme="http://tashi711.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「扩展欧几里得算法」与「模逆元」详解</title>
    <link href="http://tashi711.top/programming/dsaa/extended-euclidean/"/>
    <id>http://tashi711.top/programming/dsaa/extended-euclidean/</id>
    <published>2019-02-08T03:17:59.000Z</published>
    <updated>2019-02-17T12:50:39.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>扩展欧几里得算法（Extended Euclidean algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足等式：ax + by = gcd(a, b)。</p><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>在数论中，裴蜀定理（Bézout’s lemma）是一个关于最大公约数的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和m，关于未知数x和y的线性丢番图方程（未知数只能使用整数的整数系数多项式等式）ax+by=m（称为裴蜀等式，Bézout’s identity）有整数解时当且仅当m是a及b的最大公约数d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数。</p><p>例如，12和42的最大公约数是6，则方程12x+42y=6有解。事实上有(-3)×12+1×42=6及4×12+(-1)×42=6。</p><p>特别来说，方程ax+by=1有整数解当且仅当整数a和b互素。</p><a id="more"></a><h3 id="扩展欧几里得求解过程"><a href="#扩展欧几里得求解过程" class="headerlink" title="扩展欧几里得求解过程"></a>扩展欧几里得求解过程</h3><p>有两个数a、b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。这就是扩展欧几里得的做法。</p><p>由辗转相除法可知gcd(a,b)=gcd(b,a%b)。所以由ax+by=gcd(a,b)可得bx*+(a%b)y*=gcd(a,b)。第二个式子变形可得ay*+b(x1-(a/b)×y*)=gcd(a,b)，则有x=y*，y=(x*-(a/b)×y*)。当b=0时，gcd(a,b)=a，则有1×a+0×b=0，即x=1，y=0。</p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ExtendedEuclidean</span><span class="params">(T a, T b, T* x, T* y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    *x = <span class="number">1</span>;</span><br><span class="line">    *y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    T gcd = ExtendedEuclidean(b, a % b, y, x);</span><br><span class="line">    *y -= *x * (a / b);</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模逆元"><a href="#模逆元" class="headerlink" title="模逆元"></a>模逆元</h2><p>模逆元也称为模倒数。一整数a对同余n之模逆元是指满足以下公式的整数b<br>$$a^{-1} \equiv b \; ({\rm mod} \; n)$$<br>也可以写成以下的式子<br>$$ab \equiv 1 \; ({\rm mod} \; n)$$<br>由上面提到的裴蜀定理，整数a对模数n之模逆元存在的充分必要条件是a和n互质，若此模逆元存在，在模数n下的除法可以用和对应模逆元的乘法来达成。之前写了一篇“「取余」那些事”，其中关于除法取余的部分就在此详述。通常实际中模数n为一个大质数（比如10^9+7），此时比模数小的任意正整数一定与n互质，逆元一定存在。</p><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ModularInverse</span><span class="params">(T a, T n)</span> </span>&#123;</span><br><span class="line">  T x, y;</span><br><span class="line">  T gcd = ExtendedEuclidean(a, n, &amp;x, &amp;y);</span><br><span class="line">  <span class="keyword">if</span> (gcd != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gcd of "</span> &lt;&lt; a &lt;&lt; <span class="string">" and "</span> &lt;&lt; n &lt;&lt; <span class="string">" is "</span> &lt;&lt; gcd &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科 - 扩展欧几里得</a>.</li><li><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">维基百科 - 裴蜀定理</a>.</li><li><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">维基百科 - 模逆元</a>.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扩展欧几里得算法&quot;&gt;&lt;a href=&quot;#扩展欧几里得算法&quot; class=&quot;headerlink&quot; title=&quot;扩展欧几里得算法&quot;&gt;&lt;/a&gt;扩展欧几里得算法&lt;/h2&gt;&lt;p&gt;扩展欧几里得算法（Extended Euclidean algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足等式：ax + by = gcd(a, b)。&lt;/p&gt;
&lt;h3 id=&quot;裴蜀定理&quot;&gt;&lt;a href=&quot;#裴蜀定理&quot; class=&quot;headerlink&quot; title=&quot;裴蜀定理&quot;&gt;&lt;/a&gt;裴蜀定理&lt;/h3&gt;&lt;p&gt;在数论中，裴蜀定理（Bézout’s lemma）是一个关于最大公约数的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和m，关于未知数x和y的线性丢番图方程（未知数只能使用整数的整数系数多项式等式）ax+by=m（称为裴蜀等式，Bézout’s identity）有整数解时当且仅当m是a及b的最大公约数d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数。&lt;/p&gt;
&lt;p&gt;例如，12和42的最大公约数是6，则方程12x+42y=6有解。事实上有(-3)×12+1×42=6及4×12+(-1)×42=6。&lt;/p&gt;
&lt;p&gt;特别来说，方程ax+by=1有整数解当且仅当整数a和b互素。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="扩展欧几里得" scheme="http://tashi711.top/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="模逆元" scheme="http://tashi711.top/tags/%E6%A8%A1%E9%80%86%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>「取余」那些事</title>
    <link href="http://tashi711.top/programming/others/sth-about-module/"/>
    <id>http://tashi711.top/programming/others/sth-about-module/</id>
    <published>2019-02-05T03:17:59.000Z</published>
    <updated>2019-02-17T12:54:47.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="取余那些事"><a href="#取余那些事" class="headerlink" title="取余那些事"></a>取余那些事</h2><p>通常取余使用在数论中或者程序语言中。这里我们主要考虑C++中的取余操作。</p><h3 id="带余除法"><a href="#带余除法" class="headerlink" title="带余除法"></a>带余除法</h3><p><strong>定义：</strong>带余除法（也称为欧几里德除法）是数学中的一种基本算术计算方式。给定一个被除数a和一个除数b，带余除法给出一个整数q和一个介于一定范围的余数r，使得a=bq+r成立。一般限定余数的范围在0与b之间，也有限定在-b/2与b/2之间。这样的限定都是为了使得满足等式的q有且仅有一个。这时候的q称为带余除法的商。带余除法一般表示为：a÷b=q…r，表达为：“a除以b等于q，余r”。最常见的带余除法是整数与整数的带余除法（被除数a和除数b都是整数），但实数与整数乃至实数与实数的带余除法也有应用。对一般的抽象代数系统，能够进行带余除法的都是具有欧几里德性质的系统。如果余数为零，则称b整除a。一般约定除数b不能为0。</p><p><strong>基本定理：</strong>带余除法限定了余数的范围，使得商唯一存在。整数与整数的带余除法中，余数的范围通常是{0,1,…,|b|-1}这样的b个元素的集合。被除数为实数的带余除法中，常常会使用介于0和除数|b|之间（大于等于0，严格小于|b|）的半开闭区间作为余数的范围；另一种常见的范围是大于等于-|b|/2，严格小于|b|/2。带余除法的基本定理说明：整数与整数的带余除法中，只要余数的范围是|b|个整数，并且任何两个数之差都不是b的倍数，那么带余除法的商唯一存在；被除数为实数的除法中，只要余数的范围是一个如同长度为|b|的半开半闭区间，那么带余除法的商唯一存在。</p><a id="more"></a><h3 id="取余定义"><a href="#取余定义" class="headerlink" title="取余定义"></a>取余定义</h3><p>取余（modulo），又称取模、模除，是一个数除以另一个数的余数。</p><p><strong>一般定义：</strong>给定两个正整数：被除数a和除数n，a modulo n (缩写为a mod n)得到的是使用欧几里德除法时a/n的余数。 举个例子：计算表达式“5 mod 2”得到1，因为5÷2=2…1（5除以2商2余1）；而“9 mod 3”得到0，因为9÷3=3…0。</p><p>通常情况下a和n都是整数，但许多计算系统允许浮点数取模等。在C++中，“%”运算符只能作用于整数类型的取余运算，实数的取余使用<code>fmod</code>与<code>remainder</code>函数（C++11之后使用<code>std::fmod</code>与<code>std::remainder</code>），分别对应上面所述带余除法基本定理中的两种余数范围规定。本文主要考虑整数的取余，实数不多做介绍，有兴趣可以查阅相关资料。</p><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>数学上，同余（congruence modulo）是数论中的一种等价关系。当两个整数除以同一个正整数，若得相同余数，则二整数同余。同余是抽象代数中的同余关系的原型。最先引用同余的概念与同余符号“≡”者为德国数学家高斯。</p><p>两个整数a、b，若它们除以正整数m所得的余数相等，则称a、b对于模m同余，记作a ≡ b (mod m)，读作a同余于b模m，或读作a与b关于模m同余。比如26 ≡ 14 (mod 12)。</p><p>同余是离散数学乃至计算机科学的基础知识点，本文将直接使用同余的相关结论。</p><h3 id="加法取余"><a href="#加法取余" class="headerlink" title="加法取余"></a>加法取余</h3><p>用C++解决的实际问题中，通常考虑(正整数+正整数)%正整数，此时有<br>$$ (a+b)\%m \equiv (a\%m+b\%m)\%m $$<br>考虑一连串正整数的加法，最终和的结果取余等价于对每个加数取余后相加（的同时取余后再相加）的结果再取余。通常模数为10^n+m形式（比如10^9+7这样）的数字，不超过整数最大范围的一半，那么整个计算过程均可使用同样的类型而不需扩大。即所有加数都在int范围内，那么计算时可以全程使用int而无需使用long long，只需注意每次最多进行两个数相加，且每次结果必须取余。</p><h3 id="乘法取余"><a href="#乘法取余" class="headerlink" title="乘法取余"></a>乘法取余</h3><p>乘法与加法类似，用C++解决的实际问题中，通常考虑(正整数×正整数)%正整数，此时有<br>$$ (a×b)\%m \equiv (a\%m×b\%m)\%m $$<br>考虑一连串正整数的乘法，最终积的结果取余等价于对每个乘数取余后相乘（的同时取余后再相乘）的结果再取余。在乘法中，计算过程需要用到两倍size的类型来存放积的结果。比如int×int需要使用long long，且同样每次最多进行两个数相乘，每次结果必须取余。</p><h3 id="减法取余"><a href="#减法取余" class="headerlink" title="减法取余"></a>减法取余</h3><p>减法可以类比加法，但需注意即使考虑(正整数-正整数)%正整数，结果也可能为负数，此时就要考虑负数相关的取余操作了。</p><p>C++11以后规定，整除（/）的商一律向0取整（切除小数部分），如果m%n不等于0，则它的符号与m相同。令m和n是整数且n非0，除了-m导致溢出的特殊情况（C++中最小整数的负数仍是它本身，补码为100…0），其他任何时候，(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。比如：21/-5结果是-4，21%-5结果是1；-21/-8结果是2，-21%-8结果是-5。</p><p>此时回到我们的问题，(a-b)%m的结果就不一定等于(a%m-b%m)%m了，但是我们能知道(a-b)%m（令为u）是在-m到m之间，而(a%m-b%m)%m（令为v）也是在-m到m之间，并且他们要么相等，要么相差一个m（且此时他们一定不同符号。为什么？留给读者自行思考）。如果此时能够知道结果的符号，那么就可以确定正确答案了，比如当已知a大于b时，用(v+m)%m一定能得到u（这也是实际编程中最常遇到的情况与最常用的方式）。</p><p>同理，考虑一连串有正有负的加减运算最后取模，先计算出对其中每个参与运算的数字取余后再进行加减（的同时取余后再相加减）的结果再取余的这个数v，再根据实际判断是否需要加上或减去m得到正确结果。</p><h3 id="除法取余"><a href="#除法取余" class="headerlink" title="除法取余"></a>除法取余</h3><p>除法取余就没有以上三种运算那么容易了，毕竟不能对参与除法的运算数先分别取余后再相除（读者很容易就能想出反例），其实这部分内容涉及到互质、模逆元等等，我单独写一篇文章“「扩展欧几里得算法」与「模逆元」详解”来讲述这部分内容，此处不展开讨论了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%B8%A6%E4%BD%99%E9%99%A4%E6%B3%95" target="_blank" rel="noopener">维基百科 - 带余除法</a>.</li><li><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4" target="_blank" rel="noopener">维基百科 - 模除</a>.</li><li><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98" target="_blank" rel="noopener">维基百科 - 同余</a>.</li><li>C++ Primer 5th.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;取余那些事&quot;&gt;&lt;a href=&quot;#取余那些事&quot; class=&quot;headerlink&quot; title=&quot;取余那些事&quot;&gt;&lt;/a&gt;取余那些事&lt;/h2&gt;&lt;p&gt;通常取余使用在数论中或者程序语言中。这里我们主要考虑C++中的取余操作。&lt;/p&gt;
&lt;h3 id=&quot;带余除法&quot;&gt;&lt;a href=&quot;#带余除法&quot; class=&quot;headerlink&quot; title=&quot;带余除法&quot;&gt;&lt;/a&gt;带余除法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;带余除法（也称为欧几里德除法）是数学中的一种基本算术计算方式。给定一个被除数a和一个除数b，带余除法给出一个整数q和一个介于一定范围的余数r，使得a=bq+r成立。一般限定余数的范围在0与b之间，也有限定在-b/2与b/2之间。这样的限定都是为了使得满足等式的q有且仅有一个。这时候的q称为带余除法的商。带余除法一般表示为：a÷b=q…r，表达为：“a除以b等于q，余r”。最常见的带余除法是整数与整数的带余除法（被除数a和除数b都是整数），但实数与整数乃至实数与实数的带余除法也有应用。对一般的抽象代数系统，能够进行带余除法的都是具有欧几里德性质的系统。如果余数为零，则称b整除a。一般约定除数b不能为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本定理：&lt;/strong&gt;带余除法限定了余数的范围，使得商唯一存在。整数与整数的带余除法中，余数的范围通常是{0,1,…,|b|-1}这样的b个元素的集合。被除数为实数的带余除法中，常常会使用介于0和除数|b|之间（大于等于0，严格小于|b|）的半开闭区间作为余数的范围；另一种常见的范围是大于等于-|b|/2，严格小于|b|/2。带余除法的基本定理说明：整数与整数的带余除法中，只要余数的范围是|b|个整数，并且任何两个数之差都不是b的倍数，那么带余除法的商唯一存在；被除数为实数的除法中，只要余数的范围是一个如同长度为|b|的半开半闭区间，那么带余除法的商唯一存在。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="其他" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="取余" scheme="http://tashi711.top/tags/%E5%8F%96%E4%BD%99/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 982. Triples with Bitwise AND Equal To Zero」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-982/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-982/</id>
    <published>2019-01-31T03:57:03.000Z</published>
    <updated>2019-01-31T10:02:44.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/description/" target="_blank" rel="noopener">LeetCode 982. Triples with Bitwise AND Equal To Zero</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个整数数组 A，找出索引为 (i, j, k) 的三元组，使得：<br>0 &lt;= i &lt; A.length<br>0 &lt;= j &lt; A.length<br>0 &lt;= k &lt; A.length<br>A[i] &amp; A[j] &amp; A[k] == 0，其中 &amp; 表示按位与（AND）操作符。</p><p><strong>示例：</strong><br>输入：[2,1,3]<br>输出：12<br>解释：我们可以选出如下 i, j, k 三元组：<br>(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1<br>(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2<br>(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1<br>(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3<br>(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1<br>(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2<br>(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1<br>(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3<br>(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2<br>(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2<br>(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1<br>(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 1000<br>0 &lt;= A[i] &lt; 2^16</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较容易想到的一道题，就先预处理分别与0~2^16-1相与等于0的数有多少，复杂度为O(NM)，其中M为A[i]的规模。<br>之后只需枚举前两个数，第三个数就能O(1)得出有多少个。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(NM + N^2)$。<br>空间复杂度为$O(N + M)$（额外只需$O(M)$）。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxV = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(kMaxV, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kMaxV; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((k &amp; i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    ++cnt[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : A) &#123;</span><br><span class="line">                ans += cnt[i &amp; j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input1&#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.countTriplets(input1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/triples-with-bitwise-and-equal-to-zero/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 982. Triples with Bitwise AND Equal To Zero&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个整数数组 A，找出索引为 (i, j, k) 的三元组，使得：&lt;br&gt;0 &amp;lt;= i &amp;lt; A.length&lt;br&gt;0 &amp;lt;= j &amp;lt; A.length&lt;br&gt;0 &amp;lt;= k &amp;lt; A.length&lt;br&gt;A[i] &amp;amp; A[j] &amp;amp; A[k] == 0，其中 &amp;amp; 表示按位与（AND）操作符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br&gt;输入：[2,1,3]&lt;br&gt;输出：12&lt;br&gt;解释：我们可以选出如下 i, j, k 三元组：&lt;br&gt;(i=0, j=0, k=1) : 2 &amp;amp; 2 &amp;amp; 1&lt;br&gt;(i=0, j=1, k=0) : 2 &amp;amp; 1 &amp;amp; 2&lt;br&gt;(i=0, j=1, k=1) : 2 &amp;amp; 1 &amp;amp; 1&lt;br&gt;(i=0, j=1, k=2) : 2 &amp;amp; 1 &amp;amp; 3&lt;br&gt;(i=0, j=2, k=1) : 2 &amp;amp; 3 &amp;amp; 1&lt;br&gt;(i=1, j=0, k=0) : 1 &amp;amp; 2 &amp;amp; 2&lt;br&gt;(i=1, j=0, k=1) : 1 &amp;amp; 2 &amp;amp; 1&lt;br&gt;(i=1, j=0, k=2) : 1 &amp;amp; 2 &amp;amp; 3&lt;br&gt;(i=1, j=1, k=0) : 1 &amp;amp; 1 &amp;amp; 2&lt;br&gt;(i=1, j=2, k=0) : 1 &amp;amp; 3 &amp;amp; 2&lt;br&gt;(i=2, j=0, k=1) : 3 &amp;amp; 2 &amp;amp; 1&lt;br&gt;(i=2, j=1, k=0) : 3 &amp;amp; 1 &amp;amp; 2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 1000&lt;br&gt;0 &amp;lt;= A[i] &amp;lt; 2^16&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.top/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 980. Unique Paths III」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-980/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-980/</id>
    <published>2019-01-30T03:57:03.000Z</published>
    <updated>2019-01-31T09:51:33.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/unique-paths-iii/description/" target="_blank" rel="noopener">LeetCode 980. Unique Paths III</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在二维网格 grid 上，有 4 种类型的方格：<br>1 表示起始方格。且只有一个起始方格。<br>2 表示结束方格，且只有一个结束方格。<br>0 表示我们可以走过的空方格。<br>-1 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。</p><p><strong>示例 1：</strong><br>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>输出：2<br>解释：我们有以下两条路径：</p><ol><li>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</li><li>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</li></ol><p><strong>示例 2：</strong><br>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]<br>输出：4<br>解释：我们有以下四条路径： </p><ol><li>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</li><li>(0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</li><li>(0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</li><li>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</li></ol><p><strong>示例 3：</strong><br>输入：[[0,1],[2,0]]<br>输出：0<br>解释：<br>没有一条路能完全穿过每一个空的方格一次。<br>请注意，起始和结束方格可以位于网格中的任意位置。</p><p><strong>提示：</strong><br>1 &lt;= grid.length * grid[0].length &lt;= 20</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实看数据规模基本知道挺明显的状压DP，只是无论是转移还是数据处理都稍微麻烦一点。<br>此题用了直接DP，发现会超时，几乎做了所有优化（起点终点的可行性、只考虑lowbit或者相邻4个点而不去枚举）才勉强过。<br>推荐用记忆化搜索，因为确实很多状态都是没有必要计算的。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N \cdot 2^N)$，其中N为grid.length * grid[0].length的规模。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution() &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i) &#123;</span><br><span class="line">            h[k] = i;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; f;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        f.clear();</span><br><span class="line">        g.clear();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    f[&#123;i, j&#125;] = <span class="number">0</span>;</span><br><span class="line">                    g[<span class="number">0</span>] = &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    f[&#123;i, j&#125;] = <span class="number">1</span>;</span><br><span class="line">                    g[<span class="number">1</span>] = &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[&#123;i, j&#125;] = cnt;</span><br><span class="line">                    g[cnt] = &#123; i, j &#125;;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">1</span> &lt;&lt; cnt, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cnt, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">1</span> &lt;&lt; cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == (<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>) &#123;</span><br><span class="line">                    t = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> curj = lowbit(t); t; t ^= curj, curj = lowbit(t)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = h[curj];</span><br><span class="line">                <span class="keyword">int</span> chdi = i ^ curj;</span><br><span class="line">                <span class="keyword">int</span> u = g[j].first, v = g[j].second;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line">                <span class="keyword">if</span> (u != <span class="number">0</span> &amp;&amp; grid[u - <span class="number">1</span>][v] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    adj.push_back(f[&#123;u - <span class="number">1</span>, v&#125;]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (u != n - <span class="number">1</span> &amp;&amp; grid[u + <span class="number">1</span>][v] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    adj.push_back(f[&#123;u + <span class="number">1</span>, v&#125;]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="number">0</span> &amp;&amp; grid[u][v - <span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    adj.push_back(f[&#123;u, v - <span class="number">1</span>&#125;]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (v != m - <span class="number">1</span> &amp;&amp; grid[u][v + <span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    adj.push_back(f[&#123;u, v + <span class="number">1</span>&#125;]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k : adj) &#123;</span><br><span class="line">                    dp[i][j] += dp[chdi][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; cnt) - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; input1&#123; &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">-1</span> &#125; &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; input2&#123; &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span> &#125; &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; input3&#123; &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.uniquePathsIII(input1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.uniquePathsIII(input2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.uniquePathsIII(input3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/unique-paths-iii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 980. Unique Paths III&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;在二维网格 grid 上，有 4 种类型的方格：&lt;br&gt;1 表示起始方格。且只有一个起始方格。&lt;br&gt;2 表示结束方格，且只有一个结束方格。&lt;br&gt;0 表示我们可以走过的空方格。&lt;br&gt;-1 表示我们无法跨越的障碍。&lt;br&gt;返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]&lt;br&gt;输出：2&lt;br&gt;解释：我们有以下两条路径：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)&lt;/li&gt;
&lt;li&gt;(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]&lt;br&gt;输出：4&lt;br&gt;解释：我们有以下四条路径： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)&lt;/li&gt;
&lt;li&gt;(0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)&lt;/li&gt;
&lt;li&gt;(0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)&lt;/li&gt;
&lt;li&gt;(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：[[0,1],[2,0]]&lt;br&gt;输出：0&lt;br&gt;解释：&lt;br&gt;没有一条路能完全穿过每一个空的方格一次。&lt;br&gt;请注意，起始和结束方格可以位于网格中的任意位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= grid.length * grid[0].length &amp;lt;= 20&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="状态压缩DP" scheme="http://tashi711.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 940. Distinct Subsequences II」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-940/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-940/</id>
    <published>2019-01-29T03:57:03.000Z</published>
    <updated>2019-01-31T14:15:19.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/distinct-subsequences-ii/description/" target="_blank" rel="noopener">LeetCode 940. Distinct Subsequences II</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个字符串 S，计算 S 的不同非空子序列的个数。<br>因为结果可能很大，所以返回答案模 10^9 + 7.</p><p><strong>示例 1：</strong><br>输入：”abc”<br>输出：7<br>解释：7 个不同的子序列分别是 “a”, “b”, “c”, “ab”, “ac”, “bc”, 以及 “abc”。</p><p><strong>示例 2：</strong><br>输入：”aba”<br>输出：6<br>解释：6 个不同的子序列分别是 “a”, “b”, “ab”, “ba”, “aa” 以及 “aba”。</p><p><strong>示例 3：</strong><br>输入：”aaa”<br>输出：3<br>解释：3 个不同的子序列分别是 “a”, “aa” 以及 “aaa”。</p><p><strong>提示：</strong><br>S 只包含小写字母。<br>1 &lt;= S.length &lt;= 2000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>想了很久想出个O(N^2·M)的DP算法，其中M为字母数量的规模（26），还是超时。<br>还是感叹于标答的巧妙。一维递推，可以认为是DP，详解参照标答。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N+M)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxC = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distinctSubseqII</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; last(kMaxC, <span class="number">-1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = S[i] - <span class="string">'a'</span>;</span><br><span class="line">            dp[i + <span class="number">1</span>] = (dp[i] &lt;&lt; <span class="number">1</span>) % kModule;</span><br><span class="line">            <span class="keyword">if</span> (last[cur] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] - dp[last[cur]]) % kModule;</span><br><span class="line">            &#125;</span><br><span class="line">            last[cur] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (dp[n] - <span class="number">1</span> + kModule) % kModule;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.distinctSubseqII(<span class="string">"abc"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.distinctSubseqII(<span class="string">"aba"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.distinctSubseqII(<span class="string">"aaa"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/distinct-subsequences-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 940. Distinct Subsequences II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个字符串 S，计算 S 的不同非空子序列的个数。&lt;br&gt;因为结果可能很大，所以返回答案模 10^9 + 7.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：”abc”&lt;br&gt;输出：7&lt;br&gt;解释：7 个不同的子序列分别是 “a”, “b”, “c”, “ab”, “ac”, “bc”, 以及 “abc”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：”aba”&lt;br&gt;输出：6&lt;br&gt;解释：6 个不同的子序列分别是 “a”, “b”, “ab”, “ba”, “aa” 以及 “aba”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：”aaa”&lt;br&gt;输出：3&lt;br&gt;解释：3 个不同的子序列分别是 “a”, “aa” 以及 “aaa”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;S 只包含小写字母。&lt;br&gt;1 &amp;lt;= S.length &amp;lt;= 2000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="巧妙" scheme="http://tashi711.top/tags/%E5%B7%A7%E5%A6%99/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 975. Odd Even Jump」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-975/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-975/</id>
    <published>2019-01-28T03:57:03.000Z</published>
    <updated>2019-01-31T09:24:55.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/odd-even-jump/description/" target="_blank" rel="noopener">LeetCode 975. Odd Even Jump</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5… 次跳跃称为奇数跳跃，而第 2、4、6… 次跳跃称为偶数跳跃。<br>你可以按以下方式从索引 i 向后跳转到索引 j（其中 i &lt; j）：<br>在进行奇数跳跃时（如，第 1，3，5… 次跳跃），你将会跳到索引 j，使得 A[i] &lt;= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。<br>在进行偶数跳跃时（如，第 2，4，6… 次跳跃），你将会跳到索引 j，使得 A[i] =&gt; A[j]，A[j] 是可能的最大值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。<br>（对于某些索引 i，可能无法进行合乎要求的跳跃。）<br>如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。<br>返回好的起始索引的数量。</p><p><strong>示例 1：</strong><br>输入：[10,13,12,14,15]<br>输出：2<br>解释：<br>从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。<br>从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。<br>从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。<br>从起始索引 i = 4 出发，我们已经到达数组末尾。<br>总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。</p><p><strong>示例 2：</strong><br>输入：[2,3,1,1,4]<br>输出：3<br>解释：<br>从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：<br>在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。<br>在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。<br>在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。<br>我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。<br>类似地，我们可以推断：<br>从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。<br>从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。<br>从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。<br>从起始索引 i = 4 出发，我们已经到达数组末尾。<br>总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。</p><p><strong>示例 3：</strong><br>输入：[5,1,3,4,2]<br>输出：3<br>解释：<br>我们可以从起始索引 1，2，4 出发到达数组末尾。</p><p><strong>提示：</strong><br>A.length &lt;= 20000<br>0 &lt;= A[i] &lt; 100000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实很容易想到，如果从i跳到j，那么i的结果就是j（对应的）结果。<br>因此实际问题解决的关键是，如何找到应该跳到的位置。<br>那么其实可以考虑平衡树，以数值大小为第一键值，位置为第二键值，从后往前扫，每次算完一个就加入一个。<br>找到的第一个大于自身的值与位置一定是向上跳的目标，同理也容易得出向下跳的目标。<br>平衡树复杂度是对数级别的，这里的操作比较简单（插入与找lower bound），可以用STL自带的set来模拟平衡树。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N\log N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oddEvenJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; inc&#123; &#123; A[n - <span class="number">1</span>], n - <span class="number">1</span> &#125; &#125;, dec&#123; &#123; -A[n - <span class="number">1</span>], n - <span class="number">1</span> &#125; &#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; up(n), down(n);</span><br><span class="line">        up[n - <span class="number">1</span>] = down[n - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = inc.lower_bound(&#123; A[i], i &#125;);</span><br><span class="line">            <span class="keyword">auto</span> v = dec.lower_bound(&#123; -A[i], i &#125;);</span><br><span class="line">            <span class="keyword">if</span> (u == inc.end()) &#123;</span><br><span class="line">                up[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                up[i] = down[u-&gt;second];</span><br><span class="line">                <span class="keyword">if</span> (up[i]) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == dec.end()) &#123;</span><br><span class="line">                down[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                down[i] = up[v-&gt;second];</span><br><span class="line">            &#125;</span><br><span class="line">            inc.insert(&#123; A[i], i &#125;);</span><br><span class="line">            dec.insert(&#123; -A[i], i &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input&#123; <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.oddEvenJumps(input) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/odd-even-jump/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 975. Odd Even Jump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5… 次跳跃称为奇数跳跃，而第 2、4、6… 次跳跃称为偶数跳跃。&lt;br&gt;你可以按以下方式从索引 i 向后跳转到索引 j（其中 i &amp;lt; j）：&lt;br&gt;在进行奇数跳跃时（如，第 1，3，5… 次跳跃），你将会跳到索引 j，使得 A[i] &amp;lt;= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。&lt;br&gt;在进行偶数跳跃时（如，第 2，4，6… 次跳跃），你将会跳到索引 j，使得 A[i] =&amp;gt; A[j]，A[j] 是可能的最大值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。&lt;br&gt;（对于某些索引 i，可能无法进行合乎要求的跳跃。）&lt;br&gt;如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。&lt;br&gt;返回好的起始索引的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[10,13,12,14,15]&lt;br&gt;输出：2&lt;br&gt;解释：&lt;br&gt;从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。&lt;br&gt;从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。&lt;br&gt;从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。&lt;br&gt;从起始索引 i = 4 出发，我们已经到达数组末尾。&lt;br&gt;总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[2,3,1,1,4]&lt;br&gt;输出：3&lt;br&gt;解释：&lt;br&gt;从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：&lt;br&gt;在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。&lt;br&gt;在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。&lt;br&gt;在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。&lt;br&gt;我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。&lt;br&gt;类似地，我们可以推断：&lt;br&gt;从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。&lt;br&gt;从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。&lt;br&gt;从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。&lt;br&gt;从起始索引 i = 4 出发，我们已经到达数组末尾。&lt;br&gt;总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：[5,1,3,4,2]&lt;br&gt;输出：3&lt;br&gt;解释：&lt;br&gt;我们可以从起始索引 1，2，4 出发到达数组末尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;A.length &amp;lt;= 20000&lt;br&gt;0 &amp;lt;= A[i] &amp;lt; 100000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="平衡树" scheme="http://tashi711.top/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 972. Equal Rational Numbers」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-972/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-972/</id>
    <published>2019-01-27T03:57:03.000Z</published>
    <updated>2019-01-26T17:59:17.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/equal-rational-numbers/solution/" target="_blank" rel="noopener">LeetCode 972. Equal Rational Numbers</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定两个字符串 S 和 T，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回 true；否则，返回 false。字符串中可以使用括号来表示有理数的重复部分。<br>通常，有理数最多可以用三个部分来表示：整数部分 &lt;IntegerPart>、小数非重复部分 &lt;NonRepeatingPart> 和小数重复部分 &lt;(>&lt;RepeatingPart>&lt;)>。数字可以用以下三种方法之一来表示：<br> &lt;IntegerPart>（例：0，12，123）<br> &lt;IntegerPart>&lt;.>&lt;NonRepeatingPart> （例：0.5，2.12，2.0001）<br> &lt;IntegerPart>&lt;.>&lt;NonRepeatingPart>&lt;(>&lt;RepeatingPart>&lt;)>（例：0.1(6)，0.9(9)，0.00(1212)）<br>十进制展开的重复部分通常在一对圆括号内表示。例如：<br>1 / 6 = 0.16666666… = 0.1(6) = 0.1666(6) = 0.166(66)<br>0.1(6) 或 0.1666(6) 或 0.166(66) 都是 1 / 6 的正确表示形式。</p><p><strong>示例 1：</strong><br>输入：S = “0.(52)”, T = “0.5(25)”<br>输出：true<br>解释：因为 “0.(52)” 代表 0.52525252…，而 “0.5(25)” 代表 0.52525252525…..，则这两个字符串表示相同的数字。</p><p><strong>示例 2：</strong><br>输入：S = “0.1666(6)”, T = “0.166(66)”<br>输出：true</p><p><strong>示例 3：</strong><br>输入：S = “0.9(9)”, T = “1.”<br>输出：true<br>解释：<br>“0.9(9)” 代表 0.999999999… 永远重复，等于 1 。<br>“1.” 表示数字 1，其格式正确：(IntegerPart) = “1” 且 (NonRepeatingPart) = “” 。</p><p><strong>提示：</strong><br>每个部分仅由数字组成。<br>整数部分 &lt;IntegerPart> 不会以 2 个或更多的零开头。（对每个部分的数字没有其他限制）。<br>1 &lt;= &lt;IntegerPart>.length &lt;= 4<br>0 &lt;= &lt;NonRepeatingPart>.length &lt;= 4<br>1 &lt;= &lt;RepeatingPart>.length &lt;= 4</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这种题做起来蛮有意思的，稍微搭建好有理数的各操作模型，写起来就会方便很多。<br>唯一的考点就是无限循环小数与分数间的转换关系吧。<br>注意一下通分的时候直接乘可能超过int范围，都用long long就好。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(1)$（由题目可认为输入规模为常数）。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> u = <span class="number">0</span>, v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Rational(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        u = cur;</span><br><span class="line">        v = <span class="number">1</span>;</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            p *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        add(cur, p);</span><br><span class="line">        <span class="comment">// test("temp");</span></span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> pb = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            pb *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            add(cur, (pb - <span class="number">1</span>) * p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">        u = u * y + x * v;</span><br><span class="line">        v *= y;</span><br><span class="line">        reduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">euclid</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> euclid(y, x % y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> gcd = euclid(u, v);</span><br><span class="line">        u /= gcd;</span><br><span class="line">        v /= gcd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">": "</span> &lt;&lt; u &lt;&lt; <span class="string">" / "</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Rational&amp; x, <span class="keyword">const</span> Rational&amp; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.u == y.u &amp;&amp; x.v == y.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRationalEqual</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="function">Rational <span class="title">s</span><span class="params">(S)</span></span>;</span><br><span class="line">        <span class="function">Rational <span class="title">t</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="comment">// s.test("S");</span></span><br><span class="line">        <span class="comment">// t.test("T");</span></span><br><span class="line">        <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.isRationalEqual(<span class="string">"0.(52)"</span>, <span class="string">"0.5(25)"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.isRationalEqual(<span class="string">"0.1666(6)"</span>, <span class="string">"0.166(66)"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.isRationalEqual(<span class="string">"0.9(9)"</span>, <span class="string">"1."</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.isRationalEqual(<span class="string">"323.32(32)"</span>, <span class="string">"323.323(23)"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/equal-rational-numbers/solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 972. Equal Rational Numbers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定两个字符串 S 和 T，每个字符串代表一个非负有理数，只有当它们表示相同的数字时才返回 true；否则，返回 false。字符串中可以使用括号来表示有理数的重复部分。&lt;br&gt;通常，有理数最多可以用三个部分来表示：整数部分 &amp;lt;IntegerPart&gt;、小数非重复部分 &amp;lt;NonRepeatingPart&gt; 和小数重复部分 &amp;lt;(&gt;&amp;lt;RepeatingPart&gt;&amp;lt;)&gt;。数字可以用以下三种方法之一来表示：&lt;br&gt; &amp;lt;IntegerPart&gt;（例：0，12，123）&lt;br&gt; &amp;lt;IntegerPart&gt;&amp;lt;.&gt;&amp;lt;NonRepeatingPart&gt; （例：0.5，2.12，2.0001）&lt;br&gt; &amp;lt;IntegerPart&gt;&amp;lt;.&gt;&amp;lt;NonRepeatingPart&gt;&amp;lt;(&gt;&amp;lt;RepeatingPart&gt;&amp;lt;)&gt;（例：0.1(6)，0.9(9)，0.00(1212)）&lt;br&gt;十进制展开的重复部分通常在一对圆括号内表示。例如：&lt;br&gt;1 / 6 = 0.16666666… = 0.1(6) = 0.1666(6) = 0.166(66)&lt;br&gt;0.1(6) 或 0.1666(6) 或 0.166(66) 都是 1 / 6 的正确表示形式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：S = “0.(52)”, T = “0.5(25)”&lt;br&gt;输出：true&lt;br&gt;解释：因为 “0.(52)” 代表 0.52525252…，而 “0.5(25)” 代表 0.52525252525…..，则这两个字符串表示相同的数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：S = “0.1666(6)”, T = “0.166(66)”&lt;br&gt;输出：true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：S = “0.9(9)”, T = “1.”&lt;br&gt;输出：true&lt;br&gt;解释：&lt;br&gt;“0.9(9)” 代表 0.999999999… 永远重复，等于 1 。&lt;br&gt;“1.” 表示数字 1，其格式正确：(IntegerPart) = “1” 且 (NonRepeatingPart) = “” 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;每个部分仅由数字组成。&lt;br&gt;整数部分 &amp;lt;IntegerPart&gt; 不会以 2 个或更多的零开头。（对每个部分的数字没有其他限制）。&lt;br&gt;1 &amp;lt;= &amp;lt;IntegerPart&gt;.length &amp;lt;= 4&lt;br&gt;0 &amp;lt;= &amp;lt;NonRepeatingPart&gt;.length &amp;lt;= 4&lt;br&gt;1 &amp;lt;= &amp;lt;RepeatingPart&gt;.length &amp;lt;= 4&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.top/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 968. Binary Tree Cameras」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-968/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-968/</id>
    <published>2019-01-23T03:57:03.000Z</published>
    <updated>2019-01-22T16:29:57.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/binary-tree-cameras/description/" target="_blank" rel="noopener">LeetCode 968. Binary Tree Cameras</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong><br>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。</p><p><strong>示例 2：</strong><br>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p><p><strong>提示：</strong><br>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实题不难，不过笔者思考的有点纠结。一开始看出是一道树形DP，但写着写着发现自己思维上的错误。<br>之后想着想着想到贪心是成立的，于是写了个贪心，也就是越往上靠越好，非常坎坷的过了。<br>建议可以看下官方题解，DP和贪心都是很简洁的思维。<br>另外说下空间，我这里用了他自带的没用的node的val变量，虽然省了空间，不过不算是很好的做法。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            dfs(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line">                cur = <span class="number">2</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left-&gt;val == <span class="number">2</span>) &#123;</span><br><span class="line">                cur = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            dfs(p-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line">                    cur = <span class="number">2</span>;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;right-&gt;val == <span class="number">2</span>) &#123;</span><br><span class="line">                    cur = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;val = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;left-&gt;val == <span class="number">0</span> ||</span><br><span class="line">                root-&gt;right &amp;&amp; root-&gt;right-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(root-&gt;left &amp;&amp; root-&gt;left-&gt;val == <span class="number">2</span> ||</span><br><span class="line">                root-&gt;right &amp;&amp; root-&gt;right-&gt;val == <span class="number">2</span>)) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">n1_r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n1_1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n1_2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n1_3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    n1_r.left = &amp;n1_1;</span><br><span class="line">    n1_1.left = &amp;n1_2;</span><br><span class="line">    n1_1.right = &amp;n1_3;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_4</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    n2_r.left = &amp;n2_1;</span><br><span class="line">    n2_1.left = &amp;n2_2;</span><br><span class="line">    n2_2.left = &amp;n2_3;</span><br><span class="line">    n2_3.right = &amp;n2_4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.minCameraCover(&amp;n1_r) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.minCameraCover(&amp;n2_r) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/binary-tree-cameras/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 968. Binary Tree Cameras&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个二叉树，我们在树的节点上安装摄像头。&lt;br&gt;节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。&lt;br&gt;计算监控树的所有节点所需的最小摄像头数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[0,0,null,0,0]&lt;br&gt;输出：1&lt;br&gt;解释：如图所示，一台摄像头足以监控所有节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[0,0,null,0,null,0,null,null,0]&lt;br&gt;输出：2&lt;br&gt;解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;给定树的节点数的范围是 [1, 1000]。&lt;br&gt;每个节点的值都是 0。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="树形DP" scheme="http://tashi711.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="贪心" scheme="http://tashi711.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 214. Shortest Palindrome」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-214/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-214/</id>
    <published>2019-01-13T03:57:03.000Z</published>
    <updated>2019-01-13T08:48:49.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/shortest-palindrome/description/" target="_blank" rel="noopener">LeetCode 214. Shortest Palindrome</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><p><strong>示例 1:</strong><br>输入: “aacecaaa”<br>输出: “aaacecaaa”</p><p><strong>示例 2:</strong><br>输入: “abcd”<br>输出: “dcbabcd”</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这道题不是很容易想出，因此之后遇到字符串的题目也可以得到启发，看能不能往KMP方向靠一靠。<br>这道题其实并不是一道字符串匹配的问题，但用到了KMP的思想，就是“深入理解”KMP当中的p数组。<br>也是就p[i]可以理解为“i位置结尾最多能匹配到从位置0开始的子串长度”，且p能线性得到。<br>于是答案就是”s+分隔符+reverse(s)”的p[最后位置]了，其中分隔符是为了防止s本身就是回文时全匹配了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> inited = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> sp;</span><br><span class="line">    <span class="keyword">int</span> nsp = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matched_idx;</span><br><span class="line"></span><br><span class="line">    KMP(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s = <span class="string">""</span>) &#123;</span><br><span class="line">        init(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        inited = <span class="literal">true</span>;</span><br><span class="line">        sp = s;</span><br><span class="line">        nsp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sp.size());</span><br><span class="line">        p.resize(nsp);</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nsp; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sp[j + <span class="number">1</span>] != sp[i]) &#123;</span><br><span class="line">                j = p[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sp[j + <span class="number">1</span>] == sp[i]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            p[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> rs = s;</span><br><span class="line">        reverse(rs.begin(), rs.end());</span><br><span class="line">        <span class="built_in">string</span> sp = s + <span class="string">"#"</span> + rs;</span><br><span class="line">        <span class="function">KMP <span class="title">kmp</span><span class="params">(sp)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> rs.substr(<span class="number">0</span>, n - kmp.p[<span class="number">2</span> * n] - <span class="number">1</span>) + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.shortestPalindrome(<span class="string">"aacecaaa"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.shortestPalindrome(<span class="string">"abcd"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/shortest-palindrome/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 214. Shortest Palindrome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: “aacecaaa”&lt;br&gt;输出: “aaacecaaa”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: “abcd”&lt;br&gt;输出: “dcbabcd”&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="KMP" scheme="http://tashi711.top/tags/KMP/"/>
    
      <category term="巧妙" scheme="http://tashi711.top/tags/%E5%B7%A7%E5%A6%99/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 52. N-Queens II」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-52/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-52/</id>
    <published>2019-01-13T03:57:03.000Z</published>
    <updated>2019-01-13T09:36:41.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/n-queens-ii/description/" target="_blank" rel="noopener">LeetCode 52. N-Queens II</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><p><strong>示例:</strong><br>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br>[<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>n皇后问题应该是比较经典的回溯题了，学回溯的时候应该都了解过位运算版。<br>总之就是因为np的问题阶层复杂度，那么输入规模最多也就十几，完全可以用一个数储存状态。<br>当然优化到极致就是每次枚举时都不是O(n)遍历而是直接取lowbit。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N!)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dale = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; ~(col | hill &gt;&gt; r | dale &gt;&gt; (n - <span class="number">1</span> - r));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur; now; now ^= cur) &#123;</span><br><span class="line">            cur = lowbit(now);</span><br><span class="line">            col |= cur;</span><br><span class="line">            hill |= cur &lt;&lt; r;</span><br><span class="line">            dale |= cur &lt;&lt; (n - <span class="number">1</span> - r);</span><br><span class="line">            dfs(r + <span class="number">1</span>, n);</span><br><span class="line">            col ^= cur;</span><br><span class="line">            hill ^= cur &lt;&lt; r;</span><br><span class="line">            dale ^= cur &lt;&lt; (n - <span class="number">1</span> - r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.totalNQueens(<span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/n-queens-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 52. N-Queens II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;br&gt;给定一个整数 n，返回 n 皇后不同的解决方案的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: 4&lt;br&gt;输出: 2&lt;br&gt;解释: 4 皇后问题存在如下两个不同的解法。&lt;br&gt;[&lt;br&gt; [“.Q..”,  // 解法 1&lt;br&gt;  “…Q”,&lt;br&gt;  “Q…”,&lt;br&gt;  “..Q.”],&lt;/p&gt;
&lt;p&gt; [“..Q.”,  // 解法 2&lt;br&gt;  “Q…”,&lt;br&gt;  “…Q”,&lt;br&gt;  “.Q..”]&lt;br&gt;]&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="回溯" scheme="http://tashi711.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 164. Maximum Gap」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-164/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-164/</id>
    <published>2019-01-10T03:57:03.000Z</published>
    <updated>2019-01-09T16:19:49.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/maximum-gap/description/" target="_blank" rel="noopener">LeetCode 164. Maximum Gap</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>如果数组元素个数小于 2，则返回 0。</p><p><strong>示例 1:</strong><br>输入: [3,6,9,1]<br>输出: 3<br>解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</p><p><strong>示例 2:</strong><br>输入: [10]<br>输出: 0<br>解释: 数组元素个数小于 2，因此返回 0。</p><p><strong>说明:</strong><br>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较interview oriented的一道题目。<br>难得官方题解可以拜读下、而且难得cpp的max_element、partial_sum什么的学起来鸭。<br>先讲讲为什么可以优化、首先已知通过交换的排序是不会小于nlogn的。<br>但是呢、像基数排序之类的居然就可以做到线性、原因是这类排序利用了“数字”的“特性”，而不是单纯的比较大小。<br>会发现，这类排序只能用于整数，像浮点或者甚至一些复合类型就只能nlogn了。<br>基数排序被认为是线性的、基于基数（通常是10）和数的范围（int整型2^32）是常数规模。<br>数值范围这个规模其实还挺大，但是做的轮数是这个规模的log级别、因此还是可忽略的常数。<br>拓展：当数值规模与数量规模有关时（比如n的k次方，k为常数），那么可以在基数上做点文章。<br>比如取基数为n、因为只要基数是O(n)及以下、一轮（计数）排序还是线性的，但轮数就为常数k了。<br>此外、题解还有一只解法、思想相当巧妙、可以悟一下。<br>而那个解法优化点在于、他并没有做全部的排序、而是仅比较了需要能够得出正确解的轮次。<br>当然啦、最终这个解法是线性的还是基于数值规模是线性的、且不是log级别、是反函数。<br>那么其实稍微有点问题、n太小的时候可能还是会很慢、因此应该多一个特判（毕竟n小的话直接排序又不费功夫了）。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kRadix = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_num = *max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; aux(n);</span><br><span class="line">        <span class="keyword">while</span> (max_num / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(kRadix, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                count[(nums[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            partial_sum(count.cbegin(), count.cend(), count.begin());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                aux[--count[(nums[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            copy(aux.cbegin(), aux.cend(), nums.begin());</span><br><span class="line">            <span class="built_in">exp</span> *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ret = max(ret, nums[i + <span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj1 = &#123; <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj2 = &#123; <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.maximumGap(adj1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.maximumGap(adj2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/maximum-gap/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 164. Maximum Gap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。&lt;br&gt;如果数组元素个数小于 2，则返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: [3,6,9,1]&lt;br&gt;输出: 3&lt;br&gt;解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: [10]&lt;br&gt;输出: 0&lt;br&gt;解释: 数组元素个数小于 2，因此返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。&lt;br&gt;请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="排序" scheme="http://tashi711.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 233. Number of Digit One」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-233/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-233/</id>
    <published>2019-01-04T03:57:03.000Z</published>
    <updated>2019-01-04T14:42:30.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/number-of-digit-one/description/" target="_blank" rel="noopener">LeetCode 233. Number of Digit One</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><p><strong>示例:</strong><br>输入: 13<br>输出: 6<br>解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题解很清楚了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(\log N)$。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> div = i * <span class="number">10</span>;</span><br><span class="line">            cnt += (n / div) * i + min(max(n % div - i + <span class="number">1</span>, <span class="number">0L</span>L), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.countDigitOne(<span class="number">13</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/number-of-digit-one/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 233. Number of Digit One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: 13&lt;br&gt;输出: 6&lt;br&gt;解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="思考题" scheme="http://tashi711.top/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 943. Find the Shortest Superstring」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-943/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-943/</id>
    <published>2019-01-01T03:57:03.000Z</published>
    <updated>2019-01-09T14:21:39.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/find-the-shortest-superstring/description/" target="_blank" rel="noopener">LeetCode 943. Find the Shortest Superstring</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。<br>我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。</p><p><strong>示例 1：</strong><br>输入：[“alex”,”loves”,”leetcode”]<br>输出：”alexlovesleetcode”<br>解释：”alex”，”loves”，”leetcode” 的所有排列都会被接受。</p><p><strong>示例 2：</strong><br>输入：[“catg”,”ctaagt”,”gcta”,”ttca”,”atgcatc”]<br>输出：”gctaagttcatgcatc”</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 12<br>1 &lt;= A[i].length &lt;= 20</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴搜复杂度是阶乘的，状态数很小，其实就是用状压DP解一个类TSP问题。<br>题解基本说明白了，可以参考，不过边界问题处理的很奇怪，下面的代码改良了边界处理。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N^2(2^N+W))$，W为字符串长度的规模。<br>空间复杂度为 $O(N(2^N+W))$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestSuperstring</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; overlaps(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">1</span> &lt;&lt; n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fa(<span class="number">1</span> &lt;&lt; n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> si = A[i].size();</span><br><span class="line">                    <span class="keyword">int</span> sj = A[j].size();</span><br><span class="line">                    <span class="keyword">int</span> m = min(si, sj);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = m; k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (A[i].substr(si - k, k) == A[j].substr(<span class="number">0</span>, k)) &#123;</span><br><span class="line">                            overlaps[i][j] = k;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">1</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bit = <span class="number">0</span>; bit &lt; n; ++bit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((mask &gt;&gt; bit) &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> pmask = mask ^ (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">                    <span class="keyword">if</span> (pmask == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[mask][bit] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (((pmask &gt;&gt; i) &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> val = dp[pmask][i] + overlaps[i][bit];</span><br><span class="line">                            <span class="keyword">if</span> (val &gt; dp[mask][bit]) &#123;</span><br><span class="line">                                dp[mask][bit] = val;</span><br><span class="line">                                fa[mask][bit] = i;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][j] &gt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][p]) &#123;</span><br><span class="line">                p = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            perm.push_back(p);</span><br><span class="line">            <span class="keyword">int</span> fa_p = fa[mask][p];</span><br><span class="line">            mask ^= <span class="number">1</span> &lt;&lt; p;</span><br><span class="line">            p = fa_p;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(perm.begin(), perm.end());</span><br><span class="line">        <span class="built_in">string</span> ans = A[perm[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_overlap = overlaps[perm[i - <span class="number">1</span>]][perm[i]];</span><br><span class="line">            ans += (A[perm[i]].substr(cur_overlap));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj1 = &#123; <span class="string">"alex"</span>, <span class="string">"loves"</span>, <span class="string">"leetcode"</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj2 = &#123; <span class="string">"catg"</span>, <span class="string">"ctaagt"</span>, <span class="string">"gcta"</span>, <span class="string">"ttca"</span>, <span class="string">"atgcatc"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.shortestSuperstring(adj1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.shortestSuperstring(adj2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/find-the-shortest-superstring/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 943. Find the Shortest Superstring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。&lt;br&gt;我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[“alex”,”loves”,”leetcode”]&lt;br&gt;输出：”alexlovesleetcode”&lt;br&gt;解释：”alex”，”loves”，”leetcode” 的所有排列都会被接受。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[“catg”,”ctaagt”,”gcta”,”ttca”,”atgcatc”]&lt;br&gt;输出：”gctaagttcatgcatc”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 12&lt;br&gt;1 &amp;lt;= A[i].length &amp;lt;= 20&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="状态压缩DP" scheme="http://tashi711.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    
      <category term="TSP问题" scheme="http://tashi711.top/tags/TSP%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
