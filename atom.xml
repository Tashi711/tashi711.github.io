<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tashi711的博客</title>
  
  <subtitle>過去（きのう）に傷付きながらも、信じ続ける理想（ゆめ）を求める。いつか無限（なないろ）に輝き放って、青空（そら）に橋を描く。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tashi711.xyz/"/>
  <updated>2018-09-11T16:42:31.257Z</updated>
  <id>http://tashi711.xyz/</id>
  
  <author>
    <name>Tashi711</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「902. Numbers At Most N Given Digit Set」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-902/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-902/</id>
    <published>2018-09-12T03:57:02.000Z</published>
    <updated>2018-09-11T16:42:31.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/numbers-at-most-n-given-digit-set/description/" target="_blank" rel="noopener">902. Numbers At Most N Given Digit Set</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　We have a sorted set of digits D, a non-empty subset of {‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}.  (Note that ‘0’ is not included.)<br>　　Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {‘1’,’3’,’5’}, we may write numbers such as ‘13’, ‘551’, ‘1351315’.<br>　　Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.</p><p>　　Example 1:<br>　　Input: D = [“1”,”3”,”5”,”7”], N = 100<br>　　Output: 20<br>　　Explanation:<br>　　The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</p><p>　　Example 2:<br>　　Input: D = [“1”,”4”,”9”], N = 1000000000<br>　　Output: 29523<br>　　Explanation:<br>　　We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.</p><p>　　Note:<br>　　D is a subset of digits ‘1’-‘9’ in sorted order.<br>　　1 &lt;= N &lt;= 10^9</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　最简单的模拟一下就好了，注意题目比较坑，他的描述容易被误解成每个数只能用D中的3个，其实那句话的意思是他举的例子是取了3个数（不然这道题其实暴力枚举也不会超时）。<br>　　那么就从头到尾扫，当前位置摆更小的数，后面就可以随意摆，当前位置正好摆相同的数（如果有），就扫到下一位做同样的判断累加。最后记得累加摆比N位数少的数的个数就好（任意摆），这个累和可以先初始化出来，包括D的size的所有次方。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　空间复杂度为$O(\log N)$，即N的位数，如果将D的size考虑为常数的话（不超过9）。<br>　　时间复杂度为$O(\log N)$，同理。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> sum[kMaxN];</span><br><span class="line"><span class="keyword">bool</span> have[kMaxN];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">a[i] = a[i - <span class="number">1</span>] * tot;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(have, <span class="number">0</span>, <span class="keyword">sizeof</span> have);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = s[p] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; u; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (have[i]) &#123;</span><br><span class="line">ans += a[n - p - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (have[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (p + <span class="number">1</span> == n) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dfs(s, p + <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atMostNGivenDigitSet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; D, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">tot = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(D.size());</span><br><span class="line">pre();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> s : D) &#123;</span><br><span class="line">have[s[<span class="number">0</span>] - <span class="string">'0'</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; N;</span><br><span class="line"><span class="built_in">string</span> n;</span><br><span class="line">ss &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(n.size());</span><br><span class="line">dfs(n, <span class="number">0</span>, len);</span><br><span class="line">ans += sum[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/numbers-at-most-n-given-digit-set/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;902. Numbers At Most N Given Digit Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　We have a sorted set of digits D, a non-empty subset of {‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}.  (Note that ‘0’ is not included.)&lt;br&gt;　　Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {‘1’,’3’,’5’}, we may write numbers such as ‘13’, ‘551’, ‘1351315’.&lt;br&gt;　　Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: D = [“1”,”3”,”5”,”7”], N = 100&lt;br&gt;　　Output: 20&lt;br&gt;　　Explanation:&lt;br&gt;　　The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.&lt;/p&gt;
&lt;p&gt;　　Example 2:&lt;br&gt;　　Input: D = [“1”,”4”,”9”], N = 1000000000&lt;br&gt;　　Output: 29523&lt;br&gt;　　Explanation:&lt;br&gt;　　We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　D is a subset of digits ‘1’-‘9’ in sorted order.&lt;br&gt;　　1 &amp;lt;= N &amp;lt;= 10^9&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="模拟" scheme="http://tashi711.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>「903. Valid Permutations for DI Sequence」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-903/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-903/</id>
    <published>2018-09-11T03:57:02.000Z</published>
    <updated>2018-09-11T15:47:18.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/valid-permutations-for-di-sequence/description/" target="_blank" rel="noopener">903. Valid Permutations for DI Sequence</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　We are given S, a length n string of characters from the set {‘D’, ‘I’}. (These letters stand for “decreasing” and “increasing”.)<br>　　A valid permutation is a permutation P[0], P[1], …, P[n] of integers {0, 1, …, n}, such that for all i:<br>　　If S[i] == ‘D’, then P[i] &gt; P[i+1], and;<br>　　If S[i] == ‘I’, then P[i] &lt; P[i+1].<br>　　How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.</p><p>　　Example:<br>　　Input: “DID”<br>　　Output: 5<br>　　Explanation:<br>　　The 5 valid permutations of (0, 1, 2, 3) are:<br>　　(1, 0, 3, 2)<br>　　(2, 0, 3, 1)<br>　　(2, 1, 3, 0)<br>　　(3, 0, 2, 1)<br>　　(3, 1, 2, 0)</p><p>　　Note:<br>　　1 &lt;= S.length &lt;= 200<br>　　S consists only of characters from the set {‘D’, ‘I’}.</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　因为很容易想到从子状态递推过去，典型的DP题。<br>　　用f[i][j]表示算到字符串第i个位置结尾为j的方案个数。<br>　　容易得到，如果当前S[i]为“D”，那么f[i][j] = sigma(f[i-1][k])，k从j到i，因为如果当前位置放j，那么等价的方案是前面放的1到j-1不变，j到i分别变成j+1到i+1，而需要的是前一个结尾为j+1到i+1的，那么枚举的k为j到i；同理，如果当前S[i]为“I”，那么f[i][j] = sigma(f[i-1][k])，k从1到j-1，因为需要的是前一个结尾为1到j-1（在等价方案中不变）。<br>　　容易想到初始状态为f[0][1] = 1，每次计算f[i][j]时j要从1枚举到i+1。<br>　　最终答案为sigma(f[n][i])，i从1到n+1。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　空间复杂度为状态复杂度，即$O(N^2)$。<br>　　时间复杂度为状态复杂度×转移复杂度，即$O(N^3)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">220</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_add_equal</span><span class="params">(<span class="keyword">int</span>&amp; s, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">s = (s + p) % kModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numPermsDISequence</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(S.size());</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">'\0'</span> + S;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> u = (s[i] == <span class="string">'D'</span> ? j : <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> v = (s[i] == <span class="string">'D'</span> ? i : j - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = u; k &lt;= v; ++k) &#123;</span><br><span class="line">my_add_equal(f[i][j], f[i - <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">my_add_equal(ans, f[n][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>　　看了下官方的题解，时间可以优化到N方，有个启发就是枚举k的时候其实都是连续的一段和，那么其实可以在枚举j之前先把f[i][1]到f[i][k]，k从1到i的累和算出来，之后可以直接用了（相减），时间就可以降一维。题解上说的是通过观察直接得到了没有累加的转移方程，其实自己琢磨一下那个方程会发现是有实际意义在里面的，道理差不多，利用连续和均摊复杂度。至于题解中的分治做法就没有太研究了，时间也可以到N方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/valid-permutations-for-di-sequence/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;903. Valid Permutations for DI Sequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　We are given S, a length n string of characters from the set {‘D’, ‘I’}. (These letters stand for “decreasing” and “increasing”.)&lt;br&gt;　　A valid permutation is a permutation P[0], P[1], …, P[n] of integers {0, 1, …, n}, such that for all i:&lt;br&gt;　　If S[i] == ‘D’, then P[i] &amp;gt; P[i+1], and;&lt;br&gt;　　If S[i] == ‘I’, then P[i] &amp;lt; P[i+1].&lt;br&gt;　　How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.&lt;/p&gt;
&lt;p&gt;　　Example:&lt;br&gt;　　Input: “DID”&lt;br&gt;　　Output: 5&lt;br&gt;　　Explanation:&lt;br&gt;　　The 5 valid permutations of (0, 1, 2, 3) are:&lt;br&gt;　　(1, 0, 3, 2)&lt;br&gt;　　(2, 0, 3, 1)&lt;br&gt;　　(2, 1, 3, 0)&lt;br&gt;　　(3, 0, 2, 1)&lt;br&gt;　　(3, 1, 2, 0)&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= S.length &amp;lt;= 200&lt;br&gt;　　S consists only of characters from the set {‘D’, ‘I’}.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「C++ Primer (5th) 第3章」小结</title>
    <link href="http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-3/"/>
    <id>http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-3/</id>
    <published>2018-09-11T03:17:59.000Z</published>
    <updated>2018-09-11T15:49:33.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-Primer-5th"><a href="#C-Primer-5th" class="headerlink" title="C++ Primer (5th)"></a>C++ Primer (5th)</h2><blockquote><ul><li>第一部分：C++基础</li><li>第3章</li></ul></blockquote><a id="more"></a><h3 id="第一部分：C-基础-第3章"><a href="#第一部分：C-基础-第3章" class="headerlink" title="第一部分：C++基础 (第3章)"></a>第一部分：C++基础 (第3章)</h3><ul><li>初始化时使用花括号但提供的值不能用来列表初始化，那么就会调用构造函数:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1&#123;<span class="number">10</span>&#125;; <span class="comment">// 10个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2(<span class="number">10</span>, <span class="string">"hi"</span>&#125;; <span class="comment">// 10个"hi"</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-Primer-5th&quot;&gt;&lt;a href=&quot;#C-Primer-5th&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer (5th)&quot;&gt;&lt;/a&gt;C++ Primer (5th)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：C++基础&lt;/li&gt;
&lt;li&gt;第3章&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「Effective C++ (3rd) 第一、二部分」小结</title>
    <link href="http://tashi711.xyz/programming/notes/effective-cpp/effective-cpp/"/>
    <id>http://tashi711.xyz/programming/notes/effective-cpp/effective-cpp/</id>
    <published>2018-09-08T03:17:59.000Z</published>
    <updated>2018-09-11T16:02:12.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-C-3rd"><a href="#Effective-C-3rd" class="headerlink" title="Effective C++ (3rd)"></a>Effective C++ (3rd)</h2><blockquote><ul><li>第一部分：Accustoming Yourself to C++</li><li>第二部分：Constructors, Destructors, and Assignment Operators</li></ul></blockquote><a id="more"></a><h3 id="第一部分：Accustoming-Yourself-to-C"><a href="#第一部分：Accustoming-Yourself-to-C" class="headerlink" title="第一部分：Accustoming Yourself to C++"></a>第一部分：Accustoming Yourself to C++</h3><ul><li><p>使用enum定义常数不占空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; Num = <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> a[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>const xxx::iterator</code>相当于<code>T* const</code>，<code>xxx::const_iterator</code>相当于<code>const T*</code></p></li><li>mutable成员变量可以在const成员变量中改变</li><li><p>const与non-const成员函数避免代码重复，non-const调用const：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> <span class="comment">// same as before</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[position];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="comment">// now just calls const op[]</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;( <span class="comment">// cast away const on op[]’s return type;</span></span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>) <span class="comment">// add const to *this’s type;</span></span><br><span class="line">          [position] <span class="comment">// call const version of op[]</span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>成员变量总是以声明顺序初始化，与初始化列表顺序无关</p></li><li>因为跨编译单元初始化顺序问题，用local static代替non-local static对象</li></ul><h3 id="第二部分：Constructors-Destructors-and-Assignment-Operators"><a href="#第二部分：Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="第二部分：Constructors, Destructors, and Assignment Operators"></a>第二部分：Constructors, Destructors, and Assignment Operators</h3><ul><li>内含引用成员或const成员的类不能自动生成拷贝赋值函数</li><li>如果基类的拷贝赋值函数是为私有的，派生类不会自动生成拷贝赋值函数</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Effective-C-3rd&quot;&gt;&lt;a href=&quot;#Effective-C-3rd&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ (3rd)&quot;&gt;&lt;/a&gt;Effective C++ (3rd)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：Accustoming Yourself to C++&lt;/li&gt;
&lt;li&gt;第二部分：Constructors, Destructors, and Assignment Operators&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective-C/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「C++ Primer (5th) 第1、2章」小结</title>
    <link href="http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-1-2/"/>
    <id>http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-1-2/</id>
    <published>2018-09-06T03:17:59.000Z</published>
    <updated>2018-09-11T15:49:37.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-Primer-5th"><a href="#C-Primer-5th" class="headerlink" title="C++ Primer (5th)"></a>C++ Primer (5th)</h2><blockquote><ul><li>第一部分：C++基础</li><li>第1、2章</li></ul></blockquote><a id="more"></a><h3 id="第一部分：C-基础-第1、2章"><a href="#第一部分：C-基础-第1、2章" class="headerlink" title="第一部分：C++基础 (第1、2章)"></a>第一部分：C++基础 (第1、2章)</h3><ul><li>char不一定是signed char，可能是unsigned char</li><li>double有时比float效率更高</li><li>给一个无符号类型赋值超过其表示范围，得到的是取余的结果，但对有符号类型而言结果未定义，且程序可能崩溃</li><li>int与unsigned int的算术运算得到的是unsigned int</li><li>十进制的字面类型是int，八进制、十六进制的字面类型是能容纳其数值的int、unsigned int、long、unsigned long、long long、unsigned long long中尺寸最小者</li><li>初始化列表在存在信息丢失的风险时编译器会报错</li><li><p>显式访问全局变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ::x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;</span><br></pre></td></tr></table></figure></li><li><p>如果想在多个文件间共享const对象，必须在变量定义前也添加extern</p></li><li>非常量引用不能指向常量对象</li><li><p>引用的特殊情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = r1 * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> y = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = y; <span class="comment">// 等价于 const int t = y; const int &amp;r3 = t;</span></span><br></pre></td></tr></table></figure></li><li><p>顶层（top-level）const：指针等任意对象本身是常量</p></li><li>底层（low-level）const：指针所指的（包括引用）对象是const</li><li><code>constexpr int *q = nullptr</code>中q是一个指向整数的常量指针（与<code>const int *q</code>不同）</li><li><p>constexpr也可以指向常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</span><br></pre></td></tr></table></figure></li><li><p>typedef指针后const是常量指针而不是指向常量的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">const</span> p c; 等价于 <span class="keyword">char</span> *<span class="keyword">const</span> c;</span><br></pre></td></tr></table></figure></li><li><p>auto能在一条语句中声明多个变量，但只能是同一个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>, *p = &amp;i; <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">2</span>, k = <span class="number">3.14</span>; <span class="comment">// no</span></span><br></pre></td></tr></table></figure></li><li><p>auto引用是引用对象的类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a是一个整数</span></span><br></pre></td></tr></table></figure></li><li><p>auto会忽略顶层const，保留底层const：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i <span class="comment">// d是一个整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci <span class="comment">// e是一个指向整数常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci <span class="comment">// f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p = &amp;ci <span class="comment">// 是错的，因为i推演是int，&amp;ci推演是const int</span></span><br></pre></td></tr></table></figure></li><li><p><code>const int ci = 1, &amp;cj = ci;</code>中，<code>decltype(ci)</code>是const int、<code>decltype(cj)</code>是const int&amp;</p></li><li><code>int i = 1, *p = &amp;i, &amp;r = i;</code>中，<code>decltype(r + 0)</code>是int、<code>decltype(*p)</code>是int&amp;</li><li>如果给变量加上括号编译器会把其变为表达式，则会变为引用类型：<code>decltype(i)</code>是int，<code>decltype((i))</code>是int&amp;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-Primer-5th&quot;&gt;&lt;a href=&quot;#C-Primer-5th&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer (5th)&quot;&gt;&lt;/a&gt;C++ Primer (5th)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：C++基础&lt;/li&gt;
&lt;li&gt;第1、2章&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「854. K-Similar Strings」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-854/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-854/</id>
    <published>2018-08-28T03:57:02.000Z</published>
    <updated>2018-08-28T03:12:48.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/k-similar-strings/description/" target="_blank" rel="noopener">854. K-Similar Strings</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B.<br>　　Given two anagrams A and B, return the smallest K for which A and B are K-similar.</p><p>　　Example 1:<br>　　Input: A = “ab”, B = “ba”<br>　　Output: 1</p><p>　　Example 2:<br>　　Input: A = “abc”, B = “bca”<br>　　Output: 2</p><p>　　Example 3:<br>　　Input: A = “abac”, B = “baca”<br>　　Output: 2</p><p>　　Example 4:<br>　　Input: A = “aabc”, B = “abca”<br>　　Output: 2</p><p>　　Note:<br>　　1 &lt;= A.length == B.length &lt;= 20<br>　　A and B contain only lowercase letters from the set {‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’}</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　数据范围很小，考虑用回溯爆搜。<br>　　此处考虑两个剪枝：<br>　　一是最基本的当前累计交换次数达到目前的最优解就停止；<br>　　二是交换与顺序某种意义上是无关的，因此从前往后扫，遇到第一个不一样的位置就一定试着与后面所有可能的位置交换，将当前位置交换正确，再往后扫。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　因为爆搜的复杂度很难估计，尤其是有剪枝的时候，此处不展开分析，官方题解中有分析复杂度，可以参考。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> min_ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">++res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; min_ans &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">min_ans = ans;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans == min_ans) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] == a[j]) &#123;</span><br><span class="line">swap(a[i], a[j]);</span><br><span class="line">++ans;</span><br><span class="line">dfs(u + <span class="number">1</span>);</span><br><span class="line">--ans;</span><br><span class="line">swap(a[i], a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kSimilarity</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(A.size());</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">min_ans = <span class="number">20</span>;</span><br><span class="line">a = A;</span><br><span class="line">b = B;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> min_ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/k-similar-strings/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;854. K-Similar Strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B.&lt;br&gt;　　Given two anagrams A and B, return the smallest K for which A and B are K-similar.&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: A = “ab”, B = “ba”&lt;br&gt;　　Output: 1&lt;/p&gt;
&lt;p&gt;　　Example 2:&lt;br&gt;　　Input: A = “abc”, B = “bca”&lt;br&gt;　　Output: 2&lt;/p&gt;
&lt;p&gt;　　Example 3:&lt;br&gt;　　Input: A = “abac”, B = “baca”&lt;br&gt;　　Output: 2&lt;/p&gt;
&lt;p&gt;　　Example 4:&lt;br&gt;　　Input: A = “aabc”, B = “abca”&lt;br&gt;　　Output: 2&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= A.length == B.length &amp;lt;= 20&lt;br&gt;　　A and B contain only lowercase letters from the set {‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’}&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="回溯" scheme="http://tashi711.xyz/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>「シド - バタフライエフェクト」鑑賞</title>
    <link href="http://tashi711.xyz/nihongo/uta/sid-butterfly-effect/"/>
    <id>http://tashi711.xyz/nihongo/uta/sid-butterfly-effect/</id>
    <published>2018-08-27T17:03:54.000Z</published>
    <updated>2018-08-28T02:43:30.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="歌曲信息"><a href="#歌曲信息" class="headerlink" title="歌曲信息"></a>歌曲信息</h2><blockquote><ul><li>歌曲：バタフライエフェクト</li><li>歌手：シド</li><li>作词：マオ</li><li>作曲：ゆうや</li><li>专辑：バタフライエフェクト（2017年5月10日由Ki/oon Music Inc.发行）</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近シド15周年发久违的新专，不过翻译一首去年的一直想翻译的非常好听的歌。</p><a id="more"></a><h2 id="假名歌词"><a href="#假名歌词" class="headerlink" title="假名歌词"></a>假名歌词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">通（とお）り雨（あめ）にうたれただけ　言（い）い聞（き）かせていた</span><br><span class="line">錆（さ）びたガラクタ　になるよりはましだと</span><br><span class="line">眠（ねむ）れない夜（よる）　瞑（つむ）る　怒（いか）り抱（だ）いて</span><br><span class="line"></span><br><span class="line">嵐（あらし）の前（まえ）のような　不適切（ふてきせつ）な　笑（え）み　浮（う）かべ</span><br><span class="line">その急所（きゅうしょ）を　狙（ねら）えよ</span><br><span class="line"></span><br><span class="line">空高（そらたか）くまで　助（たす）け　乞（こ）う声（こえ）</span><br><span class="line">今（いま）はまだ　届（とど）かない　そこに救（すく）いの手（て）もない</span><br><span class="line">賢者（けんじゃ）になれない　愚（おろ）かな君（きみ）</span><br><span class="line">頭（あたま）の中（なか）　溢（あふ）れ　イツカミテロ　溢（あふ）れだす</span><br><span class="line">何（なに）もかもを全（すべ）て　おれが捻（ね）じ曲（ま）げよう</span><br><span class="line"></span><br><span class="line">氷（こおり）が溶（と）ける音（おと）に　ただ　耳（みみ）を澄（す）ませてた</span><br><span class="line">我慢（がまん）のときを　じっと　楽（たの）しむように</span><br><span class="line">いつか来（く）る　朝（あさ）を　待（ま）ち望（のぞ）んで</span><br><span class="line"></span><br><span class="line">嫌悪（けんお）で　塗（ぬ）り潰（つぶ）す　少（すこ）しだけ　闇（やみ）　浮（う）かべ</span><br><span class="line">その隙（すき）みて　奪（うば）えよ</span><br><span class="line"></span><br><span class="line">空高（そらたか）くまで　助（たす）け　乞（こ）う声（こえ）</span><br><span class="line">今（いま）はまだ　届（とど）かない　そこに救（すく）いの手（て）もない</span><br><span class="line">賢者（けんじゃ）になれない　愚（おろ）かな君（きみ）</span><br><span class="line">頭（あたま）の中（なか）　溢（あふ）れ　イツカミテロ　溢（あふ）れだす</span><br><span class="line">何（なに）もかもを全（すべ）て　おれが捻（ね）じ曲（ま）げよう</span><br><span class="line"></span><br><span class="line">空高（そらたか）くまで　助（たす）け　乞（こ）う声（こえ）</span><br><span class="line">今（いま）はもう　届（とど）かない　そこに救（すく）いの手（て）もない</span><br><span class="line">賢者（けんじゃ）になれない　愚（おろ）かな君（きみ）</span><br><span class="line">頭（あたま）の中（なか）　溢（あふ）れ　イマニミテロ　溢（あふ）れだす</span><br><span class="line">何（なに）もかもを全（すべ）て　おれが捻（ね）じ曲（ま）げよう</span><br><span class="line">深紅（しんく）の羽（はね）　広（ひろ）げ　おれが変（か）えてみせよう</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;歌曲信息&quot;&gt;&lt;a href=&quot;#歌曲信息&quot; class=&quot;headerlink&quot; title=&quot;歌曲信息&quot;&gt;&lt;/a&gt;歌曲信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌曲：バタフライエフェクト&lt;/li&gt;
&lt;li&gt;歌手：シド&lt;/li&gt;
&lt;li&gt;作词：マオ&lt;/li&gt;
&lt;li&gt;作曲：ゆうや&lt;/li&gt;
&lt;li&gt;专辑：バタフライエフェクト（2017年5月10日由Ki/oon Music Inc.发行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近シド15周年发久违的新专，不过翻译一首去年的一直想翻译的非常好听的歌。&lt;/p&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ウタ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%82%A6%E3%82%BF/"/>
    
    
      <category term="シド" scheme="http://tashi711.xyz/tags/%E3%82%B7%E3%83%89/"/>
    
  </entry>
  
  <entry>
    <title>「850. Rectangle Area II」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-850/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-850/</id>
    <published>2018-06-10T03:57:02.000Z</published>
    <updated>2018-06-10T04:08:18.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/rectangle-area-ii/description/" target="_blank" rel="noopener">850. Rectangle Area II</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　给定N（1到200）个矩形，坐标范围在0到10^9，求这N个矩形覆盖的面积，结果对10^9+7取模，题目保证总的覆盖范围不超过2^63-1。<br>　　样例1：输入[[0,0,2,2],[1,0,2,3],[1,0,3,1]]，输出6。<br>　　样例2：输入[[0,0,1000000000,1000000000]]，输出49。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　数据范围很大，但分布很稀疏，比较裸的离散化了。</p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>　　主要是判断离散化后的某个单独小块在原图中的面积比较麻烦，画个图就清楚了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^3)$。<br>　　空间复杂度为$O(N^2)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">220</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN][kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rectangles.size());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : rectangles) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">adj.push_back(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(adj.begin(), adj.end());</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="keyword">int</span> tot = n * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) &#123;</span><br><span class="line">f[adj[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : rectangles) &#123;</span><br><span class="line"><span class="keyword">int</span> ux = f[i[<span class="number">0</span>]], uy = f[i[<span class="number">1</span>]], vx = f[i[<span class="number">2</span>]], vy = f[i[<span class="number">3</span>]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ux; j &lt; vx; ++j) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = uy; k &lt; vy; ++k) &#123;</span><br><span class="line">a[j][k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">ans += <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(adj[i + <span class="number">1</span>] - adj[i]) * ((adj[j + <span class="number">1</span>] - adj[j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>这道题也能用二维线段树解，复杂度可以达到$O(N \log N)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/rectangle-area-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;850. Rectangle Area II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　给定N（1到200）个矩形，坐标范围在0到10^9，求这N个矩形覆盖的面积，结果对10^9+7取模，题目保证总的覆盖范围不超过2^63-1。&lt;br&gt;　　样例1：输入[[0,0,2,2],[1,0,2,3],[1,0,3,1]]，输出6。&lt;br&gt;　　样例2：输入[[0,0,1000000000,1000000000]]，输出49。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="离散化" scheme="http://tashi711.xyz/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>「843. Guess the Word」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-843/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-843/</id>
    <published>2018-06-08T12:39:10.000Z</published>
    <updated>2018-06-08T12:56:22.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/guess-the-word/description/" target="_blank" rel="noopener">843. Guess the Word</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　交互题目：<br>　　给定N（样例为4，测试数据为100）个不同单词的list，都是小写，6位长，采样随机，其中有一个是secret的，通过调用master.guess(word)可以猜词并返回word与secret单词匹配的个数（值和位置都要匹配），但word必须是给定的list里面的，否则返回-1。小于等于10次猜对即为正确。<br>　　样例：secret = “acckzz”，wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”]：<br>　　master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.<br>　　master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.<br>　　master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.<br>　　master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.<br>　　master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.<br>　　上面猜了5次，有一次猜对了，即为正确。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　尝试了随机的方法，即每次都取满足目前猜过的情况中随机的词猜，结果猜不出来，因此需要更加有启发性的算法。参考了题解，其中有一句非常精妙：每次都应该使得保留的词尽可能少。而这个值因为可能是跟目前猜的词匹配数为0到6的任意情况，因此要使得最坏的情况（匹配后留下最多的长度）最优（最少），那么可以先预处理出两两的匹配情况，每次猜词的时候选使得其他所有可能单词匹配最多的时候最少。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^2)$。<br>　　空间复杂度为$O(N^2)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kNumTry = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kLenStr = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; u, <span class="keyword">const</span> <span class="built_in">string</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kLenStr; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (u[i] == v[i]) &#123;</span><br><span class="line">++res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordlist)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">f[i][j] = match(wordlist[i], wordlist[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; adj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">-1</span>, min_max = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : adj) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt[kLenStr + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : adj) &#123;</span><br><span class="line">++cnt[f[i][j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur_max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= kLenStr; ++j) &#123;</span><br><span class="line">cur_max = max(cur_max, cnt[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur_max &lt; min_max) &#123;</span><br><span class="line">min_max = cur_max;</span><br><span class="line">res = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSecretWord</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordlist, Master&amp; master)</span> </span>&#123;</span><br><span class="line">n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(wordlist.size());</span><br><span class="line">pre(wordlist);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">adj.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">1</span>; cnt &lt;= kNumTry; ++cnt) &#123;</span><br><span class="line"><span class="keyword">int</span> cur_idx = calc(adj);</span><br><span class="line"><span class="keyword">int</span> cur_match = master.guess(wordlist[cur_idx]);</span><br><span class="line"><span class="keyword">if</span> (cur_match == kLenStr) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : adj) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[cur_idx][i] == cur_match &amp;&amp; i != cur_idx) &#123;</span><br><span class="line">pos.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">adj = pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/guess-the-word/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;843. Guess the Word&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　交互题目：&lt;br&gt;　　给定N（样例为4，测试数据为100）个不同单词的list，都是小写，6位长，采样随机，其中有一个是secret的，通过调用master.guess(word)可以猜词并返回word与secret单词匹配的个数（值和位置都要匹配），但word必须是给定的list里面的，否则返回-1。小于等于10次猜对即为正确。&lt;br&gt;　　样例：secret = “acckzz”，wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”]：&lt;br&gt;　　master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.&lt;br&gt;　　master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.&lt;br&gt;　　master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.&lt;br&gt;　　master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.&lt;br&gt;　　master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.&lt;br&gt;　　上面猜了5次，有一次猜对了，即为正确。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="交互题" scheme="http://tashi711.xyz/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「839. Similar String Groups」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-839/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-839/</id>
    <published>2018-06-07T14:00:06.000Z</published>
    <updated>2018-06-07T14:09:21.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/similar-string-groups/description/" target="_blank" rel="noopener">839. Similar String Groups</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　给定N（1到2000）个长度为M（1到1000）的字符串，如果某两个字符串是相似的，当且仅当从某个字符串交换某两个字母位置后可以得到另一个。把这些字符串分成很多组，其中每组当中的每一个字符串至少跟同组的某一个字符串相似。求问这N个字符串被分为多少组。<br>　　给的字符串都是小写且包含的字母相同，另外有N*M≤20000，且judge时间更加充裕。<br>　　样例：输入[“tars”,”rats”,”arts”,”star”]，输出2。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　用很裸的方法两两判断相似，连边，然后找连通分量个数即可。复杂度是$O(N^2M)$，但由于题设有N*M≤20000和judge时间充裕的假设，试着提交了下，直接AC了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^2M)$。<br>　　空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">2200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[kMaxN];</span><br><span class="line"><span class="keyword">bool</span> vst[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">similar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; u, <span class="keyword">const</span> <span class="built_in">string</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (u[i] != v[i]) &#123;</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">vst[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(adj[u].size()); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = adj[u][i];</span><br><span class="line"><span class="keyword">if</span> (!vst[v]) &#123;</span><br><span class="line">dfs(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(A.size());</span><br><span class="line">m = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(A[<span class="number">0</span>].size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">adj[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (similar(A[i], A[j])) &#123;</span><br><span class="line">adj[i].push_back(j);</span><br><span class="line">adj[j].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span> vst);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vst[i]) &#123;</span><br><span class="line">dfs(i);</span><br><span class="line">++ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/similar-string-groups/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;839. Similar String Groups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　给定N（1到2000）个长度为M（1到1000）的字符串，如果某两个字符串是相似的，当且仅当从某个字符串交换某两个字母位置后可以得到另一个。把这些字符串分成很多组，其中每组当中的每一个字符串至少跟同组的某一个字符串相似。求问这N个字符串被分为多少组。&lt;br&gt;　　给的字符串都是小写且包含的字母相同，另外有N*M≤20000，且judge时间更加充裕。&lt;br&gt;　　样例：输入[“tars”,”rats”,”arts”,”star”]，输出2。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="图论" scheme="http://tashi711.xyz/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="连通分量" scheme="http://tashi711.xyz/tags/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>「847. Shortest Path Visiting All Nodes」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-847/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-847/</id>
    <published>2018-06-07T01:36:10.000Z</published>
    <updated>2018-06-07T03:13:07.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/shortest-path-visiting-all-nodes/description/" target="_blank" rel="noopener">847. Shortest Path Visiting All Nodes</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　给定N（1到12）个结点的无向无权图，输出访问到所有点的最短路径，可以重复走点、边，也可以自选起终点。<br>　　样例1：图为[[1,2,3],[0],[0],[0]]，输出4，（一种可能的最短路径为[1,0,2,0,3]）。<br>　　样例2：图为[[1],[0,2,4],[1,3,4],[2],[1,2]]，输出4，（一种可能的最短路径为[0,1,4,2,3]）。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　比较裸的一道状态压缩的题目，数据规模比较小又可以明显的找到父状态与子状态。<br>　　定义DP的数组为f[i][j]，其中i为访问状态，范围从0到$2^N-1$，每一位如果为1表示这个位置的结点访问过，为0表示未访问过，j为最后停留的结点位置，范围从0到N-1，当然必须属于i中为1的位置，否则这个状态组合就不合理（停留在j处但j没访问过），记chd为i去掉位置j处1的状态（因为最后停留在j，说明是最后走到了j，那么i一定是从chd转移过来的，否则没有意义），那么转移方程为f[i][j] = min{f[chd][k] + d[k][j]}，其中k为chd中1的位置，d[k][j]为k到j的距离，可以通过每个点进行bfs求最短路预处理得到，复杂度为$O(N^3)$。<br>　　DP的状态数量为$O(2^N)\cdot O(N)$，转移复杂度为$O(N)$，即枚举子状态chd的1的位置，因为$O(2^N)$是$O(N)$的高阶项，可以认为总的复杂度为$O(N^2\cdot2^N)$，是完全能接受的。<br>　　初始状态为f[只有第j个位置为1][any j] = 0，即自选起点。<br>　　目标状态为max{f[全1][any j]}，即枚举每个可能的终点。</p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>　　访问状态的枚举顺序从小到大即可。因为父状态一定比子状态大（父状态是子状态某个位置多了1），即如果访问状态从小到大枚举，计算父状态的时候子状态一定被计算好了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^2\cdot2^N)$。<br>　　空间复杂度为$O(N\cdot2^N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxM = <span class="number">1</span> &lt;&lt; kMaxN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxM][kMaxN];</span><br><span class="line"><span class="keyword">int</span> d[kMaxN][kMaxN];</span><br><span class="line"><span class="keyword">bool</span> vst[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; adj, <span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span> vst);</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.emplace(st, <span class="number">0</span>);</span><br><span class="line">vst[st] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front().first, w = q.front().second;</span><br><span class="line">d[st][u] = w;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(adj[u].size()); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = adj[u][i];</span><br><span class="line"><span class="keyword">if</span> (!vst[v]) &#123;</span><br><span class="line">q.emplace(v, w + <span class="number">1</span>);</span><br><span class="line">vst[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestPathLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3F</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3F</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(graph.size());</span><br><span class="line"><span class="keyword">int</span> m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">bfs(graph, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">f[<span class="number">1</span> &lt;&lt; i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line"><span class="keyword">int</span> chd = i - (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line"><span class="keyword">if</span> (chd &amp; (<span class="number">1</span> &lt;&lt; k)) &#123;</span><br><span class="line">f[i][j] = min(f[i][j], f[chd][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = n * n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">ans = min(ans, f[m][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/shortest-path-visiting-all-nodes/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;847. Shortest Path Visiting All Nodes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　给定N（1到12）个结点的无向无权图，输出访问到所有点的最短路径，可以重复走点、边，也可以自选起终点。&lt;br&gt;　　样例1：图为[[1,2,3],[0],[0],[0]]，输出4，（一种可能的最短路径为[1,0,2,0,3]）。&lt;br&gt;　　样例2：图为[[1],[0,2,4],[1,3,4],[2],[1,2]]，输出4，（一种可能的最短路径为[0,1,4,2,3]）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="状态压缩DP" scheme="http://tashi711.xyz/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 834. Sum of Distances in Tree」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-834/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-834/</id>
    <published>2018-06-04T11:33:46.000Z</published>
    <updated>2018-06-04T11:41:51.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/sum-of-distances-in-tree/description/" target="_blank" rel="noopener">LeetCode 834. Sum of Distances in Tree</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　给定N（1到10000）个结点的树，边的长度都是1，输出每个点到其他所有点的距离之和。<br>　　样例：N为6，边为[[0,1],[0,2],[2,3],[2,4],[2,5]]，输出[8,12,6,10,10,10]。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　比较简单的一道题目，暴力解决N方，其实每个点的距离和可以由相邻点得到，减去这一侧的点数加上另一侧的点数即可。<br>　　因此可以先$O(N)$算出某个点的距离和，再逐个往外算出每个点的距离和，每个点仅需$O(1)$就能得到，当然要先预处理出这一侧所有点的个数。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N)$。<br>　　空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">11000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[kMaxN], tree[kMaxN];</span><br><span class="line"><span class="keyword">bool</span> vst[kMaxN];</span><br><span class="line"><span class="keyword">int</span> cnt[kMaxN];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumOfDistancesInTree(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">n = N;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">adj[i].clear();</span><br><span class="line">tree[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">adj[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">adj[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">ans.clear();</span><br><span class="line">ans.resize(n);</span><br><span class="line"><span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span> vst);</span><br><span class="line">build_tree();</span><br><span class="line">cal_num(<span class="number">0</span>);</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">work();</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_num</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">cnt[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(tree[u].size()); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = tree[u][i];</span><br><span class="line">cnt[u] += cal_num(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">0</span>);</span><br><span class="line">vst[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(adj[u].size()); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = adj[u][i];</span><br><span class="line"><span class="keyword">if</span> (!vst[v]) &#123;</span><br><span class="line">tree[u].push_back(v);</span><br><span class="line">q.push(v);</span><br><span class="line">vst[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">sum += s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(tree[u].size()); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = tree[u][i];</span><br><span class="line">dfs(v, s + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal_ans</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">ans[u] = s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(tree[u].size()); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = tree[u][i];</span><br><span class="line">cal_ans(v, s - cnt[v] + n - cnt[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cal_ans(<span class="number">0</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/sum-of-distances-in-tree/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 834. Sum of Distances in Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　给定N（1到10000）个结点的树，边的长度都是1，输出每个点到其他所有点的距离之和。&lt;br&gt;　　样例：N为6，边为[[0,1],[0,2],[2,3],[2,4],[2,5]]，输出[8,12,6,10,10,10]。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="树形DP" scheme="http://tashi711.xyz/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 828. Unique Letter String」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-828/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-828/</id>
    <published>2018-05-31T12:00:32.000Z</published>
    <updated>2018-05-31T12:15:25.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/unique-letter-string/description/" target="_blank" rel="noopener">LeetCode 828. Unique Letter String</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　定义unique character为字符串中出现正好一次的字母，定义UNIQ(S)为字符串S中unique character的个数。给定一个只含有大写字母的字符串S，求S的所有非空子串的UNIQ之和，如果两个不同位置的子串相同被认为是不同的子串。结果对10^9+7取模。<br>　　样例：1、”ABC”-&gt;10；2、”ABA”-&gt;8。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　比较简单的一道题目，考虑每个单独的字母对于最终答案的贡献。如果某个字母a对答案有贡献，那么包含他的子串一定在从这个a往两边延伸到边界或者另一个a之内位置的范围内。那么总共可能的子串有u*v个，其中u、v分别为延伸到边界或者另一个a之内位置的长度。对每个’A’到’Z’的字母a，找到每个a的位置，计算往外延伸的长度，乘起来累加到答案即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为 $O(NM)$，其中M为字母个数，可以认为是常数26。<br>　　空间复杂度为 $O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kM = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniqueLetterString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> work(S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'A'</span>; i &lt;= <span class="string">'Z'</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[j] == i) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt_pre = j + <span class="number">1</span>, cnt_next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">++cnt_next;</span><br><span class="line"><span class="keyword">if</span> (s[k] == i) &#123;</span><br><span class="line">ans = (ans + cnt_pre * cnt_next) % kM;</span><br><span class="line">cnt_pre = cnt_next;</span><br><span class="line">cnt_next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = (ans + cnt_pre * (cnt_next + <span class="number">1</span>)) % kM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/unique-letter-string/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 828. Unique Letter String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　定义unique character为字符串中出现正好一次的字母，定义UNIQ(S)为字符串S中unique character的个数。给定一个只含有大写字母的字符串S，求S的所有非空子串的UNIQ之和，如果两个不同位置的子串相同被认为是不同的子串。结果对10^9+7取模。&lt;br&gt;　　样例：1、”ABC”-&amp;gt;10；2、”ABA”-&amp;gt;8。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>「LeetCode 803. Bricks Falling When Hit」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-803/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-803/</id>
    <published>2018-05-25T08:00:34.000Z</published>
    <updated>2018-05-25T14:42:24.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/bricks-falling-when-hit/description/" target="_blank" rel="noopener">LeetCode 803. Bricks Falling When Hit</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　给定一个0-1矩阵（[1, 200]×[1, 200]），1代表砖块，一个砖块不会掉落当且仅当它所在的4-连通分支直接连着顶层。<br>　　给定一系列消除（不超过矩阵面积次，且每次不一样），每次消除某一个位置，输出每次消除后掉落多少块（若该位置没有砖块输出0）。<br>　　样例1：<br>　　Input: grid = [[1,0,0,0],[1,1,1,0]]，hits = [[1,0]]；Output: [2]。<br>　　样例2：<br>　　Input: grid = [[1,0,0,0],[1,1,0,0]]，hits = [[1,1],[1,0]]；Output: [0,0]。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　比较难的一道题，其实一开始有想到倒序思考外加并查集，不过没有细想下去，看了题解发现自己的第一想法是对的，只是多注意一些处理的细节就好了。<br>　　首先一开始想到的是每次消除都做一遍种子填充，复杂度为$O(N^4)$，不太能接受。因此还是要想到倒序处理以及并查集才能完美解决这一题。一开始先去掉所有消除的块，用种子填充先预处理好所有的子连通分量，再逆序一个一个添加被消除的块，每次添加都判断是否有悬空的连通分量连上悬挂的连通分量，如果有，那么说明这个悬空的连通分量的就是在消除这一个位置块的时候掉下的。</p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>　　在并查集的最祖先的结点处保存这个连通分量是不是悬挂的以及整个连通分量的大小。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^2\alpha(N^2))$，其中$\alpha$是反Ackermann函数，也就是并查集的复杂度（通常被认为是小于等于4的常数）。<br>　　空间复杂度为$O(N^2)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kN = <span class="number">220</span>, kM = <span class="number">44000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kDU[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kDV[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[kM];</span><br><span class="line"><span class="keyword">int</span> cnt[kM];</span><br><span class="line"><span class="keyword">bool</span> top[kM];</span><br><span class="line"><span class="keyword">int</span> vst[kN][kN];</span><br><span class="line"><span class="keyword">int</span> n, m, h;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_p</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[k] != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> p[k] = find_p(p[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> u * m + v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>* u, <span class="keyword">int</span>* v)</span> </span>&#123;</span><br><span class="line">*u = k / m;</span><br><span class="line">*v = k % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; adj, <span class="keyword">int</span> sk, <span class="keyword">bool</span>* ok)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u &gt;= <span class="number">0</span> &amp;&amp; u &lt; n &amp;&amp; v &gt;= <span class="number">0</span> &amp;&amp; v &lt; m &amp;&amp; !vst[u][v] &amp;&amp; a[u][v]) &#123;</span><br><span class="line"><span class="keyword">int</span> k = f(u, v);</span><br><span class="line">adj.emplace_back(k);</span><br><span class="line">vst[u][v] = <span class="literal">true</span>;</span><br><span class="line">p[k] = sk;</span><br><span class="line"><span class="keyword">if</span> (u == <span class="number">0</span>) &#123;</span><br><span class="line">*ok = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flood_fill</span><span class="params">(<span class="keyword">int</span> su, <span class="keyword">int</span> sv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> sk = f(su, sv);</span><br><span class="line">q.push_back(sk);</span><br><span class="line">vst[su][sv] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> ok = (su == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(q.size()); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> k = q[i], u, v;</span><br><span class="line">g(k, &amp;u, &amp;v);</span><br><span class="line">solve(u + <span class="number">1</span>, v, q, sk, &amp;ok);</span><br><span class="line">solve(u - <span class="number">1</span>, v, q, sk, &amp;ok);</span><br><span class="line">solve(u, v + <span class="number">1</span>, q, sk, &amp;ok);</span><br><span class="line">solve(u, v - <span class="number">1</span>, q, sk, &amp;ok);</span><br><span class="line">&#125;</span><br><span class="line">cnt[sk] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(q.size());</span><br><span class="line">top[sk] = ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hitBricks(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; hits) &#123;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0xFF</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line"><span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span> vst);</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="built_in">memset</span>(top, <span class="number">0</span>, <span class="keyword">sizeof</span> top);</span><br><span class="line"></span><br><span class="line">n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(grid.size());</span><br><span class="line">m = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(grid[<span class="number">0</span>].size());</span><br><span class="line">h = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(hits.size());</span><br><span class="line"></span><br><span class="line">a = grid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> u = hits[i][<span class="number">0</span>], v = hits[i][<span class="number">1</span>];</span><br><span class="line">a[u][v] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> k = f(i, j);</span><br><span class="line"><span class="keyword">if</span> (a[i][j] &amp;&amp; !vst[i][j]) &#123;</span><br><span class="line">flood_fill(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = h - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">int</span> u = hits[i][<span class="number">0</span>], v = hits[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (grid[u][v]) &#123;</span><br><span class="line"><span class="keyword">int</span> k = f(u, v);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> cu = u + kDU[j], cv = v + kDV[j];</span><br><span class="line"><span class="keyword">if</span> (cu &gt;= <span class="number">0</span> &amp;&amp; cu &lt; n &amp;&amp; cv &gt;= <span class="number">0</span> &amp;&amp; cv &lt; m &amp;&amp; a[cu][cv]) &#123;</span><br><span class="line"><span class="keyword">int</span> ck = f(cu, cv);</span><br><span class="line"><span class="keyword">int</span> pck = find_p(ck);</span><br><span class="line">s.insert(pck);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[u][v] = <span class="number">1</span>;</span><br><span class="line">cnt[k] = <span class="number">1</span>;</span><br><span class="line">top[k] = (u == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!s.empty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cp : s) &#123;</span><br><span class="line">p[cp] = k;</span><br><span class="line">cnt[k] += cnt[cp];</span><br><span class="line">top[k] = (top[k] || top[cp]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (top[k]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cp : s) &#123;</span><br><span class="line"><span class="keyword">if</span> (!top[cp]) &#123;</span><br><span class="line">sum += cnt[cp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[i] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>　　有时候要相信自己的第一直觉，这往往是解决题目的关键。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/bricks-falling-when-hit/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 803. Bricks Falling When Hit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　给定一个0-1矩阵（[1, 200]×[1, 200]），1代表砖块，一个砖块不会掉落当且仅当它所在的4-连通分支直接连着顶层。&lt;br&gt;　　给定一系列消除（不超过矩阵面积次，且每次不一样），每次消除某一个位置，输出每次消除后掉落多少块（若该位置没有砖块输出0）。&lt;br&gt;　　样例1：&lt;br&gt;　　Input: grid = [[1,0,0,0],[1,1,1,0]]，hits = [[1,0]]；Output: [2]。&lt;br&gt;　　样例2：&lt;br&gt;　　Input: grid = [[1,0,0,0],[1,1,0,0]]，hits = [[1,1],[1,0]]；Output: [0,0]。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="种子填充算法" scheme="http://tashi711.xyz/tags/%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/"/>
    
      <category term="并查集" scheme="http://tashi711.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>PuTTY与Atom上SSH与SFTP的Public Key认证总结</title>
    <link href="http://tashi711.xyz/programming/technologies/SSH/"/>
    <id>http://tashi711.xyz/programming/technologies/SSH/</id>
    <published>2018-05-25T03:15:34.000Z</published>
    <updated>2018-05-31T12:18:24.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本机配置"><a href="#本机配置" class="headerlink" title="本机配置"></a>本机配置</h2><p>　　主要是Windows上的配置（前提是远端服务器上已经配置好相应的id_rsa.pub了）。</p><h3 id="PuTTY"><a href="#PuTTY" class="headerlink" title="PuTTY"></a>PuTTY</h3><p>　　1、配置好或者Load已有的密码登录配置；<br>　　2、生成好id_rsa（可以通过Git Bash生成或者从Linux中生成好拷贝过来）；<br>　　3、运行PuTTY安装目录下的puttygen.exe，选择菜单Conversions中的Import key，选择id_rsa文件，载入后看得到key框里面有id_rsa的信息，点击右下方的save private key，保存到一个PuTTY专用的private key文件（.ppk）中；<br>　　4、在PuTTY的左边选择SSH-&gt;Auth，在右边点击Browse按钮，载入刚才存储的.ppk文件；<br>　　5、在PuTTY的左边选择Connection-&gt;Data，在右边Auto-login username输入框中填写SSH的用户名；<br>　　6、在PuTTY的左边选择Session，在右边点击Save把配置保存下来；<br>　　7、完成配置，之后登陆会发现直接能SSH上去不需要输密码了。</p><a id="more"></a><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>　　1、配置好已有的密码登录配置；<br>　　2、密码项已经不需要了，设为空：”pass”: “”。（如果以前有配置的话）<br>　　3、配置私钥所在位置，一般如下：”privatekey”: “C:/Users/[xxx]/.ssh/id_rsa”，其中[xxx]为自己的本机系统用户名。注意即使在Windows下文件名分隔符要使用左斜杠<br>　　4、完成配置，之后直接点击Connect就可以直接登陆了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>　　Linux下注意更换id_rsa和id_rsa.pub之后重新log in一下即可。<br>　　另外，如果没有配置过ssh-agent可以先执行：eval <code>ssh-agent -s</code>，然后执行ssh-add，这些是永久生效的，之后开机就不用再执行了。<br>　　如果遇到id_rsa权限过高的情况，可以再将id_rsa给chmod到0600，之后就可以顺利连上ssh和sftp了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本机配置&quot;&gt;&lt;a href=&quot;#本机配置&quot; class=&quot;headerlink&quot; title=&quot;本机配置&quot;&gt;&lt;/a&gt;本机配置&lt;/h2&gt;&lt;p&gt;　　主要是Windows上的配置（前提是远端服务器上已经配置好相应的id_rsa.pub了）。&lt;/p&gt;
&lt;h3 id=&quot;PuTTY&quot;&gt;&lt;a href=&quot;#PuTTY&quot; class=&quot;headerlink&quot; title=&quot;PuTTY&quot;&gt;&lt;/a&gt;PuTTY&lt;/h3&gt;&lt;p&gt;　　1、配置好或者Load已有的密码登录配置；&lt;br&gt;　　2、生成好id_rsa（可以通过Git Bash生成或者从Linux中生成好拷贝过来）；&lt;br&gt;　　3、运行PuTTY安装目录下的puttygen.exe，选择菜单Conversions中的Import key，选择id_rsa文件，载入后看得到key框里面有id_rsa的信息，点击右下方的save private key，保存到一个PuTTY专用的private key文件（.ppk）中；&lt;br&gt;　　4、在PuTTY的左边选择SSH-&amp;gt;Auth，在右边点击Browse按钮，载入刚才存储的.ppk文件；&lt;br&gt;　　5、在PuTTY的左边选择Connection-&amp;gt;Data，在右边Auto-login username输入框中填写SSH的用户名；&lt;br&gt;　　6、在PuTTY的左边选择Session，在右边点击Save把配置保存下来；&lt;br&gt;　　7、完成配置，之后登陆会发现直接能SSH上去不需要输密码了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="技术" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SSH" scheme="http://tashi711.xyz/tags/SSH/"/>
    
      <category term="Public Key" scheme="http://tashi711.xyz/tags/Public-Key/"/>
    
  </entry>
  
  <entry>
    <title>「焚吐 / みやかわくん - 神風エクスプレス」鑑賞</title>
    <link href="http://tashi711.xyz/nihongo/uta/kamikaze-ekusupuresu/"/>
    <id>http://tashi711.xyz/nihongo/uta/kamikaze-ekusupuresu/</id>
    <published>2018-05-08T12:37:54.000Z</published>
    <updated>2018-05-08T12:53:02.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="歌曲信息"><a href="#歌曲信息" class="headerlink" title="歌曲信息"></a>歌曲信息</h2><blockquote><ul><li>歌曲：神風エクスプレス</li><li>歌手：焚吐 / みやかわくん</li><li>作词：焚吐</li><li>作曲：焚吐 / みやかわくん</li><li>专辑：神風エクスプレス（2018年2月14日发行）</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>柯南最新的ED、听起来很有feeling、就稍微译了译。<br>焚吐的声音好好听哇、花痴ing…</p><a id="more"></a><h2 id="假名歌词"><a href="#假名歌词" class="headerlink" title="假名歌词"></a>假名歌词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">ああ　霞（かすみ）の中（なか）　伸（の）ばした腕（うで）が</span><br><span class="line">少（すこ）し震（ふる）えている　海岸線午前四時（かいがんせんごぜんよんじ）</span><br><span class="line"></span><br><span class="line">ああ　不安（ふあん）と高揚感（こうようかん）　一緒（いっしょ）くたにして</span><br><span class="line">波（なみ）は揺（ゆ）らめいていた</span><br><span class="line"></span><br><span class="line">未来（みらい）はそう　封（ふう）を切（き）る前（まえ）の前（まえ）</span><br><span class="line">出来上（できあ）がってさえいない原材料（げんざいりょう）</span><br><span class="line"></span><br><span class="line">「まだまだ足掻（あが）ける　ここから駆（か）けるんだ」って</span><br><span class="line">君（きみ）の　君（きみ）の　一声（ひとこえ）で全（すべ）て始（はじ）まる</span><br><span class="line"></span><br><span class="line">一二（いちに）の三（さん）で飛（と）んでいこう</span><br><span class="line">目（め）は閉（と）じていて構（かま）わない</span><br><span class="line">熱（ねつ）を帯（お）びる夢（ゆめ）</span><br><span class="line"></span><br><span class="line">瞼（まぶた）の裏（うら）でもうずっと</span><br><span class="line">思（おも）い描（えが）いてきたエクスプレス</span><br><span class="line">とうとう発進（はっしん）です</span><br><span class="line"></span><br><span class="line">ああ　明（あ）けた空（そら）が　誘（いざな）っている</span><br><span class="line">白（しろ）いアーチを成（な）して　僕（ぼく）らを待（ま）ち構（かま）える</span><br><span class="line"></span><br><span class="line">「その期待（きたい）こそが　足枷（あしかせ）なんだ</span><br><span class="line">どうか放（ほう）っといてくれよ」</span><br><span class="line"></span><br><span class="line">いつだってそう　忙（いそが）しい生（い）き物（もの）だ</span><br><span class="line">頼（たの）まれちゃいないのに今日（きょう）だって</span><br><span class="line"></span><br><span class="line">何十回目（なにじゅっかいめ）かの　愛（あい）や夢（ゆめ）に四苦八苦（しくはっく）</span><br><span class="line">正直（しょうじき）　うんざり　することもあるけれど</span><br><span class="line"></span><br><span class="line">地平（ちへい）の向（む）こう一心（いっしん）に</span><br><span class="line">目（め）を凝（こ）らすのも無駄（むだ）ではない</span><br><span class="line">高（たか）らかに歌（うた）え</span><br><span class="line"></span><br><span class="line">僕（ぼく）らが明日（あす）を見（み）ていた</span><br><span class="line">丁度（ちょうど）そのとき明日（あした）の方（ほう）</span><br><span class="line">も僕（ぼく）らを見（み）ていた</span><br><span class="line"></span><br><span class="line">願（ねが）いだって　未来（みらい）だって</span><br><span class="line">僕（ぼく）らはむしろ曖昧（あいまい）な方（ほう）が良（よ）い</span><br><span class="line">飛（と）び方（かた）もなんとなくで良（よ）い</span><br><span class="line"></span><br><span class="line">きっときっと　きっときっと　きっときっと</span><br><span class="line">そっちの方（ほう）が長（なが）く飛（と）べるや</span><br><span class="line"></span><br><span class="line">一二（いちに）の三（さん）で合図（あいず）して</span><br><span class="line">目（め）は閉（と）じていて構（かま）わない</span><br><span class="line">熱（ねつ）を帯（お）びる夢（ゆめ）</span><br><span class="line"></span><br><span class="line">あらゆる闇（やみ）を消（け）し去（さ）る</span><br><span class="line">ような神風（かみかぜ）エクスプレス</span><br><span class="line">とうとう発進（はっしん）です</span><br></pre></td></tr></table></figure><h2 id="其他感想"><a href="#其他感想" class="headerlink" title="其他感想"></a>其他感想</h2><p>焚吐之前唱过柯南的ED、声音很有特点。<br>みやかわくん稍微冷门点、是存活在二次元的翻唱歌手。<br>反正之后柯南的新曲好听都都会稍微译一译^_^…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;歌曲信息&quot;&gt;&lt;a href=&quot;#歌曲信息&quot; class=&quot;headerlink&quot; title=&quot;歌曲信息&quot;&gt;&lt;/a&gt;歌曲信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌曲：神風エクスプレス&lt;/li&gt;
&lt;li&gt;歌手：焚吐 / みやかわくん&lt;/li&gt;
&lt;li&gt;作词：焚吐&lt;/li&gt;
&lt;li&gt;作曲：焚吐 / みやかわくん&lt;/li&gt;
&lt;li&gt;专辑：神風エクスプレス（2018年2月14日发行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;柯南最新的ED、听起来很有feeling、就稍微译了译。&lt;br&gt;焚吐的声音好好听哇、花痴ing…&lt;/p&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ウタ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%82%A6%E3%82%BF/"/>
    
    
      <category term="名侦探柯南" scheme="http://tashi711.xyz/tags/%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>「Google C++ Style Guide」小结</title>
    <link href="http://tashi711.xyz/programming/notes/others/google-code-style/"/>
    <id>http://tashi711.xyz/programming/notes/others/google-code-style/</id>
    <published>2018-05-06T03:17:59.000Z</published>
    <updated>2018-05-23T14:05:38.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h2><p>刚进公司的时候看过一遍、现在需要重新再学习一下、顺便写点笔记。<br>（如果记得没错的话这份文档的名字改过了、以前叫coding style、现在叫style guide了）。<br>对于一些平时一直习惯使用的（比如#define保护）以及一些不推荐使用但是基本不会用到的（比如前置声明）就不再赘述了。<br>下面附上链接：</p><ul><li><a href="http://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">英文版链接</a></li><li><a href="http://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">中文版链接</a></li></ul><a id="more"></a><h3 id="include的路径及顺序"><a href="#include的路径及顺序" class="headerlink" title="#include的路径及顺序"></a>#include的路径及顺序</h3><p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录)。<br>xxx.cc 中包含头文件的次序如下(按字母顺序分别对每种类型的头文件进行二次排序):</p><ol><li>xxx.h</li><li>C 系统文件</li><li>C++ 系统文件</li><li>其他库的 .h 文件</li><li>本项目内 .h 文件</li></ol><p>举例来说, google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;foo/public/fooserver.h&quot; // 优先位置</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;hash_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;base/basictypes.h&quot;</span><br><span class="line">#include &quot;base/commandlineflags.h&quot;</span><br><span class="line">#include &quot;foo/public/bar.h&quot;</span><br></pre></td></tr></table></figure><p>例外：有时平台特定代码需要条件编译，这些代码可以放到其它 includes 之后，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;foo/public/fooserver.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;base/port.h&quot;  // For LANG_CXX11.</span><br><span class="line"></span><br><span class="line">#ifdef LANG_CXX11</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#endif  // LANG_CXX11</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>不应该使用 using 指示引入整个命名空间的标识符号。比如：using namespace xxx。</p><p>不要在头文件中使用命名空间别名除非显式标记内部命名空间使用。<br>因为任何在头文件中引入的命名空间都会成为公开API的一部分。<br>在 .cc 中使用别名缩短常用的命名空间，比如：namespace baz = ::foo::bar::baz;<br>如果要在 .h 中使用，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在 .h 中使用别名缩短常用的命名空间</span><br><span class="line">namespace librarian &#123;</span><br><span class="line">namespace impl &#123;  // 仅限内部使用</span><br><span class="line">namespace sidetable = ::pipeline_diagnostics::sidetable;</span><br><span class="line">&#125;  // namespace impl</span><br><span class="line"></span><br><span class="line">inline void my_inline_function() &#123;</span><br><span class="line">  // 限制在一个函数中的命名空间别名</span><br><span class="line">  namespace baz = ::foo::bar::baz;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;  // namespace librarian</span><br></pre></td></tr></table></figure><p>注意：所有置于匿名命名空间的声明都具有内部链接性，<br>函数和变量可以经由声明为 static 拥有内部链接性。<br>这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。<br>即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。<br>因此：推荐、鼓励在 .cc 中对于不需要在其他地方引用的标识符使用内部链接性声明，<br>但是不要在 .h 中使用。</p><p>另外举例而言，对于头文件 myproject/foo_bar.h , 应当使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace myproject &#123;</span><br><span class="line">namespace foo_bar &#123;</span><br><span class="line">void Function1();</span><br><span class="line">void Function2();</span><br><span class="line">&#125;  // namespace foo_bar</span><br><span class="line">&#125;  // namespace myproject</span><br></pre></td></tr></table></figure><p>而非</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace myproject &#123;</span><br><span class="line">class FooBar &#123;</span><br><span class="line"> public:</span><br><span class="line">  static void Function1();</span><br><span class="line">  static void Function2();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  // namespace myproject</span><br></pre></td></tr></table></figure><p>注意：禁止定义静态储存周期非POD变量。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>构造函数不得调用虚函数, 考虑使用明确的 Init() 方法或使用工厂模式。</p><p>在类型定义中, 类型转换运算符和单参数构造函数都应当用 explicit 进行标记。<br>例外： 拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换。<br>不能以一个参数进行调用的构造函数不应当加上 explicit。<br>接受一个 std::initializer_list 作为参数的构造函数也应当省略 explicit，<br>以便支持拷贝初始化 (例如 MyType m = {1, 2};) 。</p><p>所有继承必须是 public 的。<br>对于重载的虚函数或虚析构函数, 使用 override,<br>或 (较不常用的) final 关键字显式地进行标记。</p><p>声明顺序：<br>类型 (包括 typedef, using 和嵌套的结构体与类),<br>常量<br>工厂函数<br>构造函数<br>赋值运算符<br>析构函数<br>其它函数<br>数据成员</p><p>接口类类名以 Interface 为后缀, 除提供带实现的虚析构函数。<br>静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员。<br>不提供构造函数, 提供的话, 声明为 protected。</p><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>一些trick：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Vector 接收了一个初始化列表。</span><br><span class="line">vector&lt;string&gt; v&#123;&quot;foo&quot;, &quot;bar&quot;&#125;;</span><br><span class="line"></span><br><span class="line">// 不考虑细节上的微妙差别，大致上相同。</span><br><span class="line">// 您可以任选其一。</span><br><span class="line">vector&lt;string&gt; v = &#123;&quot;foo&quot;, &quot;bar&quot;&#125;;</span><br><span class="line"></span><br><span class="line">// 可以配合 new 一起用。</span><br><span class="line">auto p = new vector&lt;string&gt;&#123;&quot;foo&quot;, &quot;bar&quot;&#125;;</span><br><span class="line"></span><br><span class="line">// map 接收了一些 pair, 列表初始化大显神威。</span><br><span class="line">map&lt;int, string&gt; m = &#123;&#123;1, &quot;one&quot;&#125;, &#123;2, &quot;2&quot;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化列表也可以用在返回类型上的隐式转换。</span><br><span class="line">vector&lt;int&gt; test_function() &#123; return &#123;1, 2, 3&#125;; &#125;</span><br><span class="line"></span><br><span class="line">// 初始化列表可迭代。</span><br><span class="line">for (int i : &#123;-1, -2, -3&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 在函数调用里用列表初始化。</span><br><span class="line">void TestFunction2(vector&lt;int&gt; v) &#123;&#125;</span><br><span class="line">TestFunction2(&#123;1, 2, 3&#125;);</span><br></pre></td></tr></table></figure></p><p>用户自定义 std::initializer_list<t> ：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyType &#123;</span><br><span class="line"> public:</span><br><span class="line">  // std::initializer_list 专门接收 init 列表。</span><br><span class="line">  // 得以值传递。</span><br><span class="line">  MyType(std::initializer_list&lt;int&gt; init_list) &#123;</span><br><span class="line">    for (int i : init_list) append(i);</span><br><span class="line">  &#125;</span><br><span class="line">  MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) &#123;</span><br><span class="line">    clear();</span><br><span class="line">    for (int i : init_list) append(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyType m&#123;2, 3, 5, 7&#125;;</span><br></pre></td></tr></table></figure><p>列表初始化也适用于常规数据类型的构造，<br>哪怕没有接收 std::initializer_list<t> 的构造函数：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double d&#123;1.23&#125;;</span><br><span class="line">// MyOtherType 没有 std::initializer_list 构造函数，</span><br><span class="line"> // 直接上接收常规类型的构造函数。</span><br><span class="line">class MyOtherType &#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit MyOtherType(string);</span><br><span class="line">  MyOtherType(int, string);</span><br><span class="line">&#125;;</span><br><span class="line">MyOtherType m = &#123;1, &quot;b&quot;&#125;;</span><br><span class="line">// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。</span><br><span class="line">MyOtherType m&#123;&quot;b&quot;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Google-C-Style-Guide&quot;&gt;&lt;a href=&quot;#Google-C-Style-Guide&quot; class=&quot;headerlink&quot; title=&quot;Google C++ Style Guide&quot;&gt;&lt;/a&gt;Google C++ Style Guide&lt;/h2&gt;&lt;p&gt;刚进公司的时候看过一遍、现在需要重新再学习一下、顺便写点笔记。&lt;br&gt;（如果记得没错的话这份文档的名字改过了、以前叫coding style、现在叫style guide了）。&lt;br&gt;对于一些平时一直习惯使用的（比如#define保护）以及一些不推荐使用但是基本不会用到的（比如前置声明）就不再赘述了。&lt;br&gt;下面附上链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://google.github.io/styleguide/cppguide.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;英文版链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文版链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Google" scheme="http://tashi711.xyz/tags/Google/"/>
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>日语中「条件表达方式」小结</title>
    <link href="http://tashi711.xyz/nihongo/benkyou/condition/"/>
    <id>http://tashi711.xyz/nihongo/benkyou/condition/</id>
    <published>2018-05-05T11:23:28.000Z</published>
    <updated>2018-05-05T11:54:57.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><h3 id="“～たら”和“～ば”"><a href="#“～たら”和“～ば”" class="headerlink" title="“～たら”和“～ば”"></a>“～たら”和“～ば”</h3><p>1、表示“如果”、“要是”，其中用“～ば”时后面的小句不能是意志、请求的形式（“～たいです”、“～てください”）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">雨が降ったら、窓を閉めてください。（“～降れば”不行）</span><br></pre></td></tr></table></figure><p>2、后面的小句是过去时，表示发现某种情况，不能用“～ば”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窓を開けたら、富士山が見えました。（“～開ければ”不行）</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="“～と”"><a href="#“～と”" class="headerlink" title="“～と”"></a>“～と”</h3><p>1、用于前项一旦成立，后项就必然成为现实。此时用“～たら”也不算错，但不够自然。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">スイッチを押すと／押したら、電気がつきます。</span><br></pre></td></tr></table></figure><p>2、后面的小句不能是意志、请求的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">スイッチを押したら、すぐ部屋を出てください。（“～押すと”不行）</span><br></pre></td></tr></table></figure><p>3、后面的小句是过去时，表示发现某种情况，与“～たら”相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窓を開けると、富士山が見えました。</span><br></pre></td></tr></table></figure><h3 id="“～なら”"><a href="#“～なら”" class="headerlink" title="“～なら”"></a>“～なら”</h3><p>1、多用于以对方的某种意愿为前提而提出某种建议，这种用法“～たら”“～ば”“～と”都不具备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新鮮な魚を買いたいんですが…。</span><br><span class="line">—— 魚を買うなら、駅前のズーパーがいいですよ。</span><br></pre></td></tr></table></figure><p>2、前项不是对方的意志或愿望，而是其某种兴趣或嗜好时，与“～たら”可以通用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">野菜が嫌いなら／嫌いだったら、食べなくでもいいですよ。</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>新标日第二版第37课语法部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;归纳总结&quot;&gt;&lt;a href=&quot;#归纳总结&quot; class=&quot;headerlink&quot; title=&quot;归纳总结&quot;&gt;&lt;/a&gt;归纳总结&lt;/h2&gt;&lt;h3 id=&quot;“～たら”和“～ば”&quot;&gt;&lt;a href=&quot;#“～たら”和“～ば”&quot; class=&quot;headerlink&quot; title=&quot;“～たら”和“～ば”&quot;&gt;&lt;/a&gt;“～たら”和“～ば”&lt;/h3&gt;&lt;p&gt;1、表示“如果”、“要是”，其中用“～ば”时后面的小句不能是意志、请求的形式（“～たいです”、“～てください”）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;雨が降ったら、窓を閉めてください。（“～降れば”不行）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2、后面的小句是过去时，表示发现某种情况，不能用“～ば”。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;窓を開けたら、富士山が見えました。（“～開ければ”不行）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ベンキョウ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%83%99%E3%83%B3%E3%82%AD%E3%83%A7%E3%82%A6/"/>
    
    
      <category term="コンディション" scheme="http://tashi711.xyz/tags/%E3%82%B3%E3%83%B3%E3%83%87%E3%82%A3%E3%82%B7%E3%83%A7%E3%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 827. Making A Large Island」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-827/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-827/</id>
    <published>2018-05-02T11:34:17.000Z</published>
    <updated>2018-05-02T11:53:03.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/making-a-large-island/description/" target="_blank" rel="noopener">LeetCode 827. Making A Large Island</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定N×N的0-1方图（1≤N≤50），求问最多改变其中一个0到1之后最大的1的4-连通分量。<br>比如样例[[1, 0], [0, 1]]，结果为3。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较简单点的一道题目，先种子填充求出所有4-连通分量，记录下来（注意不同的连通分量间打上不同的tag）。<br>枚举每个0点，将其上下左右的<strong>不同</strong>连通分量的size加起来再加1的最大值输出即可。</p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>只需注意边界条件，以及没有0点时能够输出整个方图的size即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N^2)$，因为种子填充最多将整张图遍历完。<br>空间复杂度为 $O(N^2)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> vst[N][N];</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">n = (<span class="keyword">int</span>)grid.size();</span><br><span class="line">m = (<span class="keyword">int</span>)grid[<span class="number">0</span>].size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">a[i + <span class="number">1</span>][j + <span class="number">1</span>] = grid[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line">node(<span class="keyword">int</span> _u = <span class="number">0</span>, <span class="keyword">int</span> _v = <span class="number">0</span>) : u(_u), v(_v) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">within_and_not_vst_then_emplace</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="built_in">vector</span>&lt;node&gt;&amp; adj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u &gt;= <span class="number">1</span> &amp;&amp; u &lt;= n &amp;&amp; v &gt;= <span class="number">1</span> &amp;&amp; v &lt;= m &amp;&amp; !vst[u][v] &amp;&amp; a[u][v] == <span class="number">1</span>) &#123;</span><br><span class="line">adj.emplace_back(u, v);</span><br><span class="line">vst[u][v] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floodfill</span><span class="params">(<span class="keyword">int</span> su, <span class="keyword">int</span> sv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; q;</span><br><span class="line">q.emplace_back(su, sv);</span><br><span class="line">vst[su][sv] = cur;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)q.size(); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q[i].u, v = q[i].v;</span><br><span class="line">within_and_not_vst_then_emplace(u + <span class="number">1</span>, v, q);</span><br><span class="line">within_and_not_vst_then_emplace(u - <span class="number">1</span>, v, q);</span><br><span class="line">within_and_not_vst_then_emplace(u, v + <span class="number">1</span>, q);</span><br><span class="line">within_and_not_vst_then_emplace(u, v - <span class="number">1</span>, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)q.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">within_and_insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u &gt;= <span class="number">1</span> &amp;&amp; u &lt;= n &amp;&amp; v &gt;= <span class="number">1</span> &amp;&amp; v &lt;= m) &#123;</span><br><span class="line">s.insert(vst[u][v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vst, <span class="number">0</span>, <span class="keyword">sizeof</span> vst);</span><br><span class="line">cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">cnt.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vst[i][j] &amp;&amp; a[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">++cur;</span><br><span class="line"><span class="keyword">int</span> res = floodfill(i, j);</span><br><span class="line">ans = max(ans, res);</span><br><span class="line">cnt.push_back(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">within_and_insert(i + <span class="number">1</span>, j, s);</span><br><span class="line">within_and_insert(i - <span class="number">1</span>, j, s);</span><br><span class="line">within_and_insert(i, j + <span class="number">1</span>, s);</span><br><span class="line">within_and_insert(i, j - <span class="number">1</span>, s);</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : s) &#123;</span><br><span class="line">t += cnt[k];</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>确实特别简单的一道题，最暴力的方法枚举所有0点的时候单独做种子填充。<br>也仅仅是4次方的复杂度，对这道题的规模来说不会超时。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/making-a-large-island/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 827. Making A Large Island&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定N×N的0-1方图（1≤N≤50），求问最多改变其中一个0到1之后最大的1的4-连通分量。&lt;br&gt;比如样例[[1, 0], [0, 1]]，结果为3。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="种子填充算法" scheme="http://tashi711.xyz/tags/%E7%A7%8D%E5%AD%90%E5%A1%AB%E5%85%85%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 818. Race Car」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-818/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-818/</id>
    <published>2018-04-28T06:54:25.000Z</published>
    <updated>2018-04-28T07:45:18.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/race-car/description/" target="_blank" rel="noopener">LeetCode 818. Race Car</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>一开始车在无限长的的直线的坐标0处，速度为+1，有两种指令A（加速）和R（反向）。<br>当接收指令A时，位置加上速度的值，然后速度乘2，当接收指令R时，速度反向且绝对值变为1，位置不变。<br>现在给定终点位置，求问到达这个位置的最少指令数。<br>比如样例输入3，输出2（AA: 0-&gt;1-&gt;3）；输入6，输出5（AAARA: 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6）</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较难的一道题目，想了几天无果看了官方给的题解，还是很巧妙的。<br>用$A^k$表示$k$次连续的$A$，首先结尾一定不是$R$，开头的$RA^k$可以放到最后。<br>那么最终指令应该形如$A^{k_1}RA^{k_2}R…RA^{k_n}$。<br>容易得到奇数的$k_i$与偶数的$k_i$都是单调递减的，且各不相同。<br>并且到达或者超过目标位置之后继续执行$A$是没有意义的。<br>因此就有了DP的做法，如果下标位置是$2^k-1$，那么可以直接$A^k$达到。<br>否则有两种情况，一是拐两次到达，正面一定有一次最大限度的$2^k-1$，外加返回走$j$步（枚举$j$）。<br>二是直接走刚好超过$2^k-1$，回走到终点。</p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>边界条件f[0] = 0。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(NlogN)$。<br>空间复杂度为 $O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">11000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">racecar</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x7F</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> k = max_k(i);</span><br><span class="line"><span class="keyword">if</span> (i == (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>) &#123;</span><br><span class="line">f[i] = k;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">f[i] = min(f[i], f[i - (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>)) + (<span class="number">1</span> &lt;&lt; j)] + k + j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> - i &lt; i) &#123;</span><br><span class="line">f[i] = min(f[i], f[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> - i] + k + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_k</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">++res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>看起来是个N方的复杂度，但其实步长是指数级的。<br>因此在距离范围内枚举步长的量级只是对数级，可以用DP解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/race-car/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 818. Race Car&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;一开始车在无限长的的直线的坐标0处，速度为+1，有两种指令A（加速）和R（反向）。&lt;br&gt;当接收指令A时，位置加上速度的值，然后速度乘2，当接收指令R时，速度反向且绝对值变为1，位置不变。&lt;br&gt;现在给定终点位置，求问到达这个位置的最少指令数。&lt;br&gt;比如样例输入3，输出2（AA: 0-&amp;gt;1-&amp;gt;3）；输入6，输出5（AAARA: 0-&amp;gt;1-&amp;gt;3-&amp;gt;7-&amp;gt;7-&amp;gt;6）&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
