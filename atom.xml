<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tashi711的博客</title>
  
  <subtitle>過去（きのう）に傷付きながらも、信じ続ける理想（ゆめ）を求める。いつか無限（なないろ）に輝き放って、青空（そら）に橋を描く。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tashi711.top/"/>
  <updated>2019-03-29T13:56:14.113Z</updated>
  <id>http://tashi711.top/</id>
  
  <author>
    <name>Tashi711</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「POJ 3468 - A Simple Problem with Integers」解题报告</title>
    <link href="http://tashi711.top/programming/reports/others/poj-3468/"/>
    <id>http://tashi711.top/programming/reports/others/poj-3468/</id>
    <published>2019-03-28T16:11:04.000Z</published>
    <updated>2019-03-29T13:56:14.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener">POJ 3468 - A Simple Problem with Integers</a></li><li>来源：POJ Monthly–2007.11.25, Yang Yi</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>N个整数（-1000000000 ≤ Ai ≤ 1000000000），Q次询问（1 ≤ N,Q ≤ 100000）。<br>每次询问要么是”C a b c”，表示区间[a, b]的每个数加c. -10000 ≤ c ≤ 10000。<br>要么是”Q a b”，表示询问区间[a, b]的和。</p><a id="more"></a><p><strong>输入样例：</strong><br>10 5<br>1 2 3 4 5 6 7 8 9 10<br>Q 4 4<br>Q 1 10<br>Q 2 4<br>C 3 6 3<br>Q 2 4</p><p><strong>输出样例：</strong><br>4<br>55<br>9<br>15</p><p><strong>时间限制：</strong><br>5s</p><p><strong>空间限制：</strong><br>128M</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>裸的线段树题，详见线段树浅析的那篇文章</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度均为$O((Q+N)\log N)$。<br>空间复杂度均为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  Node() : l(<span class="number">-1</span>), r(<span class="number">-1</span>), len(<span class="number">-1</span>), mid(<span class="number">-1</span>), pl(<span class="number">-1</span>), pr(<span class="number">-1</span>), add(<span class="number">0</span>), sum(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">int</span> l;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">int</span> pl;</span><br><span class="line">  <span class="keyword">int</span> pr;</span><br><span class="line">  T add;</span><br><span class="line">  T sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  SegmentTree(<span class="keyword">int</span> n) : n_(n), tree_(n * <span class="number">4</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    Build(<span class="number">1</span>, n_, vec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, T add, <span class="keyword">int</span> p = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= tree_[p].l &amp;&amp; v &gt;= tree_[p].r) &#123;</span><br><span class="line">      tree_[p].add += add;</span><br><span class="line">      tree_[p].sum += add * tree_[p].len;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(p);</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= tree_[p].mid) &#123;</span><br><span class="line">      Update(u, v, add, tree_[p].pl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; tree_[p].mid) &#123;</span><br><span class="line">      Update(u, v, add, tree_[p].pr);</span><br><span class="line">    &#125;</span><br><span class="line">    PushUp(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> p = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= tree_[p].l &amp;&amp; v &gt;= tree_[p].r) &#123;</span><br><span class="line">      <span class="keyword">return</span> tree_[p].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    T res = <span class="number">0</span>;</span><br><span class="line">    PushDown(p);</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= tree_[p].mid) &#123;</span><br><span class="line">      res += Query(u, v, tree_[p].pl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; tree_[p].mid) &#123;</span><br><span class="line">      res += Query(u, v, tree_[p].pr);</span><br><span class="line">    &#125;</span><br><span class="line">    PushUp(p);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    tree_[p].sum = tree_[tree_[p].pl].sum + tree_[tree_[p].pr].sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree_[p].add) &#123;</span><br><span class="line">      tree_[tree_[p].pl].add += tree_[p].add;</span><br><span class="line">      tree_[tree_[p].pr].add += tree_[p].add;</span><br><span class="line">      tree_[tree_[p].pl].sum += tree_[p].add * tree_[tree_[p].pl].len;</span><br><span class="line">      tree_[tree_[p].pr].sum += tree_[p].add * tree_[tree_[p].pr].len;</span><br><span class="line">      tree_[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;T&gt;&amp; vec, <span class="keyword">int</span> p = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    tree_[p].l = l;</span><br><span class="line">    tree_[p].r = r;</span><br><span class="line">    tree_[p].len = r - l + <span class="number">1</span>;</span><br><span class="line">    tree_[p].mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      tree_[p].sum = vec[l - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree_[p].pl = p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    tree_[p].pr = p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    Build(l, tree_[p].mid, vec, tree_[p].pl);</span><br><span class="line">    Build(tree_[p].mid + <span class="number">1</span>, r, vec, tree_[p].pr);</span><br><span class="line">    PushUp(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&lt;T&gt;&gt; tree_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, q;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; vec(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;vec[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  SegmentTree&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; st(n);</span><br><span class="line">  st.Init(vec);</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> add;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u, v, i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;add);</span><br><span class="line">      st.Update(u, v, add);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, st.Query(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;http://poj.org/problem?id=3468&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 3468 - A Simple Problem with Integers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：POJ Monthly–2007.11.25, Yang Yi&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;N个整数（-1000000000 ≤ Ai ≤ 1000000000），Q次询问（1 ≤ N,Q ≤ 100000）。&lt;br&gt;每次询问要么是”C a b c”，表示区间[a, b]的每个数加c. -10000 ≤ c ≤ 10000。&lt;br&gt;要么是”Q a b”，表示询问区间[a, b]的和。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="其他" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="线段树" scheme="http://tashi711.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「线段树」浅析</title>
    <link href="http://tashi711.top/programming/dsaa/segment-tree/"/>
    <id>http://tashi711.top/programming/dsaa/segment-tree/</id>
    <published>2019-03-28T03:15:34.000Z</published>
    <updated>2019-03-29T13:48:37.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>之前写过两篇关于树状数组的文章，提到了树状数组在区间操作上的不足，这篇文章以区间更新与求和为切入点简单介绍线段树。</p><h3 id="规定与细节"><a href="#规定与细节" class="headerlink" title="规定与细节"></a>规定与细节</h3><p>线段树的实现有很多种方式，为了统一细节，这里都遵守以下规则（这也是目前线段树比较大众化的写法）：</p><p>1、用连续一段数组存放结点，其中下标为1的结点为根结点，左右儿子结点（如果有）的下标分别为当前结点下标的2倍和2倍+1，下标范围不会超过4倍总线段长度（当然另一种做法是每次需要往下build的时候new一个新结点，这样会充分利用空间，但是不断地申请空间会比较慢）；</p><p>2、每段线段表示左闭右闭的区间，比如[1, 10]分成[1, 5]与[6, 10]，而不是等价用[1, 11)分成[1, 6)与[6, 11)；</p><p>3、分线段不均匀时优先将中间节点分到左边，比如[1, 3]分成[1, 2]与[3, 3]，而不是[1, 1]与[2, 3]；</p><p>4、区间操作的输入区间不改变（有一种现实是每次下放都将输入截断为不超过当前结点区间的范围）。</p><a id="more"></a><h2 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h2><p>线段树的精髓就在于懒标记了，考虑在某段区间加上一个数，要是每次都下放到每个单独结点，时间会非常慢，如果判断出对当前结点的区间做的操作统一时，可以将下放停在这个地方，表示下面的区间都要做同样的操作，当后面的操作不是作用于整个当前区间时，再把前面累积的操作一起下放。当然不光是求和，基本所有区间操作都可以用到这个trick。</p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  Node() : l(<span class="number">-1</span>), r(<span class="number">-1</span>), len(<span class="number">-1</span>), mid(<span class="number">-1</span>), pl(<span class="number">-1</span>), pr(<span class="number">-1</span>), add(<span class="number">0</span>), sum(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">int</span> l;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  <span class="keyword">int</span> pl;</span><br><span class="line">  <span class="keyword">int</span> pr;</span><br><span class="line">  T add;</span><br><span class="line">  T sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  SegmentTree(<span class="keyword">int</span> n) : n_(n), tree_(n * <span class="number">4</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;T&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    Build(<span class="number">1</span>, n_, vec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, T add, <span class="keyword">int</span> p = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= tree_[p].l &amp;&amp; v &gt;= tree_[p].r) &#123;</span><br><span class="line">      tree_[p].add += add;</span><br><span class="line">      tree_[p].sum += add * tree_[p].len;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(p);</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= tree_[p].mid) &#123;</span><br><span class="line">      Update(u, v, add, tree_[p].pl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; tree_[p].mid) &#123;</span><br><span class="line">      Update(u, v, add, tree_[p].pr);</span><br><span class="line">    &#125;</span><br><span class="line">    PushUp(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> p = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= tree_[p].l &amp;&amp; v &gt;= tree_[p].r) &#123;</span><br><span class="line">      <span class="keyword">return</span> tree_[p].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    T res = <span class="number">0</span>;</span><br><span class="line">    PushDown(p);</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= tree_[p].mid) &#123;</span><br><span class="line">      res += Query(u, v, tree_[p].pl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; tree_[p].mid) &#123;</span><br><span class="line">      res += Query(u, v, tree_[p].pr);</span><br><span class="line">    &#125;</span><br><span class="line">    PushUp(p);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    tree_[p].sum = tree_[tree_[p].pl].sum + tree_[tree_[p].pr].sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree_[p].add) &#123;</span><br><span class="line">      tree_[tree_[p].pl].add += tree_[p].add;</span><br><span class="line">      tree_[tree_[p].pr].add += tree_[p].add;</span><br><span class="line">      tree_[tree_[p].pl].sum += tree_[p].add * tree_[tree_[p].pl].len;</span><br><span class="line">      tree_[tree_[p].pr].sum += tree_[p].add * tree_[tree_[p].pr].len;</span><br><span class="line">      tree_[p].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;T&gt;&amp; vec, <span class="keyword">int</span> p = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    tree_[p].l = l;</span><br><span class="line">    tree_[p].r = r;</span><br><span class="line">    tree_[p].len = r - l + <span class="number">1</span>;</span><br><span class="line">    tree_[p].mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      tree_[p].sum = vec[l - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree_[p].pl = p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    tree_[p].pr = p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    Build(l, tree_[p].mid, vec, tree_[p].pl);</span><br><span class="line">    Build(tree_[p].mid + <span class="number">1</span>, r, vec, tree_[p].pr);</span><br><span class="line">    PushUp(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&lt;T&gt;&gt; tree_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析与拓展"><a href="#复杂度分析与拓展" class="headerlink" title="复杂度分析与拓展"></a>复杂度分析与拓展</h2><p>在使用懒标记的情况下（上面程序的add），区间的更新与询问操作都是总长度的log级。</p><p>对于线段树，有许多种拓展方式，各种区间操作都可以巧妙地通过修改Update与Query函数来实现（例如区间都设为某个数，或者设为某个数与加上某个数两种操作交叉进行）。维度上，在二维树状数组那篇文章中也提到，线段树可以扩展到2维（四分树或者矩形树）甚至n维，且单次操作复杂度不发生改变（而树状数组随着维度的增加是会变为对数的多项式倍）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题提出&quot;&gt;&lt;a href=&quot;#问题提出&quot; class=&quot;headerlink&quot; title=&quot;问题提出&quot;&gt;&lt;/a&gt;问题提出&lt;/h2&gt;&lt;p&gt;之前写过两篇关于树状数组的文章，提到了树状数组在区间操作上的不足，这篇文章以区间更新与求和为切入点简单介绍线段树。&lt;/p&gt;
&lt;h3 id=&quot;规定与细节&quot;&gt;&lt;a href=&quot;#规定与细节&quot; class=&quot;headerlink&quot; title=&quot;规定与细节&quot;&gt;&lt;/a&gt;规定与细节&lt;/h3&gt;&lt;p&gt;线段树的实现有很多种方式，为了统一细节，这里都遵守以下规则（这也是目前线段树比较大众化的写法）：&lt;/p&gt;
&lt;p&gt;1、用连续一段数组存放结点，其中下标为1的结点为根结点，左右儿子结点（如果有）的下标分别为当前结点下标的2倍和2倍+1，下标范围不会超过4倍总线段长度（当然另一种做法是每次需要往下build的时候new一个新结点，这样会充分利用空间，但是不断地申请空间会比较慢）；&lt;/p&gt;
&lt;p&gt;2、每段线段表示左闭右闭的区间，比如[1, 10]分成[1, 5]与[6, 10]，而不是等价用[1, 11)分成[1, 6)与[6, 11)；&lt;/p&gt;
&lt;p&gt;3、分线段不均匀时优先将中间节点分到左边，比如[1, 3]分成[1, 2]与[3, 3]，而不是[1, 1]与[2, 3]；&lt;/p&gt;
&lt;p&gt;4、区间操作的输入区间不改变（有一种现实是每次下放都将输入截断为不超过当前结点区间的范围）。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="线段树" scheme="http://tashi711.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 591. Tag Validator」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-591/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-591/</id>
    <published>2019-03-21T03:57:03.000Z</published>
    <updated>2019-03-21T15:16:05.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/tag-validator/" target="_blank" rel="noopener">LeetCode 591. Tag Validator</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：<br>代码必须被合法的闭合标签包围。否则，代码是无效的。<br>闭合标签（不一定合法）要严格符合格式：&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;。其中，&lt;TAG_NAME&gt;是起始标签，&lt;/TAG_NAME&gt;是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是合法的。<br>合法的 TAG_NAME 仅含有大写字母，长度在范围 [1,9] 之间。否则，该 TAG_NAME 是不合法的。<br>合法的 TAG_CONTENT 可以包含其他合法的闭合标签，cdata （请参考规则7）和任意字符（注意参考规则1）除了不匹配的&lt;、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，TAG_CONTENT 是不合法的。<br>一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。<br>一个&lt;，如果你找不到一个后续的&gt;与之匹配，是不合法的。并且当你找到一个&lt;或&lt;/时，所有直到下一个&gt;的前的字符，都应当被解析为 TAG_NAME（不一定合法）。<br>cdata 有如下格式：&lt;![CDATA[CDATA_CONTENT]]&gt;。CDATA_CONTENT 的范围被定义成 &lt;![CDATA[ 和后续的第一个 ]]&gt;之间的字符。<br>CDATA_CONTENT 可以包含任意字符。cdata 的功能是阻止验证器解析CDATA_CONTENT，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为常规字符。</p><p><strong>合法代码的例子:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">代码被包含在了闭合的标签内： &lt;DIV&gt; 和 &lt;/DIV&gt; 。</span><br><span class="line">TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 </span><br><span class="line">即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。</span><br><span class="line">所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">我们首先将代码分割为： start_tag|tag_content|end_tag 。</span><br><span class="line">start_tag -&gt; &quot;&lt;DIV&gt;&quot;</span><br><span class="line">end_tag -&gt; &quot;&lt;/DIV&gt;&quot;</span><br><span class="line">tag_content 也可被分割为： text1|cdata|text2 。</span><br><span class="line">text1 -&gt; &quot;&gt;&gt;  ![cdata[]] &quot;</span><br><span class="line">cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot; ，其中 CDATA_CONTENT 为 &quot;&lt;div&gt;]&gt;&quot;</span><br><span class="line">text2 -&gt; &quot;]]&gt;&gt;]&quot;</span><br><span class="line">start_tag 不是 &quot;&lt;DIV&gt;&gt;&gt;&quot; 的原因参照规则 6 。</span><br><span class="line">cdata 不是 &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; 的原因参照规则 7 。</span><br></pre></td></tr></table></figure><p><strong>不合法代码的例子:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line">解释: 不合法。如果 &quot;&lt;A&gt;&quot; 是闭合的，那么 &quot;&lt;B&gt;&quot; 一定是不匹配的，反之亦然。</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;/DIV&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>为简明起见，你可以假设输入的代码（包括提到的任意字符）只包含数字, 字母, ‘&lt;’,’&gt;’,’/‘,’!’,’[‘,’]’和’ ‘。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>纯模拟题，注意细节即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> code)</span> </span>&#123;</span><br><span class="line">    code_ = code;</span><br><span class="line">    n_ = code.size();</span><br><span class="line">    <span class="keyword">int</span> p = FindValidClosedTag(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> p == n_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">FindValidClosedTag</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (code_[p++] != <span class="string">'&lt;'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> start_tag;</span><br><span class="line">    <span class="keyword">if</span> ((p = FindValidTagName(p, &amp;start_tag)) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((p = FindValidTagContent(p)) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> end_tag;</span><br><span class="line">    <span class="keyword">if</span> ((p = FindValidTagName(p, &amp;end_tag)) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start_tag != end_tag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">FindValidTagName</span><span class="params">(<span class="keyword">int</span> p, <span class="built_in">string</span>* tag_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &lt; n_; ++p) &#123;</span><br><span class="line">      <span class="keyword">if</span> (code_[p] == <span class="string">'&gt;'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isupper</span>(code_[p]) &amp;&amp; ++len &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">        *tag_name += code_[p];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">FindValidTagContent</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; p &lt; n_; ++p) &#123;</span><br><span class="line">      <span class="keyword">if</span> (code_[p] == <span class="string">'&lt;'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p + <span class="number">1</span> &lt; n_ &amp;&amp; code_[p + <span class="number">1</span>] == <span class="string">'/'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> p + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p + <span class="number">1</span> &lt; n_ &amp;&amp; code_[p + <span class="number">1</span>] == <span class="string">'!'</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((p = FindCdata(p + <span class="number">2</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          --p;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p + <span class="number">1</span> &lt; n_ &amp;&amp; <span class="built_in">isupper</span>(code_[p + <span class="number">1</span>])) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((p = FindValidClosedTag(p)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          --p;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">FindCdata</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(p &lt; n_ &amp;&amp; code_[p++] == <span class="string">'['</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(p &lt; n_ &amp;&amp; code_[p++] == <span class="string">'C'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(p &lt; n_ &amp;&amp; code_[p++] == <span class="string">'D'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(p &lt; n_ &amp;&amp; code_[p++] == <span class="string">'A'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(p &lt; n_ &amp;&amp; code_[p++] == <span class="string">'T'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(p &lt; n_ &amp;&amp; code_[p++] == <span class="string">'A'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(p &lt; n_ &amp;&amp; code_[p++] == <span class="string">'['</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((p = FindCdataContent(p)) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">FindCdataContent</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (p += <span class="number">2</span>; p &lt; n_; ++p) &#123;</span><br><span class="line">      <span class="keyword">if</span> (code_[p] == <span class="string">'&gt;'</span> &amp;&amp; code_[p - <span class="number">1</span>] == <span class="string">']'</span> &amp;&amp; code_[p - <span class="number">2</span>] == <span class="string">']'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> code_;</span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">bool</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  PrintAns(solution-&gt;isValid(</span><br><span class="line">    <span class="string">"&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;"</span>));</span><br><span class="line">  PrintAns(solution-&gt;isValid(</span><br><span class="line">    <span class="string">"&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;"</span>));</span><br><span class="line">  PrintAns(solution-&gt;isValid(<span class="string">"&lt;A&gt;  &lt;B&gt; &lt; / A&gt;   &lt; / B&gt;"</span>));</span><br><span class="line">  PrintAns(solution-&gt;isValid(<span class="string">"&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;"</span>));</span><br><span class="line">  PrintAns(solution-&gt;isValid(<span class="string">"&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;"</span>));</span><br><span class="line">  PrintAns(solution-&gt;isValid(</span><br><span class="line">    <span class="string">"&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;"</span>));</span><br><span class="line">  PrintAns(solution-&gt;isValid(</span><br><span class="line">    <span class="string">"&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt; "</span></span><br><span class="line">    <span class="string">" &lt;/DIV&gt;"</span>));</span><br><span class="line">  PrintAns(solution-&gt;isValid(</span><br><span class="line">    <span class="string">"&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;"</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/tag-validator/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 591. Tag Validator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="模拟" scheme="http://tashi711.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>「二维树状数组」浅析</title>
    <link href="http://tashi711.top/programming/dsaa/2d-bit/"/>
    <id>http://tashi711.top/programming/dsaa/2d-bit/</id>
    <published>2019-03-19T03:15:34.000Z</published>
    <updated>2019-03-19T15:00:43.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>之前写过一篇“「树状数组」浅析”，详述了一维树状数组，本文主要推广到二维树状数组，也可以类推到更高维。同样用一个问题引出，已知二维数组a[][]，元素个数为n*m，现在要求a数组中某个矩形区域的和。</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><a id="more"></a><p>与一维情况一样，我们完全可以存储sum(x, y)表示从左下角到(x, y)的矩形区域的和（注意这里表达的意思与另一篇文章的区别），然后对任意给定的查找区间[x1 ~ x2, y1 ~ y2]，返回sum(x2, y2) - sum(x1 - 1, y2) - sum(x2, y1 - 1) + sum(x1 - 1, y1 - 1)。同样的问题，这只是没有元素改变的情况下的比较优化的解法，那么对于对于数组中的元素随时变更的情况下是否也有像一维树状数组一样优秀的算法呢。</p><h2 id="二维树状数组的思想"><a href="#二维树状数组的思想" class="headerlink" title="二维树状数组的思想"></a>二维树状数组的思想</h2><p>回想一维树状数组，当前index上的值管理了它本身往前到index去掉lowbit后位置的后面一个位置间的数的和，而二维树状数组tree[i][j]其实管理的是x从i-lowbit(i)+1到i，y从j-lowbit(j)+1到j间的数的和，因此二维树状数组的算法也呼之欲出，用两层循环分别遍历i和j的lowbit即可。</p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoDimensionalBIT</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TwoDimensionalBIT(<span class="keyword">int</span> len_x, <span class="keyword">int</span> len_y, <span class="keyword">int</span> x0 = <span class="number">1</span>, <span class="keyword">int</span> y0 = <span class="number">1</span>)</span><br><span class="line">    : len_x_(len_x), len_y_(len_y), x0_(x0), y0_(y0),</span><br><span class="line">    tree(len_x + <span class="number">1</span>, <span class="built_in">vector</span>&lt;T&gt;(len_y + <span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> px = x - x0_ + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (px &lt;= len_x_) &#123;</span><br><span class="line">      <span class="keyword">int</span> py = y - y0_ + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (py &lt;= len_y_) &#123;</span><br><span class="line">        tree[px][py] += k;</span><br><span class="line">        py += Lowbit(py);</span><br><span class="line">      &#125;</span><br><span class="line">      px += Lowbit(px);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">GetRange</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GetSum(x2, y2) - GetSum(x1 - <span class="number">1</span>, y2) - GetSum(x2, y1 - <span class="number">1</span>) +</span><br><span class="line">      GetSum(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p &amp; -p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    T sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> px = x - x0_ + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (px) &#123;</span><br><span class="line">      <span class="keyword">int</span> py = y - y0_ + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (py) &#123;</span><br><span class="line">        sum += tree[px][py];</span><br><span class="line">        py ^= Lowbit(py);</span><br><span class="line">      &#125;</span><br><span class="line">      px ^= Lowbit(px);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> len_x_ = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> len_y_ = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> x0_ = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> y0_ = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;T&gt;&gt; tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>这段代码相比于一维的那个版本更加推广了几点：1、用模板可以实现各类别的和；2、可选择起点，一般树状数组都是1到n这样规定下标的，毕竟要满足lowbit的约束，有时候会遇到实际是0开始的下标甚至有负下标，可以直接在上面的代码中放进构造函数，内部会在计算时把实际坐标先对应到以1开头。</p><h2 id="复杂度分析与拓展"><a href="#复杂度分析与拓展" class="headerlink" title="复杂度分析与拓展"></a>复杂度分析与拓展</h2><p>这里看到两层循环，每层都遍历了一遍lowbit，因此复杂度为$O(\log n*\log m)$（对于单次更新和求和操作都是）。要注意的是很多处理高维的对数级复杂度的数据结构的复杂度中的对数是取在整体size上的（比如二维线段树的单次操作复杂度是$O(\log (nm))=O(\log n+\log m)$）。</p><p>按照一维到二维的推广思路，树状数组也很容易推广到更高维度，单次复杂度为每个维度对数的乘积，以线段树为比较，高维线段树单次复杂度为每个维度对数的和（高维情况下，线段树不再表现为线段，例如一般把二维线段树叫做矩形树或者四分树，这里姑且先这么叫），因此除了一维的情况，线段树都比树状数组复杂度低，并且线段树功能上更为强大，树状数组只能动态更新单点，线段树可以动态更新线段（或者高维中的矩形、长方体等），此外树状数组只能用于求前缀和，线段树可以解决非常多种类的区间操作问题。当然了，树状数组也有其优势，一是代码简单，二是常数小，在一般的size下，log级别其实也就是常数级别，线段树通常要承担比树状数组大的常数开销，因此最后的表现可能差不多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题提出&quot;&gt;&lt;a href=&quot;#问题提出&quot; class=&quot;headerlink&quot; title=&quot;问题提出&quot;&gt;&lt;/a&gt;问题提出&lt;/h2&gt;&lt;p&gt;之前写过一篇“「树状数组」浅析”，详述了一维树状数组，本文主要推广到二维树状数组，也可以类推到更高维。同样用一个问题引出，已知二维数组a[][]，元素个数为n*m，现在要求a数组中某个矩形区域的和。&lt;/p&gt;
&lt;h3 id=&quot;前缀和&quot;&gt;&lt;a href=&quot;#前缀和&quot; class=&quot;headerlink&quot; title=&quot;前缀和&quot;&gt;&lt;/a&gt;前缀和&lt;/h3&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树状数组" scheme="http://tashi711.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 587. Erect the Fence」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-587/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-587/</id>
    <published>2019-03-05T03:57:03.000Z</published>
    <updated>2019-03-05T13:57:29.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/erect-the-fence/" target="_blank" rel="noopener">LeetCode 587. Erect the Fence</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。</p><p><strong>示例 1:</strong><br>输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]<br>输出: [[1,1],[2,0],[4,2],[3,3],[2,4]]</p><p><strong>示例 2:</strong><br>输入: [[1,2],[2,2],[4,2]]<br>输出: [[1,2],[2,2],[4,2]]<br>即使树都在一条直线上，你也需要先用绳子包围它们。</p><p><strong>注意:</strong><br>所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。<br>输入的整数在 0 到 100 之间。<br>花园至少有一棵树。<br>所有树的坐标都是不同的。<br>输入的点没有顺序。输出顺序也没有要求。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实就是个裸凸包题，可以参考我最近刚写的平面凸包详解的文章，对应稳重提到的第二种特殊情形。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N \log N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  Point() : x(<span class="number">0</span>), y(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : x(a), y(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvexHull</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GrahamScan</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point&gt;&amp; points, <span class="built_in">vector</span>&lt;Point&gt;* res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (points.size() == <span class="number">1u</span>) &#123;</span><br><span class="line">      res-&gt;push_back(points[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; temp(points);</span><br><span class="line">    <span class="keyword">auto</span> p_min = min_element(temp.begin(), temp.end(),</span><br><span class="line">      [](<span class="keyword">const</span> Point&amp; u, <span class="keyword">const</span> Point&amp; v) &#123;</span><br><span class="line">      <span class="keyword">return</span> make_pair(u.y, u.x) &lt; make_pair(v.y, v.x);</span><br><span class="line">    &#125;);</span><br><span class="line">    swap(*p_min, temp[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">auto</span> dist = [](<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line">      <span class="keyword">int</span> dx = b.x - a.x;</span><br><span class="line">      <span class="keyword">int</span> dy = b.y - a.y;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">abs</span>(dx) + <span class="built_in">abs</span>(dy);</span><br><span class="line">    &#125;;</span><br><span class="line">    sort(next(temp.begin()), temp.end(),</span><br><span class="line">      [&amp;temp, &amp;dist](<span class="keyword">const</span> Point&amp; u, <span class="keyword">const</span> Point&amp; v) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">      <span class="keyword">double</span> theta_u = <span class="built_in">atan2</span>(u.y - temp[<span class="number">0</span>].y, u.x - temp[<span class="number">0</span>].x);</span><br><span class="line">      <span class="keyword">double</span> theta_v = <span class="built_in">atan2</span>(v.y - temp[<span class="number">0</span>].y, v.x - temp[<span class="number">0</span>].x);</span><br><span class="line">      <span class="keyword">if</span> (theta_u == theta_v) &#123;</span><br><span class="line">        <span class="keyword">return</span> dist(u, temp[<span class="number">0</span>]) &lt; dist(v, temp[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> theta_u &lt; theta_v;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">auto</span> pos = temp.rend();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = next(temp.rbegin()); it != temp.rend(); ++it) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Cross(temp[<span class="number">0</span>], *temp.crbegin(), *it) != <span class="number">0</span>) &#123;</span><br><span class="line">        pos = it;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(temp.rbegin(), pos);</span><br><span class="line">    res-&gt;push_back(<span class="built_in">std</span>::move(temp[<span class="number">0</span>]));</span><br><span class="line">    res-&gt;push_back(<span class="built_in">std</span>::move(temp[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> n = temp.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Cross(*next(res-&gt;rbegin()), *res-&gt;rbegin(), temp[i]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        res-&gt;push_back(<span class="built_in">std</span>::move(temp[i]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res-&gt;pop_back();</span><br><span class="line">        --i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b, <span class="keyword">const</span> Point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ux = b.x - a.x;</span><br><span class="line">    <span class="keyword">int</span> uy = b.y - a.y;</span><br><span class="line">    <span class="keyword">int</span> vx = c.x - b.x;</span><br><span class="line">    <span class="keyword">int</span> vy = c.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> ux * vy - uy * vx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;Point&gt; outerTrees(<span class="built_in">vector</span>&lt;Point&gt;&amp; points) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; ans;</span><br><span class="line">    ConvexHull convex_hull;</span><br><span class="line">    convex_hull.GrahamScan(points, &amp;ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : ans) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.x &lt;&lt; <span class="string">' '</span> &lt;&lt; p.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;Point&gt; points1&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;,&#123;<span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">2</span>, <span class="number">0</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;,&#123;<span class="number">3</span>, <span class="number">3</span>&#125;,&#123;<span class="number">4</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Point&gt; points2&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,&#123;<span class="number">2</span>, <span class="number">2</span>&#125;,&#123;<span class="number">4</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">  PrintAns(solution-&gt;outerTrees(points1));</span><br><span class="line">  PrintAns(solution-&gt;outerTrees(points2));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/erect-the-fence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 587. Erect the Fence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="凸包" scheme="http://tashi711.top/tags/%E5%87%B8%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>「平面凸包」详解</title>
    <link href="http://tashi711.top/programming/dsaa/convex-hull/"/>
    <id>http://tashi711.top/programming/dsaa/convex-hull/</id>
    <published>2019-03-04T03:17:59.000Z</published>
    <updated>2019-03-04T15:19:03.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="平面凸包"><a href="#平面凸包" class="headerlink" title="平面凸包"></a>平面凸包</h2><p>Wiki上对平面凸包有一个直观的解释：在二维欧几里得空间中，凸包可想象为一条刚好包着所有点的橡皮圈。那么给定平面上的一组点集，如何求出其凸包就是本文讨论的内容。</p><h3 id="Jarvis步进法"><a href="#Jarvis步进法" class="headerlink" title="Jarvis步进法"></a>Jarvis步进法</h3><a id="more"></a><p>Jarvis步进法又叫包裹法，首先由一点必定在凸包的点开始，例如最左的一点A1。然后选择A2点使得所有点都在A1A2的右方，这步骤的时间复杂度是O(n)，要比较所有点以A1为原点的极坐标角度。以A2为原点，重复这个步骤，依次找到 A3,A4,…,Ak。这总共有k步。因此，时间复杂度为O(kn)。当然，最坏的情况下n个点全部在凸包上，复杂度为O(n^2)</p><h3 id="Graham扫描法"><a href="#Graham扫描法" class="headerlink" title="Graham扫描法"></a>Graham扫描法</h3><p>Graham扫描法基本是平面凸包最优的解法了，由最底的一点A1开始（如果有多个这样的点，那么选择最左边的），计算它跟其他各点的连线和x轴正向的角度，按小至大将这些点排序，称它们的对应点为A2,A3,…,An。这里的时间复杂度可达O(nlogn)，即排序的复杂度。考虑最小的角度对应的点A3。若由A2到A3的路径相对A1到A2的路径是向右转的（可以想象一个人沿A1走到A2，他站在A2时，是向哪边改变方向），表示A3不可能是凸包上的一点，考虑下一点由A2到A4的路径；否则就考虑A3到A4的路径是否向右转……直到回到A1。</p><p>若一个点在两边凸包点的连线上，考虑两种情况：一、认为这个点不是凸包上的点，这种情况最简单，只需注意保证每次都是严格的向左走（不可以走直线，即叉乘严格大于0）即可；二、认为这个点是凸包上的点，这种情况比较麻烦，首先每次只要不是向右走就好（可以走直线，即叉乘大于等于0），这个条件还不够，因为如果两个点在排序时是同一角度，遍历顺序也会影响结果，考虑某两个点在同一角度上，如果这两个点连线的两边都有点，那么这两个点无论遍历顺序，其中近的那个点一定会被忽略，远的那个点会正常进入考虑，如果连线的两边只有一边有点，那么这两个点一定是刚开始出去或者结束了回来，那么正确的遍历方式是出去的时候先遍历近的，再遍历远的，回来的时候相反（读者可以试着画图自证）。</p><p>以下为C++实现的考虑上面两种情况的第二种（第一种其实更为简单，这里略去），注意排序时当两个点角度相同时取更近的点在前（这里用|x|+|y|是等价的），然后在排好序的点集末尾把角度相同的顺序reverse成远的点在前。注意一点细节就是如果所有点集都在一条直线上，其实把他们当成出去或者回来都行，下面的代码会都reverse一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  Point() : x(<span class="number">0</span>), y(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : x(a), y(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvexHull</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GrahamScan</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Point&gt;&amp; points, <span class="built_in">vector</span>&lt;Point&gt;* res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (points.size() == <span class="number">1u</span>) &#123;</span><br><span class="line">      res-&gt;push_back(points[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; temp(points);</span><br><span class="line">    <span class="keyword">auto</span> p_min = min_element(temp.begin(), temp.end(),</span><br><span class="line">      [](<span class="keyword">const</span> Point&amp; u, <span class="keyword">const</span> Point&amp; v) &#123;</span><br><span class="line">      <span class="keyword">return</span> make_pair(u.y, u.x) &lt; make_pair(v.y, v.x);</span><br><span class="line">    &#125;);</span><br><span class="line">    swap(*p_min, temp[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">auto</span> dist = [](<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line">      <span class="keyword">int</span> dx = b.x - a.x;</span><br><span class="line">      <span class="keyword">int</span> dy = b.y - a.y;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">abs</span>(dx) + <span class="built_in">abs</span>(dy);</span><br><span class="line">    &#125;;</span><br><span class="line">    sort(next(temp.begin()), temp.end(),</span><br><span class="line">      [&amp;temp, &amp;dist](<span class="keyword">const</span> Point&amp; u, <span class="keyword">const</span> Point&amp; v) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">      <span class="keyword">double</span> theta_u = <span class="built_in">atan2</span>(u.y - temp[<span class="number">0</span>].y, u.x - temp[<span class="number">0</span>].x);</span><br><span class="line">      <span class="keyword">double</span> theta_v = <span class="built_in">atan2</span>(v.y - temp[<span class="number">0</span>].y, v.x - temp[<span class="number">0</span>].x);</span><br><span class="line">      <span class="keyword">if</span> (theta_u == theta_v) &#123;</span><br><span class="line">        <span class="keyword">return</span> dist(u, temp[<span class="number">0</span>]) &lt; dist(v, temp[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> theta_u &lt; theta_v;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">auto</span> pos = temp.rend();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = next(temp.rbegin()); it != temp.rend(); ++it) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Cross(temp[<span class="number">0</span>], *temp.crbegin(), *it) != <span class="number">0</span>) &#123;</span><br><span class="line">        pos = it;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(temp.rbegin(), pos);</span><br><span class="line">    res-&gt;push_back(<span class="built_in">std</span>::move(temp[<span class="number">0</span>]));</span><br><span class="line">    res-&gt;push_back(<span class="built_in">std</span>::move(temp[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> n = temp.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Cross(*next(res-&gt;rbegin()), *res-&gt;rbegin(), temp[i]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        res-&gt;push_back(<span class="built_in">std</span>::move(temp[i]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res-&gt;pop_back();</span><br><span class="line">        --i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Cross</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b, <span class="keyword">const</span> Point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ux = b.x - a.x;</span><br><span class="line">    <span class="keyword">int</span> uy = b.y - a.y;</span><br><span class="line">    <span class="keyword">int</span> vx = c.x - b.x;</span><br><span class="line">    <span class="keyword">int</span> vy = c.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> ux * vy - uy * vx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%87%B8%E5%8C%85" target="_blank" rel="noopener">维基百科 - 凸包</a>.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;平面凸包&quot;&gt;&lt;a href=&quot;#平面凸包&quot; class=&quot;headerlink&quot; title=&quot;平面凸包&quot;&gt;&lt;/a&gt;平面凸包&lt;/h2&gt;&lt;p&gt;Wiki上对平面凸包有一个直观的解释：在二维欧几里得空间中，凸包可想象为一条刚好包着所有点的橡皮圈。那么给定平面上的一组点集，如何求出其凸包就是本文讨论的内容。&lt;/p&gt;
&lt;h3 id=&quot;Jarvis步进法&quot;&gt;&lt;a href=&quot;#Jarvis步进法&quot; class=&quot;headerlink&quot; title=&quot;Jarvis步进法&quot;&gt;&lt;/a&gt;Jarvis步进法&lt;/h3&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="凸包" scheme="http://tashi711.top/tags/%E5%87%B8%E5%8C%85/"/>
    
      <category term="Graham" scheme="http://tashi711.top/tags/Graham/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 564. Find the Closest Palindrome」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-564/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-564/</id>
    <published>2019-02-27T03:57:03.000Z</published>
    <updated>2019-03-06T14:34:00.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/find-the-closest-palindrome/" target="_blank" rel="noopener">LeetCode 564. Find the Closest Palindrome</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个整数 n ，你需要找到与它最近的回文数（不包括自身）。<br>“最近的”定义为两个整数差的绝对值最小。</p><p><strong>示例 1:</strong><br>输入: “123”<br>输出: “121”</p><p><strong>注意:</strong><br>n 是由字符串表示的正整数，其长度不超过18。<br>如果有多个结果，返回最小的那个。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实就是个细节题，注意考虑模拟到所有情况即可。基本思路就是取左边一半（奇数长度取到包括中间位置），这个数称为left，右边的数模仿left、left+1、left-1的对称形式（不包括奇数长度时的中间位置）。然后left-1可能减一位或变成0、left+1可能增加一位，这些时候分别考虑99…9和100…01即可。输入就是一位长度时判断不是0输出n+1否则输出1。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(\log N)$（即数的长度）。<br>空间复杂度为$O(\log N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">nearestPalindromic</span><span class="params">(<span class="built_in">string</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num = stoll(n);</span><br><span class="line">    <span class="keyword">int</span> len = n.size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> to_string(num - <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> ans = n;</span><br><span class="line">    <span class="keyword">int</span> half = (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &lt; len; ++i) &#123;</span><br><span class="line">      ans[i] = ans[len - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans_val = stoll(ans);</span><br><span class="line">    <span class="keyword">if</span> (ans_val == num) &#123;</span><br><span class="line">      ans_val = <span class="number">0x7FFFFFFFFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left = stoll(n.substr(<span class="number">0</span>, half));</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> u = left - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> su = to_string(u);</span><br><span class="line">    <span class="keyword">int</span> len_u = su.size();</span><br><span class="line">    <span class="keyword">bool</span> consider_minus_1 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (len_u &lt; half || u == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="function"><span class="built_in">string</span> <span class="title">psb</span><span class="params">(len - <span class="number">1</span>, <span class="string">'9'</span>)</span></span>;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span> psb_val = stoll(psb);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">abs</span>(psb_val - num) &lt;= <span class="built_in">abs</span>(ans_val - num) &amp;&amp; psb_val != num) &#123;</span><br><span class="line">        ans_val = psb_val;</span><br><span class="line">        ans = psb;</span><br><span class="line">      &#125;</span><br><span class="line">      consider_minus_1 = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (consider_minus_1) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &lt; len; ++i) &#123;</span><br><span class="line">        su += su[len - i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> u_val = stoll(su);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(u_val - num) &lt;= <span class="built_in">abs</span>(ans_val - num) &amp;&amp; u_val != num) &#123;</span><br><span class="line">      ans_val = u_val;</span><br><span class="line">      ans = su;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v = left + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> sv = to_string(v);</span><br><span class="line">    <span class="keyword">int</span> len_v = sv.size();</span><br><span class="line">    <span class="keyword">bool</span> consider_add_1 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (len_v &gt; half) &#123;</span><br><span class="line">      string psb("1" + string(len - 1, '0') + "1");</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span> psb_val = stoll(psb);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">abs</span>(psb_val - num) &lt;= <span class="built_in">abs</span>(ans_val - num) &amp;&amp; psb_val != num) &#123;</span><br><span class="line">        ans_val = psb_val;</span><br><span class="line">        ans = psb;</span><br><span class="line">      &#125;</span><br><span class="line">      consider_add_1 = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (consider_add_1) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &lt; len; ++i) &#123;</span><br><span class="line">        sv += sv[len - i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v_val = stoll(sv);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(v_val - num) &lt; <span class="built_in">abs</span>(ans_val - num) &amp;&amp; v_val != num) &#123;</span><br><span class="line">      ans_val = v_val;</span><br><span class="line">      ans = sv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  PrintAns(solution-&gt;nearestPalindromic(<span class="string">"123"</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/find-the-closest-palindrome/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 564. Find the Closest Palindrome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="模拟" scheme="http://tashi711.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 493. Reverse Pairs」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-493/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-493/</id>
    <published>2019-02-26T03:57:03.000Z</published>
    <updated>2019-03-06T14:34:09.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/reverse-pairs/description/" target="_blank" rel="noopener">LeetCode 493. Reverse Pairs</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。<br>你需要返回给定数组中的重要翻转对的数量。</p><p><strong>示例 1:</strong><br>输入: [1,3,2,3,1]<br>输出: 2</p><p><strong>示例 2:</strong><br>输入: [2,4,3,5,1]<br>输出: 3</p><p><strong>注意:</strong><br>给定数组的长度不会超过50000。<br>输入数组中的所有数字都在32位整数的表示范围内。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>逆序对变种，之前写过一篇树状数组和归并排序来求逆序对的，这道题也都适用，下面的代码是分治（归并排序改进）做的。其实就修改一点，当右边队首被归并时产生的逆序对不是单纯的左边队列剩余多少个，而是某个特定点从那个地方开始的数都大于右边队首元素的两倍，每次右边队首被归并后维护这个位置，均摊常数复杂度。</p><p>注意两个细节，一是假如左边队列归并完了不能单纯把右边队列全部归并过去，而是也要一步一步计算可能产生的逆序对，例如左边是-5，右边是-3、-2，那么-5归并后依旧能对-3产生“逆序对”。二是注意int×2可能爆掉，写成×2LL即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N \log N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    ans_ = <span class="number">0</span>;</span><br><span class="line">    n_= nums.size();</span><br><span class="line">    MergeSort(nums, <span class="number">0</span>, n_ - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt;= v) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = u + (v - u) / <span class="number">2</span>;</span><br><span class="line">      MergeSort(nums, u, mid);</span><br><span class="line">      MergeSort(nums, mid + <span class="number">1</span>, v);</span><br><span class="line">      Merge(nums, u, mid, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u, <span class="keyword">int</span> mid, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> l = u, r = mid + <span class="number">1</span>, p = u;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= mid &amp;&amp; r &lt;= v &amp;&amp; nums[p] &lt;= nums[r] * <span class="number">2L</span>L) &#123;</span><br><span class="line">      ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= v) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[l] &lt;= nums[r]) &#123;</span><br><span class="line">        temp.push_back(nums[l++]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans_ += mid - p + <span class="number">1</span>;</span><br><span class="line">        temp.push_back(nums[r++]);</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= mid &amp;&amp; r &lt;= v &amp;&amp; nums[p] &lt;= nums[r] * <span class="number">2L</span>L) &#123;</span><br><span class="line">          ++p;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = back_inserter(temp);</span><br><span class="line">    copy(nums.cbegin() + l, nums.cbegin() + mid + <span class="number">1</span>, it);</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= v) &#123;</span><br><span class="line">      ans_ += mid - p + <span class="number">1</span>;</span><br><span class="line">      temp.push_back(nums[r++]);</span><br><span class="line">      <span class="keyword">while</span> (p &lt;= mid &amp;&amp; r &lt;= v &amp;&amp; nums[p] &lt;= nums[r] * <span class="number">2L</span>L) &#123;</span><br><span class="line">        ++p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    copy(temp.cbegin(), temp.cend(), nums.begin() + u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n_ = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans_ = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2 = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  PrintAns(solution-&gt;reversePairs(nums1));</span><br><span class="line">  PrintAns(solution-&gt;reversePairs(nums2));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/reverse-pairs/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 493. Reverse Pairs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="分治" scheme="http://tashi711.top/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 480. Sliding Window Median」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-480/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-480/</id>
    <published>2019-02-25T03:57:03.000Z</published>
    <updated>2019-03-06T14:34:26.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/sliding-window-median/solution/" target="_blank" rel="noopener">LeetCode 480. Sliding Window Median</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。<br>例如：<br>[2,3,4]，中位数是 3<br>[2,3]，中位数是 (2 + 3) / 2 = 2.5<br>给出一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。<br>例如：<br>给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。<br>窗口位置                      中位数<br>[1  3  -1] -3  5  3  6  7       1<br> 1 [3  -1  -3] 5  3  6  7       -1<br> 1  3 [-1  -3  5] 3  6  7       -1<br> 1  3  -1 [-3  5  3] 6  7       3<br> 1  3  -1  -3 [5  3  6] 7       5<br> 1  3  -1  -3  5 [3  6  7]      6<br> 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。</p><p><strong>提示：</strong><br>假设k是合法的，即：k 始终小于输入的非空数组的元素个数.</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>没有题解，跟之前做的有一道在线求中位数比较像（295），可以借鉴思路，不过由于用记录中间迭代器的做法比较不直观，并且会删除元素，很可能就删掉记录的那个元素，因此考虑用两个平衡树（小根大根）实现，不用堆是因为有删除随机位置的操作。平衡树可以用STL的multiset做，单次操作复杂度都是log级。注意一点就是两个整数相加（在求平均值的时候）可能爆掉，因此我是直接用double存的。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N \log N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; medianSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">double</span>, greater&lt;<span class="keyword">double</span>&gt;&gt; small;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; big;</span><br><span class="line">    <span class="keyword">int</span> ns = (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">      small.insert(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ns; i &lt; k; ++i) &#123;</span><br><span class="line">      big.insert(*small.cbegin());</span><br><span class="line">      small.erase(small.cbegin());</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(k &amp; <span class="number">1</span> ?</span><br><span class="line">      *small.cbegin() : (*small.cbegin() + *big.cbegin()) / <span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = small.find(nums[i - k]);</span><br><span class="line">      <span class="keyword">if</span> (it != small.end()) &#123;</span><br><span class="line">        small.erase(it);</span><br><span class="line">        <span class="keyword">if</span> (big.empty() || nums[i] &lt;= *big.cbegin()) &#123;</span><br><span class="line">          small.insert(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          small.insert(*big.cbegin());</span><br><span class="line">          big.erase(big.cbegin());</span><br><span class="line">          big.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = big.find(nums[i - k]);</span><br><span class="line">        big.erase(it);</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= *small.cbegin()) &#123;</span><br><span class="line">          big.insert(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          big.insert(*small.cbegin());</span><br><span class="line">          small.erase(small.cbegin());</span><br><span class="line">          small.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ans.push_back(k &amp; <span class="number">1</span> ?</span><br><span class="line">        *small.cbegin() : (*small.cbegin() + *big.cbegin()) / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">  ostream_iterator&lt;<span class="keyword">double</span>&gt; it(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line">  copy(ans.cbegin(), ans.cend(), it);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">-3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">  PrintAns(solution-&gt;medianSlidingWindow(nums, <span class="number">3</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/sliding-window-median/solution/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 480. Sliding Window Median&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="平衡树" scheme="http://tashi711.top/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 466. Count The Repetitions」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-466/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-466/</id>
    <published>2019-02-24T03:57:03.000Z</published>
    <updated>2019-02-24T16:37:04.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/count-the-repetitions/description/" target="_blank" rel="noopener">LeetCode 466. Count The Repetitions</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>定义由 n 个连接的字符串 s 组成字符串 S，即 S = [s,n]。例如，[“abc”, 3]=“abcabcabc”。<br>另一方面，如果我们可以从 s2 中删除某些字符使其变为 s1，我们称字符串 s1 可以从字符串 s2 获得。例如，“abc” 可以根据我们的定义从 “abdbec” 获得，但不能从 “acbbe” 获得。<br>现在给出两个非空字符串 S1 和 S2（每个最多 100 个字符长）和两个整数 0 ≤ N1 ≤ 10^6 和 1 ≤ N2 ≤ 10^6。现在考虑字符串 S1 和 S2，其中S1=[s1,n1]和S2=[s2,n2]。找出可以使[S2,M]从 S1 获得的最大整数 M。</p><p><strong>示例：</strong><br>输入：<br>s1 =”acb”,n1 = 4<br>s2 =”ab”,n2 = 2<br>返回：<br>2</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较麻烦的一道题，注意细节即可，先从头开始遍历匹配，直到遇到s1末尾匹配到s2相同的位置，此时能得到几个s1完全匹配几个s2（当然如果在找到这个之前n1就消耗完了就直接返回了），然后用一个除法取模，一下子能把绝大部分匹配完，最后再做少量遍历匹配结尾即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N^2)$，其中N为字符串长度规模，因为n1结尾最多把n2的每个位置都匹配一遍就能找到重复的。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getMaxRepetitions</span><span class="params">(<span class="built_in">string</span> s1, <span class="keyword">int</span> n1, <span class="built_in">string</span> s2, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz1 = s1.size(), sz2 = s2.size();</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f1, f2;</span><br><span class="line">    <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>, last1 = <span class="number">-1</span>, last2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cnt1 == n1) &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt2 / n2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == s2[p2]) &#123;</span><br><span class="line">          ++p2;</span><br><span class="line">          <span class="keyword">if</span> (p2 == sz2) &#123;</span><br><span class="line">            ++cnt2;</span><br><span class="line">            p2 = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++cnt1;</span><br><span class="line">      <span class="keyword">if</span> (f1.find(p2) == f1.end()) &#123;</span><br><span class="line">        f1[p2] = cnt1;</span><br><span class="line">        f2[p2] = cnt2;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last1 = f1[p2];</span><br><span class="line">        last2 = f2[p2];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> delta1 = cnt1 - last1;</span><br><span class="line">    <span class="keyword">int</span> delta2 = cnt2 - last2;</span><br><span class="line">    n1 -= cnt1;</span><br><span class="line">    cnt2 += n1 / delta1 * delta2;</span><br><span class="line">    n1 %= delta1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n1; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == s2[p2]) &#123;</span><br><span class="line">          ++p2;</span><br><span class="line">          <span class="keyword">if</span> (p2 == sz2) &#123;</span><br><span class="line">            ++cnt2;</span><br><span class="line">            p2 = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt2 / n2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  PrintAns(solution-&gt;getMaxRepetitions(<span class="string">"acb"</span>, <span class="number">4</span>, <span class="string">"ab"</span>, <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/count-the-repetitions/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 466. Count The Repetitions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="模拟" scheme="http://tashi711.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 446. Arithmetic Slices II - Subsequence」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-446/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-446/</id>
    <published>2019-02-23T03:57:03.000Z</published>
    <updated>2019-02-23T05:32:00.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/arithmetic-slices-ii-subsequence/description/" target="_blank" rel="noopener">LeetCode 446. Arithmetic Slices II - Subsequence</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。<br>例如，以下数列为等差数列:<br>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9<br>以下数列不是等差数列。<br>1, 1, 2, 5, 7<br>数组 A 包含 N 个数，且索引从 0 开始。该数组子序列将划分为整数序列 (P0, P1, …, Pk)，P 与 Q 是整数且满足 0 ≤ P0 &lt; P1 &lt; … &lt; Pk &lt; N。<br>如果序列 A[P0]，A[P1]，…，A[Pk-1]，A[Pk] 是等差的，那么数组 A 的子序列 (P0，P1，…，PK) 称为等差序列。值得注意的是，这意味着 k ≥ 2。<br>函数要返回数组 A 中所有等差子序列的个数。<br>输入包含 N 个整数。每个整数都在 -231 和 231-1 之间，另外 0 ≤ N ≤ 1000。保证输出小于 231-1。</p><p><strong>示例：</strong><br>输入：[2, 4, 6, 8, 10]<br>输出：7<br>解释：<br>所有的等差子序列为：<br>[2,4,6]<br>[4,6,8]<br>[6,8,10]<br>[2,4,6,8]<br>[4,6,8,10]<br>[2,4,6,8,10]<br>[2,6,10]</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较简单的一道DP，只是要稍微绕一下，下标是离散的，需要用一个哈希转换一下。注意int - int可能得到int范围外的数，用long long保存差值即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N^2)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;&gt; cnt(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dt = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i]) - A[j];</span><br><span class="line">        <span class="keyword">int</span> chd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[j].find(dt) != cnt[j].end()) &#123;</span><br><span class="line">          chd = cnt[j][dt];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[i][dt] += chd + <span class="number">1</span>;</span><br><span class="line">        ans += chd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">  PrintAns(solution-&gt;numberOfArithmeticSlices(A));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/arithmetic-slices-ii-subsequence/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 446. Arithmetic Slices II - Subsequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 996. Number of Squareful Arrays」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-996/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-996/</id>
    <published>2019-02-22T03:57:03.000Z</published>
    <updated>2019-02-20T08:04:12.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/number-of-squareful-arrays/description/" target="_blank" rel="noopener">LeetCode 996. Number of Squareful Arrays</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。<br>返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。</p><p><strong>示例 1：</strong><br>输入：[1,17,8]<br>输出：2<br>解释：<br>[1,8,17] 和 [17,8,1] 都是有效的排列。</p><p><strong>示例 2：</strong><br>输入：[2,2,2]<br>输出：1</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 12<br>0 &lt;= A[i] &lt;= 1e9</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实应该是标准的状压DP，参考标解2，这里使用暴力枚举也做出来了，当然加了点优化。<br>一开始先建图，用纯暴力枚举所有哈密顿路径，然后分别除以每个重复数字个数的阶乘，TLE。<br>尝试直接在dfs时判断，当前走过某个数字时，不在同一步尝试走跟它相同数值的结点（两个结点完全等价），AC。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N!)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numSquarefulPerms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    ans_ = <span class="number">0</span>;</span><br><span class="line">    n_ = A.size();</span><br><span class="line">    adj_.assign(n_ + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    vst_.assign(n_ + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    f_.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k : A) &#123;</span><br><span class="line">      ++f_[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n_; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsSquare(A[i] + A[j])) &#123;</span><br><span class="line">          adj_[i].push_back(j);</span><br><span class="line">          adj_[j].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; ++i) &#123;</span><br><span class="line">      adj_[n_].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Dfs(<span class="number">0</span>, n_, A);</span><br><span class="line">    <span class="keyword">return</span> ans_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsSquare</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(k) + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">if</span> (rt * rt == k) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> u, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    vst_[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == n_) &#123;</span><br><span class="line">      ++ans_;</span><br><span class="line">      vst_[u] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : adj_[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vst_[v] &amp;&amp; s.find(A[v]) == s.end()) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, v, A);</span><br><span class="line">        s.insert(A[v]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vst_[u] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vst_;</span><br><span class="line">  <span class="keyword">int</span> ans_;</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input1 = &#123;<span class="number">1</span>, <span class="number">17</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input2 = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  PrintAns(solution-&gt;numSquarefulPerms(input1));</span><br><span class="line">  PrintAns(solution-&gt;numSquarefulPerms(input2));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/number-of-squareful-arrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 996. Number of Squareful Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="状态压缩DP" scheme="http://tashi711.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    
      <category term="TSP问题" scheme="http://tashi711.top/tags/TSP%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 995. Minimum Number of K Consecutive Bit Flips」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-995/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-995/</id>
    <published>2019-02-21T03:57:03.000Z</published>
    <updated>2019-02-20T08:03:55.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/" target="_blank" rel="noopener">LeetCode 995. Minimum Number of K Consecutive Bit Flips</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。<br>返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。</p><p><strong>示例 1：</strong><br>输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。</p><p><strong>示例 2：</strong><br>输入：A = [1,1,0], K = 2<br>输出：-1<br>解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。</p><p><strong>示例 3：</strong><br>输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 30000<br>1 &lt;= K &lt;= A.length</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很容易想到一个n方的贪心，从左扫到右，如果当前是0，就一定要变成1。<br>可以参考下题解的“开关事件”思路，非常巧妙，可以优化一维复杂度。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      cur ^= flag[i];</span><br><span class="line">      <span class="keyword">if</span> (A[i] == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ans;</span><br><span class="line">        flag[i + K] = <span class="number">1</span>;</span><br><span class="line">        cur ^= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a3 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  PrintAns(solution-&gt;minKBitFlips(a1, <span class="number">1</span>));</span><br><span class="line">  PrintAns(solution-&gt;minKBitFlips(a2, <span class="number">2</span>));</span><br><span class="line">  PrintAns(solution-&gt;minKBitFlips(a3, <span class="number">3</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 995. Minimum Number of K Consecutive Bit Flips&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="巧妙" scheme="http://tashi711.top/tags/%E5%B7%A7%E5%A6%99/"/>
    
      <category term="贪心" scheme="http://tashi711.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 301. Remove Invalid Parentheses」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-301/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-301/</id>
    <published>2019-02-20T03:57:03.000Z</published>
    <updated>2019-02-20T07:29:06.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/remove-invalid-parentheses/description/" target="_blank" rel="noopener">LeetCode 301. Remove Invalid Parentheses</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。<br>说明: 输入可能包含了除 ( 和 ) 以外的字符。</p><p><strong>示例 1:</strong><br>输入: “()())()”<br>输出: [“()()()”, “(())()”]</p><p><strong>示例 2:</strong><br>输入: “(a)())()”<br>输出: [“(a)()()”, “(a())()”]</p><p><strong>示例 3:</strong><br>输入: “)(“<br>输出: [“”]</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题解太长就没看了，但是看到复杂度还是放心去码了（所以题目不给数据规模真的有时候挺难受）。首先有一点，括号除外的字母一定不用删掉，因此只需着眼于括号。</p><p>考虑纯暴力回溯，左括号多于右括号时才考虑添加，最坏2^N，记录答案时遇到更长的直接替换掉。我这里使用了一个小小的优化，先求出最优解的长度，然后用这个数据进行可行性剪枝。（或者这个属于最优化剪枝？看怎么理解。）当然了最坏复杂度还是2^N，比如一半左括号接一半右括号：(((…)))…。不过这个剪枝一般情况下可以节省大量时间（至少不用考虑长度了，因为经过可行性剪枝之后到达最后的一定是最长的）。</p><p>那么最优解的长度怎么求呢，其实很简单，线性的遍历一次即可，开一个计数器。遇到左括号计数器+1，遇到右括号如果计数器不为0则-1，最优解多匹配一组括号。</p><p>最后去重用unordered_set即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(2^N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; removeInvalidParentheses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">    ans_.clear();</span><br><span class="line">    s_ = s;</span><br><span class="line">    n_ = s_.size();</span><br><span class="line">    CalcLongestLen();</span><br><span class="line">    Dfs(<span class="number">0</span>, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(ans_.begin(), ans_.end());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CalcLongestLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    len_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">          --cnt;</span><br><span class="line">          ++len_;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> <span class="built_in">string</span>&amp; cur, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == n_) &#123;</span><br><span class="line">      ans_.insert(cur);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s_[p] == <span class="string">'('</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &lt; len_) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, cur + <span class="string">'('</span>, left + <span class="number">1</span>, right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n_ - <span class="number">1</span> - p &gt;= len_ * <span class="number">2</span> - left - right) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, cur, left, right);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s_[p] == <span class="string">')'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, cur + <span class="string">')'</span>, left, right + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n_ - <span class="number">1</span> - p &gt;= len_ * <span class="number">2</span> - left - right) &#123;</span><br><span class="line">        Dfs(p + <span class="number">1</span>, cur, left, right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n_ - <span class="number">1</span> - p &gt;= len_ * <span class="number">2</span> - left - right) &#123;</span><br><span class="line">      Dfs(p + <span class="number">1</span>, cur + s_[p], left, right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; ans_;</span><br><span class="line">  <span class="built_in">string</span> s_;</span><br><span class="line">  <span class="keyword">int</span> n_ = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> len_ = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">  ostream_iterator&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt; out_it(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line">  copy(ans.cbegin(), ans.cend(), out_it);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  PrintAns(solution-&gt;removeInvalidParentheses(<span class="string">"()())()"</span>));</span><br><span class="line">  PrintAns(solution-&gt;removeInvalidParentheses(<span class="string">"(a)())()"</span>));</span><br><span class="line">  PrintAns(solution-&gt;removeInvalidParentheses(<span class="string">")("</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/remove-invalid-parentheses/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 301. Remove Invalid Parentheses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="回溯" scheme="http://tashi711.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 295. Find Median from Data Stream」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-295/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-295/</id>
    <published>2019-02-19T03:57:03.000Z</published>
    <updated>2019-02-19T11:16:14.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/find-median-from-data-stream/description/" target="_blank" rel="noopener">LeetCode 295. Find Median from Data Stream</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。<br>例如，<br>[2,3,4] 的中位数是 3<br>[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br>设计一个支持以下两种操作的数据结构：<br>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p><p><strong>示例：</strong><br>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p><p><strong>进阶:</strong><br>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？<br>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>不超时的算法，一是用两个堆（优先队列，题解方法3），插入是log时间，可能会移来移去，查找是常数时间，比较清晰。<br>这里主要说说第二种解法，其实就是裸的平衡树，单次插入都是log时间。<br>一般平衡树都可以实现求第k大数的功能，这样查找为log时间，可以优化，因为插入前后求第k大的位置相差不会超过1。<br>仅需判断插入后中间值往哪里移，（如果这个操作被认为是常数时间）插入操作仅需常数时间。<br>考虑使用STL的平衡树（multiset），代码基本与题解相同，使用一个迭代器。<br>要注意这段代码能够运行正确必须保证两点，一是插入操作不影响原先保存的迭代器位置（multiset满足）。<br>二是当插入重复元素时的位置是确定的，multiset在C++11之后是保证插入到相同元素的最后。<br>因此在C++11之前下面的代码其实是不保证正确的，需要注意。<br>至于进阶考虑的问题，如果整数值的规模只有100，可以开100个计数器。<br>维护前缀和在一半以前的位置，这样插入与查找的复杂度都是常数。<br>如果绝大部分数据满足这个，那么可以考虑绝大部分数据用计数器，其他数据再用平衡树。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N \log N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MedianFinder() : ptr_(data_.end()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = data_.size();</span><br><span class="line">    data_.insert(num);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">      ptr_ = data_.begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; *ptr_) &#123;</span><br><span class="line">      ptr_ = (n &amp; <span class="number">1</span> ? ptr_ : prev(ptr_));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ptr_ = (n &amp; <span class="number">1</span> ? next(ptr_) : ptr_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = data_.size();</span><br><span class="line">    <span class="keyword">return</span> (*ptr_ + *next(ptr_, n % <span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; data_;</span><br><span class="line">  <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MedianFinder obj;</span><br><span class="line">  obj.addNum(<span class="number">1</span>);</span><br><span class="line">  obj.addNum(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; obj.findMedian() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  obj.addNum(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; obj.findMedian() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/find-median-from-data-stream/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 295. Find Median from Data Stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="平衡树" scheme="http://tashi711.top/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 282. Expression Add Operators」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-282/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-282/</id>
    <published>2019-02-18T03:57:03.000Z</published>
    <updated>2019-02-18T11:58:14.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/expression-add-operators/description/" target="_blank" rel="noopener">LeetCode 282. Expression Add Operators</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><a id="more"></a><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个仅包含数字 0-9 的字符串和一个目标值，在数字之间添加二元运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。</p><p><strong>示例 1:</strong><br>输入: num = “123”, target = 6<br>输出: [“1+2+3”, “1*2*3”] </p><p><strong>示例 2:</strong><br>输入: num = “232”, target = 8<br>输出: [“2*3+2”, “2+3*2”]</p><p><strong>示例 3:</strong><br>输入: num = “105”, target = 5<br>输出: [“1*0+5”,”10-5”]</p><p><strong>示例 4:</strong><br>输入: num = “00”, target = 0<br>输出: [“0+0”, “0-0”, “0*0”]</p><p><strong>示例 5:</strong><br>输入: num = “3456237490”, target = 9191<br>输出: []</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>标准的回溯题，直接做就好。<br>注意两点，一是题目隐含前导0是不满足要求的，需要处理一下（否则105可以有1*05）。<br>二是可能爆int，比如样例的最后一个，用long long即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>官方给出了$O(N^2 \cdot 3^N)$的推导，当然有一维N是因为拷贝导致的，可以优化掉，不过需要更复杂的处理。<br>时间复杂度为$O(N^2 \cdot 3^N)$。<br>空间复杂度为$O(N^2 \cdot 3^N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">long</span> <span class="keyword">long</span> sum, <span class="keyword">long</span> <span class="keyword">long</span> pre, <span class="keyword">const</span> <span class="built_in">string</span>&amp; cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == n_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sum == target_) &#123;</span><br><span class="line">        ans_.push_back(cur);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val_now = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str_now;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt; n_; ++i) &#123;</span><br><span class="line">      val_now = val_now * <span class="number">10</span> + num_[i] - <span class="string">'0'</span>;</span><br><span class="line">      str_now += num_[i];</span><br><span class="line">      <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">        Dfs(i + <span class="number">1</span>, val_now, val_now, str_now);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Dfs(i + <span class="number">1</span>, sum - pre + pre * val_now, pre * val_now, cur + <span class="string">'*'</span> + str_now);</span><br><span class="line">        Dfs(i + <span class="number">1</span>, sum + val_now, val_now, cur + <span class="string">'+'</span> + str_now);</span><br><span class="line">        Dfs(i + <span class="number">1</span>, sum - val_now, -val_now, cur + <span class="string">'-'</span> + str_now);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (num_[p] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; addOperators(<span class="built_in">string</span> num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    num_ = num;</span><br><span class="line">    n_ = num.size();</span><br><span class="line">    target_ = target;</span><br><span class="line">    ans_.clear();</span><br><span class="line">    Dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> ans_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans_;</span><br><span class="line">  <span class="built_in">string</span> num_;</span><br><span class="line">  <span class="keyword">int</span> n_;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> target_ = <span class="number">-1L</span>L;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAns</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s : ans) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"123"</span>, <span class="number">6</span>));</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"232"</span>, <span class="number">8</span>));</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"105"</span>, <span class="number">5</span>));</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"00"</span>, <span class="number">0</span>));</span><br><span class="line">  PrintAns(solution-&gt;addOperators(<span class="string">"3456237490"</span>, <span class="number">9191</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/expression-add-operators/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 282. Expression Add Operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="回溯" scheme="http://tashi711.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 992. Subarrays with K Different Integers」解题报告</title>
    <link href="http://tashi711.top/programming/reports/leetcode/leetcode-992/"/>
    <id>http://tashi711.top/programming/reports/leetcode/leetcode-992/</id>
    <published>2019-02-10T03:57:03.000Z</published>
    <updated>2019-02-17T12:53:02.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/description/" target="_blank" rel="noopener">LeetCode 992. Subarrays with K Different Integers</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。<br>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）<br>返回 A 中好子数组的数目。</p><p><strong>示例 1：</strong><br>输出：A = [1,2,1,2,3], K = 2<br>输入：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</p><p><strong>示例 2：</strong><br>输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= A.length<br>1 &lt;= K &lt;= A.length</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>维护两个窗口，一个是到目前为止个数不超过K的，一个是到目前为止个数小于K的。<br>两者长度相减就是以当前结尾满足要求的个数。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt_long(n + <span class="number">1</span>, <span class="number">0</span>), cnt_short(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> num_long = <span class="number">0</span>, num_short = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idx_long = <span class="number">0</span>, idx_short = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> cur = A[i];</span><br><span class="line">      <span class="keyword">if</span> (cnt_long[cur]++ == <span class="number">0</span>) &#123;</span><br><span class="line">        ++num_long;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (num_long &gt; K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt_long[A[idx_long++]] == <span class="number">0</span>) &#123;</span><br><span class="line">          --num_long;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cnt_short[cur]++ == <span class="number">0</span>) &#123;</span><br><span class="line">        ++num_short;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (num_short &gt;= K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt_short[A[idx_short++]] == <span class="number">0</span>) &#123;</span><br><span class="line">          --num_short;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ans += idx_short - idx_long;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;Solution&gt; solution(<span class="keyword">new</span> Solution);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; solution-&gt;subarraysWithKDistinct(input1, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; solution-&gt;subarraysWithKDistinct(input2, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/subarrays-with-k-different-integers/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 992. Subarrays with K Different Integers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。&lt;br&gt;（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）&lt;br&gt;返回 A 中好子数组的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输出：A = [1,2,1,2,3], K = 2&lt;br&gt;输入：7&lt;br&gt;解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：A = [1,2,1,3,4], K = 3&lt;br&gt;输出：3&lt;br&gt;解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;br&gt;1 &amp;lt;= A[i] &amp;lt;= A.length&lt;br&gt;1 &amp;lt;= K &amp;lt;= A.length&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="滑动窗口" scheme="http://tashi711.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>「Kick Start 2018 Round H」试水</title>
    <link href="http://tashi711.top/programming/reports/others/kick-start-2018-h/"/>
    <id>http://tashi711.top/programming/reports/others/kick-start-2018-h/</id>
    <published>2019-02-09T01:57:24.000Z</published>
    <updated>2019-02-09T11:27:28.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2" target="_blank" rel="noopener">Kick Start 2018 Round H</a></li><li>来源：Google</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="1-Big-Buttons-9pts-13pts"><a href="#1-Big-Buttons-9pts-13pts" class="headerlink" title="1. Big Buttons (9pts, 13pts)"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2/0000000000051136" target="_blank" rel="noopener">1. Big Buttons (9pts, 13pts)</a></h3><h4 id="大致描述"><a href="#大致描述" class="headerlink" title="大致描述"></a>大致描述</h4><p>给定长度N和P个前缀，求只由“R”“B”组成的长度为N的且不以这P个前缀开头的字符串有多少种。<br>T组数据，范围1到100，P范围1到min(2^N, 100)，N范围小数据1到10，大数据1到50。</p><a id="more"></a><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很容易就能想出大数据的解法了，先去掉被其他前缀包含的前缀，保证前缀两两不冲突。<br>然后去掉每个前缀产生的个数（2^(N-L)），L为当前前缀长度。每次去掉的个数一定不会与其他前缀冲突。<br>因此复杂度其实主要是预处理的时间，O(P^2·N)，题解给出了更优的解法：字典树，可以优化一维P。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度为$O(P^2N)$（以下代码）。<br>空间复杂度为$O(PN)$。</p><h4 id="AC代码（C-G-）"><a href="#AC代码（C-G-）" class="headerlink" title="AC代码（C++ (G++)）"></a>AC代码（C++ (G++)）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KickStartSolver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  KickStartSolver() : po2(kMaxN + <span class="number">1</span>) &#123;</span><br><span class="line">    Init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnlineJudge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">      InputAndSolveSingleCase();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LocalTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    po2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kMaxN; ++i) &#123;</span><br><span class="line">      po2[i] = po2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InputAndSolveSingleCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input;</span><br><span class="line">    <span class="keyword">int</span> n, p;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">      input.emplace_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Solve(n, input);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; input)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">char</span> delimiter, <span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++case_cnt &lt;&lt; <span class="string">":"</span> &lt;&lt; delimiter &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputSameLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">' '</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputNewLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">'\n'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> case_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; po2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::Solve(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; input) &#123;</span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; diff;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; si : input) &#123;</span><br><span class="line">    <span class="keyword">bool</span> need_insert = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; to_erase;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; sd : diff) &#123;</span><br><span class="line">      <span class="keyword">bool</span> same = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">int</span> ssi = si.size(), ssd = sd.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ssi &amp;&amp; i &lt; ssd; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si[i] != sd[i]) &#123;</span><br><span class="line">          same = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (same) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssi &lt; ssd) &#123;</span><br><span class="line">          to_erase.push_back(sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          need_insert = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (need_insert) &#123;</span><br><span class="line">      diff.insert(si);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; st : to_erase) &#123;</span><br><span class="line">      diff.erase(st);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = po2[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; sd : diff) &#123;</span><br><span class="line">    ans -= po2[n - sd.size()];</span><br><span class="line">  &#125;</span><br><span class="line">  ss &lt;&lt; ans;</span><br><span class="line">  OutputSameLine(ss.str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::LocalTest() &#123;</span><br><span class="line">  <span class="keyword">int</span> n1 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">int</span> n2 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> n3 = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> n4 = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input1&#123;<span class="string">"BBB"</span>, <span class="string">"RB"</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input2&#123;<span class="string">"R"</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input3&#123;<span class="string">"R"</span>, <span class="string">"B"</span>, <span class="string">"RBRB"</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; input4&#123;<span class="string">"BRBRBBBRBRRRBBB"</span>, <span class="string">"BRBRBRRRBRRRBRB"</span>,</span><br><span class="line">    <span class="string">"BBBRBBBRBRRRBBB"</span>,<span class="string">"BRBRBRRRBRRRB"</span>, <span class="string">"BRBRBBBRBBBRB"</span>&#125;;</span><br><span class="line">  Solve(n1, input1);</span><br><span class="line">  Solve(n2, input2);</span><br><span class="line">  Solve(n3, input3);</span><br><span class="line">  Solve(n4, input4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;KickStartSolver&gt; solver(<span class="keyword">new</span> KickStartSolver);</span><br><span class="line">  <span class="comment">// solver-&gt;LocalTest();</span></span><br><span class="line">  solver-&gt;OnlineJudge();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Mural-14pts-19pts"><a href="#2-Mural-14pts-19pts" class="headerlink" title="2. Mural (14pts, 19pts)"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2/000000000005118a" target="_blank" rel="noopener">2. Mural (14pts, 19pts)</a></h3><h4 id="大致描述-1"><a href="#大致描述-1" class="headerlink" title="大致描述"></a>大致描述</h4><p>给定N个一位数排成一排，每天先取一个数，第一天任意取，后面只能挨着取过的数取。<br>然后每天会丢一个数，只能从两边随机丢一个且不能是已经取的数，丢掉的数不能再取。<br>问最多得到的数和为多少。<br>1到100组数据，N范围小数据2到100，大数据有一个5×10^6，其余同小数据。</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>其实很容易就能想出大数据的解法了，想到一定能取到任意ceil(N/2)个连续的数就解决了。<br>可以这么取：第一天一定取使得想取的分开两边不长于不想取的长度（有两个的话任意取）。<br>比如下面，x代表不想取的，o代表想取的，#代表最先取的：<br>8个： xxxoooox -&gt; xxxoo##x （均可）<br>9个： xxxooooox -&gt; xxxooo#ox<br>后面当天丢掉哪边，第二天就往哪边取（或者那边已经取完了，此时往剩的一边一直取完到结束）。<br>那么抽象一下，最终问题就是求定长最大子序列和了，O(N)就可以解决。</p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h4 id="AC代码（C-G-）-1"><a href="#AC代码（C-G-）-1" class="headerlink" title="AC代码（C++ (G++)）"></a>AC代码（C++ (G++)）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KickStartSolver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnlineJudge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LocalTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InputAndSolveSingleCase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span>&amp; input)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">char</span> delimiter, <span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++seq_case &lt;&lt; <span class="string">":"</span> &lt;&lt; delimiter &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputSameLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">' '</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputNewLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">'\n'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> seq_case = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::OnlineJudge() &#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    InputAndSolveSingleCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::InputAndSolveSingleCase() &#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">  Solve(n, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::Solve(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span>&amp; input) &#123;</span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line">  <span class="keyword">int</span> half = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">  transform(input.cbegin(), input.cend(), back_inserter(val), [](<span class="keyword">char</span> c) &#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">int</span> cur = accumulate(val.cbegin(), val.cbegin() + half, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> ans = cur;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &lt; n; ++i) &#123;</span><br><span class="line">    cur += val[i] - val[i - half];</span><br><span class="line">    ans = max(ans, cur);</span><br><span class="line">  &#125;</span><br><span class="line">  ss &lt;&lt; ans;</span><br><span class="line">  OutputSameLine(ss.str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::LocalTest() &#123;</span><br><span class="line">  Solve(<span class="number">4</span>, <span class="string">"1332"</span>);</span><br><span class="line">  Solve(<span class="number">4</span>, <span class="string">"9583"</span>);</span><br><span class="line">  Solve(<span class="number">3</span>, <span class="string">"616"</span>);</span><br><span class="line">  Solve(<span class="number">10</span>, <span class="string">"1029384756"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;KickStartSolver&gt; solver(<span class="keyword">new</span> KickStartSolver);</span><br><span class="line">  <span class="comment">// solver-&gt;LocalTest();</span></span><br><span class="line">  solver-&gt;OnlineJudge();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Let-Me-Count-The-Ways-20pts-25pts"><a href="#3-Let-Me-Count-The-Ways-20pts-25pts" class="headerlink" title="3. Let Me Count The Ways (20pts, 25pts)"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2/0000000000051189" target="_blank" rel="noopener">3. Let Me Count The Ways (20pts, 25pts)</a></h3><h4 id="大致描述-2"><a href="#大致描述-2" class="headerlink" title="大致描述"></a>大致描述</h4><p>给定N对人排一排，其中M对人不能挨在一起，有多少种方案。<br>1到100组数据，小数据1 ≤ M ≤ N ≤ 100，大数据1 ≤ M ≤ N ≤ 100000。</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>其实比较容易就想到了容斥原理加上一点组合数学求解，只是瓶颈在求组合数需要线性复杂度。<br>哪怕预处理组合数，时间和空间也不够（n方），看了题解恍然大悟，还能用模逆元，就能O(1)求出组合数。<br>预处理阶乘与其模逆元也就O(NlogN)复杂度。</p><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度为$O(N)$（不计预处理复杂度）。<br>空间复杂度为$O(N)$。</p><h4 id="AC代码（C-G-）-2"><a href="#AC代码（C-G-）-2" class="headerlink" title="AC代码（C++ (G++)）"></a>AC代码（C++ (G++)）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KickStartSolver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">200000</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">long</span> <span class="keyword">long</span> kModulus = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">  KickStartSolver() : po2(kMaxN + <span class="number">1</span>), fact(kMaxN + <span class="number">1</span>), fact_inv(kMaxN + <span class="number">1</span>) &#123;</span><br><span class="line">    po2[<span class="number">0</span>] = fact[<span class="number">0</span>] = fact_inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kMaxN; ++i) &#123;</span><br><span class="line">      po2[i] = (po2[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % kModulus;</span><br><span class="line">      fact[i] = (fact[i - <span class="number">1</span>] * i) % kModulus;</span><br><span class="line">      fact_inv[i] = ModularInverse(fact[i], kModulus);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnlineJudge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">LocalTest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">InputAndSolveSingleCase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T <span class="title">ExtendedEuclidean</span><span class="params">(T a, T b, T* x, T* y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">      *x = <span class="number">1</span>;</span><br><span class="line">      *y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      T gcd = ExtendedEuclidean(b, a % b, y, x);</span><br><span class="line">      *y -= *x * (a / b);</span><br><span class="line">      <span class="keyword">return</span> gcd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T <span class="title">ModularInverse</span><span class="params">(T a, T n)</span> </span>&#123;</span><br><span class="line">    T x, y;</span><br><span class="line">    T gcd = ExtendedEuclidean(a, n, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span> (gcd != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gcd of "</span> &lt;&lt; a &lt;&lt; <span class="string">" and "</span> &lt;&lt; n &lt;&lt; <span class="string">" is "</span> &lt;&lt; gcd &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Combination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fact[n] * fact_inv[k] % kModulus * fact_inv[n - k] % kModulus;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Output</span><span class="params">(<span class="keyword">char</span> delimiter, <span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++seq_case &lt;&lt; <span class="string">":"</span> &lt;&lt; delimiter &lt;&lt; content &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputCurrentLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">' '</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OutputNewLine</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; content)</span> </span>&#123;</span><br><span class="line">    Output(<span class="string">'\n'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> seq_case = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; po2;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fact;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fact_inv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::OnlineJudge() &#123;</span><br><span class="line">  <span class="keyword">int</span> t;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    InputAndSolveSingleCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::InputAndSolveSingleCase() &#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  Solve(n, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::Solve(<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">  <span class="built_in">stringstream</span> ss;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> cur_sign = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    ans = (ans + cur_sign * Combination(<span class="number">2</span> * n - i, i) * fact[i] % kModulus *</span><br><span class="line">      po2[i] % kModulus * fact[<span class="number">2</span> * (n - i)] % kModulus * Combination(m, i) %</span><br><span class="line">      kModulus) % kModulus;</span><br><span class="line">    cur_sign = -cur_sign;</span><br><span class="line">  &#125;</span><br><span class="line">  ss &lt;&lt; (ans + kModulus) % kModulus;</span><br><span class="line">  OutputCurrentLine(ss.str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KickStartSolver::LocalTest() &#123;</span><br><span class="line">  Solve(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  Solve(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  Solve(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">  Solve(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">  Solve(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">unique_ptr</span>&lt;KickStartSolver&gt; solver(<span class="keyword">new</span> KickStartSolver);</span><br><span class="line">  <span class="comment">// solver-&gt;LocalTest();</span></span><br><span class="line">  solver-&gt;OnlineJudge();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="试水心得"><a href="#试水心得" class="headerlink" title="试水心得"></a>试水心得</h2><p>之前没刷过Kick Start，只刷过Code Jam，做下最新的题试下水。<br>感觉Kick Start整体难度比Code Jam简单不少。（大概是取样不够？）<br>最大的收获就是完善了这个KickStartSolver的类了，之后实操可以方便很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kick Start 2018 Round H&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：Google&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;1-Big-Buttons-9pts-13pts&quot;&gt;&lt;a href=&quot;#1-Big-Buttons-9pts-13pts&quot; class=&quot;headerlink&quot; title=&quot;1. Big Buttons (9pts, 13pts)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ee2/0000000000051136&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1. Big Buttons (9pts, 13pts)&lt;/a&gt;&lt;/h3&gt;&lt;h4 id=&quot;大致描述&quot;&gt;&lt;a href=&quot;#大致描述&quot; class=&quot;headerlink&quot; title=&quot;大致描述&quot;&gt;&lt;/a&gt;大致描述&lt;/h4&gt;&lt;p&gt;给定长度N和P个前缀，求只由“R”“B”组成的长度为N的且不以这P个前缀开头的字符串有多少种。&lt;br&gt;T组数据，范围1到100，P范围1到min(2^N, 100)，N范围小数据1到10，大数据1到50。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="其他" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="扩展欧几里得" scheme="http://tashi711.top/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="Google" scheme="http://tashi711.top/tags/Google/"/>
    
      <category term="容斥原理" scheme="http://tashi711.top/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    
      <category term="Kick Start" scheme="http://tashi711.top/tags/Kick-Start/"/>
    
      <category term="字典树" scheme="http://tashi711.top/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="组合数学" scheme="http://tashi711.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「扩展欧几里得算法」与「模逆元」详解</title>
    <link href="http://tashi711.top/programming/dsaa/extended-euclidean/"/>
    <id>http://tashi711.top/programming/dsaa/extended-euclidean/</id>
    <published>2019-02-08T03:17:59.000Z</published>
    <updated>2019-02-17T12:50:39.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>扩展欧几里得算法（Extended Euclidean algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足等式：ax + by = gcd(a, b)。</p><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>在数论中，裴蜀定理（Bézout’s lemma）是一个关于最大公约数的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和m，关于未知数x和y的线性丢番图方程（未知数只能使用整数的整数系数多项式等式）ax+by=m（称为裴蜀等式，Bézout’s identity）有整数解时当且仅当m是a及b的最大公约数d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数。</p><p>例如，12和42的最大公约数是6，则方程12x+42y=6有解。事实上有(-3)×12+1×42=6及4×12+(-1)×42=6。</p><p>特别来说，方程ax+by=1有整数解当且仅当整数a和b互素。</p><a id="more"></a><h3 id="扩展欧几里得求解过程"><a href="#扩展欧几里得求解过程" class="headerlink" title="扩展欧几里得求解过程"></a>扩展欧几里得求解过程</h3><p>有两个数a、b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。这就是扩展欧几里得的做法。</p><p>由辗转相除法可知gcd(a,b)=gcd(b,a%b)。所以由ax+by=gcd(a,b)可得bx*+(a%b)y*=gcd(a,b)。第二个式子变形可得ay*+b(x1-(a/b)×y*)=gcd(a,b)，则有x=y*，y=(x*-(a/b)×y*)。当b=0时，gcd(a,b)=a，则有1×a+0×b=0，即x=1，y=0。</p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ExtendedEuclidean</span><span class="params">(T a, T b, T* x, T* y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    *x = <span class="number">1</span>;</span><br><span class="line">    *y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    T gcd = ExtendedEuclidean(b, a % b, y, x);</span><br><span class="line">    *y -= *x * (a / b);</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模逆元"><a href="#模逆元" class="headerlink" title="模逆元"></a>模逆元</h2><p>模逆元也称为模倒数。一整数a对同余n之模逆元是指满足以下公式的整数b<br>$$a^{-1} \equiv b \; ({\rm mod} \; n)$$<br>也可以写成以下的式子<br>$$ab \equiv 1 \; ({\rm mod} \; n)$$<br>由上面提到的裴蜀定理，整数a对模数n之模逆元存在的充分必要条件是a和n互质，若此模逆元存在，在模数n下的除法可以用和对应模逆元的乘法来达成。之前写了一篇“「取余」那些事”，其中关于除法取余的部分就在此详述。通常实际中模数n为一个大质数（比如10^9+7），此时比模数小的任意正整数一定与n互质，逆元一定存在。</p><h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">ModularInverse</span><span class="params">(T a, T n)</span> </span>&#123;</span><br><span class="line">  T x, y;</span><br><span class="line">  T gcd = ExtendedEuclidean(a, n, &amp;x, &amp;y);</span><br><span class="line">  <span class="keyword">if</span> (gcd != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Gcd of "</span> &lt;&lt; a &lt;&lt; <span class="string">" and "</span> &lt;&lt; n &lt;&lt; <span class="string">" is "</span> &lt;&lt; gcd &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (x % n + n) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科 - 扩展欧几里得</a>.</li><li><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">维基百科 - 裴蜀定理</a>.</li><li><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">维基百科 - 模逆元</a>.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扩展欧几里得算法&quot;&gt;&lt;a href=&quot;#扩展欧几里得算法&quot; class=&quot;headerlink&quot; title=&quot;扩展欧几里得算法&quot;&gt;&lt;/a&gt;扩展欧几里得算法&lt;/h2&gt;&lt;p&gt;扩展欧几里得算法（Extended Euclidean algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足等式：ax + by = gcd(a, b)。&lt;/p&gt;
&lt;h3 id=&quot;裴蜀定理&quot;&gt;&lt;a href=&quot;#裴蜀定理&quot; class=&quot;headerlink&quot; title=&quot;裴蜀定理&quot;&gt;&lt;/a&gt;裴蜀定理&lt;/h3&gt;&lt;p&gt;在数论中，裴蜀定理（Bézout’s lemma）是一个关于最大公约数的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和m，关于未知数x和y的线性丢番图方程（未知数只能使用整数的整数系数多项式等式）ax+by=m（称为裴蜀等式，Bézout’s identity）有整数解时当且仅当m是a及b的最大公约数d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x、y都称为裴蜀数。&lt;/p&gt;
&lt;p&gt;例如，12和42的最大公约数是6，则方程12x+42y=6有解。事实上有(-3)×12+1×42=6及4×12+(-1)×42=6。&lt;/p&gt;
&lt;p&gt;特别来说，方程ax+by=1有整数解当且仅当整数a和b互素。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="扩展欧几里得" scheme="http://tashi711.top/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
      <category term="模逆元" scheme="http://tashi711.top/tags/%E6%A8%A1%E9%80%86%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>「取余」那些事</title>
    <link href="http://tashi711.top/programming/others/sth-about-module/"/>
    <id>http://tashi711.top/programming/others/sth-about-module/</id>
    <published>2019-02-05T03:17:59.000Z</published>
    <updated>2019-02-17T12:54:47.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="取余那些事"><a href="#取余那些事" class="headerlink" title="取余那些事"></a>取余那些事</h2><p>通常取余使用在数论中或者程序语言中。这里我们主要考虑C++中的取余操作。</p><h3 id="带余除法"><a href="#带余除法" class="headerlink" title="带余除法"></a>带余除法</h3><p><strong>定义：</strong>带余除法（也称为欧几里德除法）是数学中的一种基本算术计算方式。给定一个被除数a和一个除数b，带余除法给出一个整数q和一个介于一定范围的余数r，使得a=bq+r成立。一般限定余数的范围在0与b之间，也有限定在-b/2与b/2之间。这样的限定都是为了使得满足等式的q有且仅有一个。这时候的q称为带余除法的商。带余除法一般表示为：a÷b=q…r，表达为：“a除以b等于q，余r”。最常见的带余除法是整数与整数的带余除法（被除数a和除数b都是整数），但实数与整数乃至实数与实数的带余除法也有应用。对一般的抽象代数系统，能够进行带余除法的都是具有欧几里德性质的系统。如果余数为零，则称b整除a。一般约定除数b不能为0。</p><p><strong>基本定理：</strong>带余除法限定了余数的范围，使得商唯一存在。整数与整数的带余除法中，余数的范围通常是{0,1,…,|b|-1}这样的b个元素的集合。被除数为实数的带余除法中，常常会使用介于0和除数|b|之间（大于等于0，严格小于|b|）的半开闭区间作为余数的范围；另一种常见的范围是大于等于-|b|/2，严格小于|b|/2。带余除法的基本定理说明：整数与整数的带余除法中，只要余数的范围是|b|个整数，并且任何两个数之差都不是b的倍数，那么带余除法的商唯一存在；被除数为实数的除法中，只要余数的范围是一个如同长度为|b|的半开半闭区间，那么带余除法的商唯一存在。</p><a id="more"></a><h3 id="取余定义"><a href="#取余定义" class="headerlink" title="取余定义"></a>取余定义</h3><p>取余（modulo），又称取模、模除，是一个数除以另一个数的余数。</p><p><strong>一般定义：</strong>给定两个正整数：被除数a和除数n，a modulo n (缩写为a mod n)得到的是使用欧几里德除法时a/n的余数。 举个例子：计算表达式“5 mod 2”得到1，因为5÷2=2…1（5除以2商2余1）；而“9 mod 3”得到0，因为9÷3=3…0。</p><p>通常情况下a和n都是整数，但许多计算系统允许浮点数取模等。在C++中，“%”运算符只能作用于整数类型的取余运算，实数的取余使用<code>fmod</code>与<code>remainder</code>函数（C++11之后使用<code>std::fmod</code>与<code>std::remainder</code>），分别对应上面所述带余除法基本定理中的两种余数范围规定。本文主要考虑整数的取余，实数不多做介绍，有兴趣可以查阅相关资料。</p><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>数学上，同余（congruence modulo）是数论中的一种等价关系。当两个整数除以同一个正整数，若得相同余数，则二整数同余。同余是抽象代数中的同余关系的原型。最先引用同余的概念与同余符号“≡”者为德国数学家高斯。</p><p>两个整数a、b，若它们除以正整数m所得的余数相等，则称a、b对于模m同余，记作a ≡ b (mod m)，读作a同余于b模m，或读作a与b关于模m同余。比如26 ≡ 14 (mod 12)。</p><p>同余是离散数学乃至计算机科学的基础知识点，本文将直接使用同余的相关结论。</p><h3 id="加法取余"><a href="#加法取余" class="headerlink" title="加法取余"></a>加法取余</h3><p>用C++解决的实际问题中，通常考虑(正整数+正整数)%正整数，此时有<br>$$ (a+b)\%m \equiv (a\%m+b\%m)\%m $$<br>考虑一连串正整数的加法，最终和的结果取余等价于对每个加数取余后相加（的同时取余后再相加）的结果再取余。通常模数为10^n+m形式（比如10^9+7这样）的数字，不超过整数最大范围的一半，那么整个计算过程均可使用同样的类型而不需扩大。即所有加数都在int范围内，那么计算时可以全程使用int而无需使用long long，只需注意每次最多进行两个数相加，且每次结果必须取余。</p><h3 id="乘法取余"><a href="#乘法取余" class="headerlink" title="乘法取余"></a>乘法取余</h3><p>乘法与加法类似，用C++解决的实际问题中，通常考虑(正整数×正整数)%正整数，此时有<br>$$ (a×b)\%m \equiv (a\%m×b\%m)\%m $$<br>考虑一连串正整数的乘法，最终积的结果取余等价于对每个乘数取余后相乘（的同时取余后再相乘）的结果再取余。在乘法中，计算过程需要用到两倍size的类型来存放积的结果。比如int×int需要使用long long，且同样每次最多进行两个数相乘，每次结果必须取余。</p><h3 id="减法取余"><a href="#减法取余" class="headerlink" title="减法取余"></a>减法取余</h3><p>减法可以类比加法，但需注意即使考虑(正整数-正整数)%正整数，结果也可能为负数，此时就要考虑负数相关的取余操作了。</p><p>C++11以后规定，整除（/）的商一律向0取整（切除小数部分），如果m%n不等于0，则它的符号与m相同。令m和n是整数且n非0，除了-m导致溢出的特殊情况（C++中最小整数的负数仍是它本身，补码为100…0），其他任何时候，(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。比如：21/-5结果是-4，21%-5结果是1；-21/-8结果是2，-21%-8结果是-5。</p><p>此时回到我们的问题，(a-b)%m的结果就不一定等于(a%m-b%m)%m了，但是我们能知道(a-b)%m（令为u）是在-m到m之间，而(a%m-b%m)%m（令为v）也是在-m到m之间，并且他们要么相等，要么相差一个m（且此时他们一定不同符号。为什么？留给读者自行思考）。如果此时能够知道结果的符号，那么就可以确定正确答案了，比如当已知a大于b时，用(v+m)%m一定能得到u（这也是实际编程中最常遇到的情况与最常用的方式）。</p><p>同理，考虑一连串有正有负的加减运算最后取模，先计算出对其中每个参与运算的数字取余后再进行加减（的同时取余后再相加减）的结果再取余的这个数v，再根据实际判断是否需要加上或减去m得到正确结果。</p><h3 id="除法取余"><a href="#除法取余" class="headerlink" title="除法取余"></a>除法取余</h3><p>除法取余就没有以上三种运算那么容易了，毕竟不能对参与除法的运算数先分别取余后再相除（读者很容易就能想出反例），其实这部分内容涉及到互质、模逆元等等，我单独写一篇文章“「扩展欧几里得算法」与「模逆元」详解”来讲述这部分内容，此处不展开讨论了。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%B8%A6%E4%BD%99%E9%99%A4%E6%B3%95" target="_blank" rel="noopener">维基百科 - 带余除法</a>.</li><li><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4" target="_blank" rel="noopener">维基百科 - 模除</a>.</li><li><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98" target="_blank" rel="noopener">维基百科 - 同余</a>.</li><li>C++ Primer 5th.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;取余那些事&quot;&gt;&lt;a href=&quot;#取余那些事&quot; class=&quot;headerlink&quot; title=&quot;取余那些事&quot;&gt;&lt;/a&gt;取余那些事&lt;/h2&gt;&lt;p&gt;通常取余使用在数论中或者程序语言中。这里我们主要考虑C++中的取余操作。&lt;/p&gt;
&lt;h3 id=&quot;带余除法&quot;&gt;&lt;a href=&quot;#带余除法&quot; class=&quot;headerlink&quot; title=&quot;带余除法&quot;&gt;&lt;/a&gt;带余除法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;带余除法（也称为欧几里德除法）是数学中的一种基本算术计算方式。给定一个被除数a和一个除数b，带余除法给出一个整数q和一个介于一定范围的余数r，使得a=bq+r成立。一般限定余数的范围在0与b之间，也有限定在-b/2与b/2之间。这样的限定都是为了使得满足等式的q有且仅有一个。这时候的q称为带余除法的商。带余除法一般表示为：a÷b=q…r，表达为：“a除以b等于q，余r”。最常见的带余除法是整数与整数的带余除法（被除数a和除数b都是整数），但实数与整数乃至实数与实数的带余除法也有应用。对一般的抽象代数系统，能够进行带余除法的都是具有欧几里德性质的系统。如果余数为零，则称b整除a。一般约定除数b不能为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本定理：&lt;/strong&gt;带余除法限定了余数的范围，使得商唯一存在。整数与整数的带余除法中，余数的范围通常是{0,1,…,|b|-1}这样的b个元素的集合。被除数为实数的带余除法中，常常会使用介于0和除数|b|之间（大于等于0，严格小于|b|）的半开闭区间作为余数的范围；另一种常见的范围是大于等于-|b|/2，严格小于|b|/2。带余除法的基本定理说明：整数与整数的带余除法中，只要余数的范围是|b|个整数，并且任何两个数之差都不是b的倍数，那么带余除法的商唯一存在；被除数为实数的除法中，只要余数的范围是一个如同长度为|b|的半开半闭区间，那么带余除法的商唯一存在。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="其他" scheme="http://tashi711.top/categories/%E7%BC%96%E7%A8%8B/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="取余" scheme="http://tashi711.top/tags/%E5%8F%96%E4%BD%99/"/>
    
  </entry>
  
</feed>
