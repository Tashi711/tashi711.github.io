<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tashi711的博客</title>
  
  <subtitle>過去（きのう）に傷付きながらも、信じ続ける理想（ゆめ）を求める。いつか無限（なないろ）に輝き放って、青空（そら）に橋を描く。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tashi711.xyz/"/>
  <updated>2018-10-07T05:55:00.130Z</updated>
  <id>http://tashi711.xyz/</id>
  
  <author>
    <name>Tashi711</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「Γ函数」小结</title>
    <link href="http://tashi711.xyz/programming/notes/others/gamma-function/"/>
    <id>http://tashi711.xyz/programming/notes/others/gamma-function/</id>
    <published>2018-10-07T04:17:59.000Z</published>
    <updated>2018-10-07T05:55:00.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分治算法复杂度分析"><a href="#分治算法复杂度分析" class="headerlink" title="分治算法复杂度分析"></a>分治算法复杂度分析</h2><p>Γ函数，也叫做伽玛函数（Gamma函数），是阶乘函数在实数与复数域上的扩展。<br>此处给出一些常见结论。</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于实数部分为正的复数z，伽玛函数定义为：<br>$$\Gamma(z)=\int_0^{+\infty} {x^{z-1}e^{-x}} \,{\rm d}x$$<br>特别地，对于正实数s&gt;0，伽玛函数定义为：<br>$$\Gamma(s)=\int_0^{+\infty} {x^{s-1}e^{-x}} \,{\rm d}x$$<br>容易得到：<br>$$\Gamma(1)=1$$</p><h3 id="递推结论"><a href="#递推结论" class="headerlink" title="递推结论"></a>递推结论</h3><p>对于正实数s&gt;0：<br>$$\Gamma(s+1)=s\Gamma(s)$$<br>特别地，如果n为非负整数，则：<br>$$\Gamma(n+1)=n!\Gamma(1)=n!$$</p><h3 id="数值性质"><a href="#数值性质" class="headerlink" title="数值性质"></a>数值性质</h3><p>对非正整数，Γ函数没有定义。<br>如果n为非负整数，则：<br>$$\Gamma(\frac{1}{2}+n)=\frac{(2n-1)!!}{2^n}\sqrt{\pi}=\frac{(2n)!}{4^nn!}\sqrt{\pi}$$<br>$$\Gamma(\frac{1}{2}-n)=\frac{(-2)^n}{(2n-1)!!}\sqrt{\pi}=\frac{(-4)^nn!}{(2n)!}\sqrt{\pi}$$<br>特别地，n=0时：<br>$$\Gamma(\frac{1}{2})=\sqrt{\pi}$$<br>一些其他特殊值：<br>$$\Gamma(\frac{3}{2})=\frac{1}{2}\sqrt{\pi}$$<br>$$\Gamma(\frac{5}{2})=\frac{3}{4}\sqrt{\pi}$$<br>$$\Gamma(\frac{7}{2})=\frac{15}{8}\sqrt{\pi}$$<br>$$\Gamma(-\frac{1}{2})=-2\sqrt{\pi}$$<br>$$\Gamma(-\frac{3}{2})=\frac{3}{4}\sqrt{\pi}$$<br>$$\Gamma(-\frac{5}{2})=-\frac{8}{15}\sqrt{\pi}$$</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zh.wikipedia.org/wiki/%CE%93%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">Γ函数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分治算法复杂度分析&quot;&gt;&lt;a href=&quot;#分治算法复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;分治算法复杂度分析&quot;&gt;&lt;/a&gt;分治算法复杂度分析&lt;/h2&gt;&lt;p&gt;Γ函数，也叫做伽玛函数（Gamma函数），是阶乘函数在实数与复数域上的扩展。&lt;br&gt;此处给出一些常见结论。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Γ函数" scheme="http://tashi711.xyz/tags/%CE%93%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>「分治算法」复杂度分析</title>
    <link href="http://tashi711.xyz/programming/notes/others/divide-and-conquer/"/>
    <id>http://tashi711.xyz/programming/notes/others/divide-and-conquer/</id>
    <published>2018-10-07T03:17:59.000Z</published>
    <updated>2018-10-06T13:47:24.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分治算法复杂度分析"><a href="#分治算法复杂度分析" class="headerlink" title="分治算法复杂度分析"></a>分治算法复杂度分析</h2><p>最近遇到许多分治的算法题，而分治算法的复杂度估计在《数据结构与算法分析》这本书中进行了推导，有兴趣可以跟着推导一下，此处给出结论。</p><a id="more"></a><h3 id="分治方程"><a href="#分治方程" class="headerlink" title="分治方程"></a>分治方程</h3><p>$$T(N) = aT(N/b) + O(N^k\log^pN), (a≥1, b&gt;1, p≥1)$$</p><h3 id="解（结论）"><a href="#解（结论）" class="headerlink" title="解（结论）"></a>解（结论）</h3><p>$$T(N) =<br>\begin{cases}<br>O(N^{\log_ba}), &amp; a&gt;b^k \\<br>O(N^k\log^{p+1}N), &amp; a=b^k \\<br>O(N^k\log^pN), &amp; a&lt;b^k<br>\end{cases}$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分治算法复杂度分析&quot;&gt;&lt;a href=&quot;#分治算法复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;分治算法复杂度分析&quot;&gt;&lt;/a&gt;分治算法复杂度分析&lt;/h2&gt;&lt;p&gt;最近遇到许多分治的算法题，而分治算法的复杂度估计在《数据结构与算法分析》这本书中进行了推导，有兴趣可以跟着推导一下，此处给出结论。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="分治" scheme="http://tashi711.xyz/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>「ONE OK ROCK - Deeper Deeper」鑑賞</title>
    <link href="http://tashi711.xyz/nihongo/uta/oor-deeper-deeper/"/>
    <id>http://tashi711.xyz/nihongo/uta/oor-deeper-deeper/</id>
    <published>2018-10-06T17:03:54.000Z</published>
    <updated>2018-10-07T06:44:15.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="歌曲信息"><a href="#歌曲信息" class="headerlink" title="歌曲信息"></a>歌曲信息</h2><blockquote><ul><li>歌曲：Deeper Deeper</li><li>歌手：ONE OK ROCK</li><li>作词：Taka</li><li>作曲：Tomoya/Ryota</li><li>专辑：Deeper Deeper / Nothing Helps（2013年1月9日发行）</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OOR最喜欢的一首歌，没有之一。<br>标准日式摇滚。</p><a id="more"></a><h2 id="假名歌词"><a href="#假名歌词" class="headerlink" title="假名歌词"></a>假名歌词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Another step up, it&apos;s takin&apos; takin&apos; takin&apos; takin&apos; long</span><br><span class="line">Always digging, it&apos;s gettin&apos; getting&apos; getting&apos; get it on</span><br><span class="line">Wherever you stand just start to walk</span><br><span class="line">Everywhere you go goes round and round</span><br><span class="line">It&apos;s coming back to what I know</span><br><span class="line"></span><br><span class="line">The deep deep deeper we go</span><br><span class="line">Feeling alone, but it&apos;s oh so simple, let it go</span><br><span class="line">Dim dim dim the light&apos;s low</span><br><span class="line">But not blind, I can see the symbol, let it show</span><br><span class="line">Mighty story, don&apos;t hide it from me</span><br><span class="line">いつだって人（ひと）は迷（まよ）うんだって</span><br><span class="line">気付（きづ）いちゃったって知（し）らんぷりしていよう</span><br><span class="line">そしてgood good days</span><br><span class="line"></span><br><span class="line">僕（ぼく）らは生（う）まれてからso多（おお）くを学（まな）び</span><br><span class="line">死（し）に近（ちか）づくにつれて多（おお）くを忘（わす）れ</span><br><span class="line">気付（きづ）いた時（とき）にゃもう灰（はい）になってる</span><br><span class="line">生（い）きた証（あかし）を残（のこ）しておくにはモノじゃ無（な）くて</span><br><span class="line">「誰（だれ）かの記憶（きおく）に残（のこ）るような人生（じんせい）をお薦（すす）めします」</span><br><span class="line"></span><br><span class="line">The deep deep deeper we go</span><br><span class="line">Feeling alone, but it&apos;s oh so simple, let it go</span><br><span class="line">Dim dim dim the light&apos;s low</span><br><span class="line">But not blind, I can see the symbol, let it show</span><br><span class="line">Mighty story, don&apos;t hide it from me</span><br><span class="line">いつだって人（ひと）は迷（まよ）うんだって</span><br><span class="line">気付（きづ）いちゃったって知（し）らんぷりしていよう</span><br><span class="line">そしてgood good days</span><br><span class="line"></span><br><span class="line">物事（ものごと）にはsoどんな時（とき）だって</span><br><span class="line">オマケのノビシロがついていて</span><br><span class="line">何（なに）かを築（きず）きそして変（か）えて越（こ）えて</span><br><span class="line">奇跡（きせき）と言（い）う名（な）の必然（ひつぜん）を繰（く）り返（かえ）して</span><br><span class="line">上（うえ）へ</span><br><span class="line"></span><br><span class="line">We never we never we will not stop right here</span><br><span class="line"></span><br><span class="line">Do what you do gotta get through</span><br><span class="line">へたれてる時間（じかん）なんて微塵（みじん）も無（な）いぞ</span><br><span class="line">後悔（こうかい）しないように生（い）きる</span><br><span class="line">そんな風（ふう）に生（い）きたって悔（く）いは残（のこ）るさ</span><br><span class="line">長（なが）いものに巻（ま）かれて終（お）わる</span><br><span class="line">いやそれどころか巻（ま）いて終（お）わるのさ</span><br><span class="line">予測（よそく）すらできやしない猛（もう）スピードで</span><br><span class="line">ほらgood good bye</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;歌曲信息&quot;&gt;&lt;a href=&quot;#歌曲信息&quot; class=&quot;headerlink&quot; title=&quot;歌曲信息&quot;&gt;&lt;/a&gt;歌曲信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌曲：Deeper Deeper&lt;/li&gt;
&lt;li&gt;歌手：ONE OK ROCK&lt;/li&gt;
&lt;li&gt;作词：Taka&lt;/li&gt;
&lt;li&gt;作曲：Tomoya/Ryota&lt;/li&gt;
&lt;li&gt;专辑：Deeper Deeper / Nothing Helps（2013年1月9日发行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;OOR最喜欢的一首歌，没有之一。&lt;br&gt;标准日式摇滚。&lt;/p&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ウタ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%82%A6%E3%82%BF/"/>
    
    
      <category term="ONE OK ROCK" scheme="http://tashi711.xyz/tags/ONE-OK-ROCK/"/>
    
  </entry>
  
  <entry>
    <title>「913. Cat and Mouse」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-913/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-913/</id>
    <published>2018-10-04T03:57:02.000Z</published>
    <updated>2018-10-04T07:51:26.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/cat-and-mouse/description/" target="_blank" rel="noopener">913. Cat and Mouse</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>两个玩家分别扮演猫（Cat）和老鼠（Mouse）在无向图上进行游戏，他们轮流行动。<br>该图按下述规则给出：graph[a] 是所有结点 b 的列表，使得 ab 是图的一条边。<br>老鼠从结点 1 开始并率先出发，猫从结点 2 开始且随后出发，在结点 0 处有一个洞。<br>在每个玩家的回合中，他们必须沿着与他们所在位置相吻合的图的一条边移动。例如，如果老鼠位于结点 1，那么它只能移动到 graph[1] 中的（任何）结点去。<br>此外，猫无法移动到洞（结点 0）里。<br>然后，游戏在出现以下三种情形之一时结束：<br>如果猫和老鼠占据相同的结点，猫获胜。<br>如果老鼠躲入洞里，老鼠获胜。<br>如果某一位置重复出现（即轮到某一玩家移动时，该玩家与其之前某一回合处于同一位置），游戏平局。<br>给定 graph，并假设两个玩家都以最佳状态参与游戏，如果老鼠获胜，则返回 1；如果猫获胜，则返回 2；如果平局，则返回 0。</p><p><strong>示例：</strong><br>输入：[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]<br>输出：0<br>解释：<br>4—3—1<br>|   |<br>2—5<br> \ /<br>  0</p><p><strong>提示：</strong><br>3 &lt;= graph.length &lt;= 50<br>graph[1] 保证不为空。<br>graph[2] 中保证有一个非零的元素。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　按照题解的思路，进行宽搜即可。或者可以用DP父状态子状态的思维理解，考虑使用记忆化搜索。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^3)$。<br>　　空间复杂度为$O(N^2)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> d[kMaxN][kMaxN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, b, w;</span><br><span class="line">node(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>)</span><br><span class="line">: u(u), v(v), b(b), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catMouseGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(graph.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">a[i] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(graph[i].size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">d[i][j][<span class="number">0</span>] = a[i];</span><br><span class="line">d[i][j][<span class="number">1</span>] = a[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u : graph[j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (u == <span class="number">0</span>) &#123;</span><br><span class="line">d[i][j][<span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; ++b) &#123;</span><br><span class="line">f[<span class="number">0</span>][i][b] = <span class="number">1</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(<span class="number">0</span>, i, b, <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">f[i][i][b] = <span class="number">2</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(i, i, b, <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">node t = q.front();</span><br><span class="line"><span class="keyword">int</span> u = t.u, v = t.v, b = t.b, w = t.w;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : graph[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[i][v][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">1</span>) &#123;</span><br><span class="line">f[i][v][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(i, v, <span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">d[i][v][<span class="number">0</span>]--;</span><br><span class="line"><span class="keyword">if</span> (d[i][v][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">f[i][v][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(i, v, <span class="number">0</span>, <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : graph[v]) &#123;</span><br><span class="line"><span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; f[u][j][<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">2</span>) &#123;</span><br><span class="line">f[u][j][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(u, j, <span class="number">1</span>, <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">d[u][j][<span class="number">1</span>]--;</span><br><span class="line"><span class="keyword">if</span> (d[u][j][<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">f[u][j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(u, j, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/cat-and-mouse/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;913. Cat and Mouse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;两个玩家分别扮演猫（Cat）和老鼠（Mouse）在无向图上进行游戏，他们轮流行动。&lt;br&gt;该图按下述规则给出：graph[a] 是所有结点 b 的列表，使得 ab 是图的一条边。&lt;br&gt;老鼠从结点 1 开始并率先出发，猫从结点 2 开始且随后出发，在结点 0 处有一个洞。&lt;br&gt;在每个玩家的回合中，他们必须沿着与他们所在位置相吻合的图的一条边移动。例如，如果老鼠位于结点 1，那么它只能移动到 graph[1] 中的（任何）结点去。&lt;br&gt;此外，猫无法移动到洞（结点 0）里。&lt;br&gt;然后，游戏在出现以下三种情形之一时结束：&lt;br&gt;如果猫和老鼠占据相同的结点，猫获胜。&lt;br&gt;如果老鼠躲入洞里，老鼠获胜。&lt;br&gt;如果某一位置重复出现（即轮到某一玩家移动时，该玩家与其之前某一回合处于同一位置），游戏平局。&lt;br&gt;给定 graph，并假设两个玩家都以最佳状态参与游戏，如果老鼠获胜，则返回 1；如果猫获胜，则返回 2；如果平局，则返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br&gt;输入：[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]&lt;br&gt;输出：0&lt;br&gt;解释：&lt;br&gt;4—3—1&lt;br&gt;|   |&lt;br&gt;2—5&lt;br&gt; \ /&lt;br&gt;  0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;3 &amp;lt;= graph.length &amp;lt;= 50&lt;br&gt;graph[1] 保证不为空。&lt;br&gt;graph[2] 中保证有一个非零的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="BFS" scheme="http://tashi711.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>「878. Nth Magical Number」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-878/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-878/</id>
    <published>2018-09-30T03:57:02.000Z</published>
    <updated>2018-10-04T07:55:39.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/nth-magical-number/description/" target="_blank" rel="noopener">878. Nth Magical Number</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>A positive integer is magical if it is divisible by either A or B.<br>Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.</p><p><strong>Example 1:</strong><br>Input: N = 1, A = 2, B = 3<br>Output: 2</p><p><strong>Example 2:</strong><br>Input: N = 4, A = 2, B = 3<br>Output: 6</p><p><strong>Example 3:</strong><br>Input: N = 5, A = 2, B = 4<br>Output: 10</p><p><strong>Example 4:</strong><br>Input: N = 3, A = 6, B = 4<br>Output: 8</p><p><strong>Note:</strong><br>1 &lt;= N &lt;= 10^9<br>2 &lt;= A &lt;= 40000<br>2 &lt;= B &lt;= 40000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　第一反应就是二分答案，判定一个数x内有多少个Magical Number很容易，稍微容斥一下，即$$    \left\lfloor \frac{x}{A} + \frac{x}{B} - \frac{x}{lcm(A, B)}\right\rfloor$$<br>　　只需要二分$N*\min(A, B)$内的数即可，因为必有N个A或B。<br>　　其实之后才想到官方题解中复杂度更高的那个算法，也就是在每lcm(A, B)个数出现的Magical Number模式（个数）是一样的，因此可以看看lcm(A, B)内有多少个，然后取个模，枚举剩下的。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(\log (N*\min(A, B))$。<br>　　空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gcd(v, u % v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthMagicalNumber</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> u = <span class="number">0</span>, v = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(N) * min(A, B);</span><br><span class="line"><span class="keyword">int</span> lcm = A / gcd(A, B) * B;</span><br><span class="line"><span class="keyword">while</span> (u &lt; v) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m = u + (v - u) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (m / A + m / B - m / lcm &lt; N) &#123;</span><br><span class="line">u = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/nth-magical-number/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;878. Nth Magical Number&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;A positive integer is magical if it is divisible by either A or B.&lt;br&gt;Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;Input: N = 1, A = 2, B = 3&lt;br&gt;Output: 2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;Input: N = 4, A = 2, B = 3&lt;br&gt;Output: 6&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;br&gt;Input: N = 5, A = 2, B = 4&lt;br&gt;Output: 10&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 4:&lt;/strong&gt;&lt;br&gt;Input: N = 3, A = 6, B = 4&lt;br&gt;Output: 8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= N &amp;lt;= 10^9&lt;br&gt;2 &amp;lt;= A &amp;lt;= 40000&lt;br&gt;2 &amp;lt;= B &amp;lt;= 40000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="二分答案" scheme="http://tashi711.xyz/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>「887. Super Egg Drop」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-887/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-887/</id>
    <published>2018-09-29T03:57:02.000Z</published>
    <updated>2018-09-29T17:02:52.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/super-egg-drop/description/" target="_blank" rel="noopener">887. Super Egg Drop</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>You are given K eggs, and you have access to a building with N floors from 1 to N.<br>Each egg is identical in function, and if an egg breaks, you cannot drop it again.<br>You know that there exists a floor F with 0 &lt;= F &lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.<br>Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 &lt;= X &lt;= N).<br>Your goal is to know with certainty what the value of F is.<br>What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?</p><p><strong>Example 1:</strong><br>Input: K = 1, N = 2<br>Output: 2<br>Explanation:<br>Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.<br>Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.<br>If it didn’t break, then we know with certainty F = 2.<br>Hence, we needed 2 moves in the worst case to know what F is with certainty.</p><p><strong>Example 2:</strong><br>Input: K = 2, N = 6<br>Output: 3</p><p><strong>Example 3:</strong><br>Input: K = 3, N = 14<br>Output: 4</p><p><strong>Note:</strong><br>1 &lt;= K &lt;= 100<br>1 &lt;= N &lt;= 10000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　很容易想到一个暴力的DP，$O(KN^2)$。也就是$$dp(k, n)=\min_{1 \le x \le n}\lbrace dp(k-1, x-1), dp(k, x-k)\rbrace$$<br>　　虽然超时，但是我们能发现min项里面前者随着x增大而增大，后者随着x增大而减小，因此使用二分查找就可以找到恰当的x，复杂度可以被优化到$O(KN\log N)$，已经可以满足解决这道问题了。进一步想想还可以做优化，dp项随着n增大，取到最优的x也会随着增大，因此其实可以寻找当前x时从上个阶段最优的x开始，而不是从1开始，这样均摊复杂度就只有$O(KN)$了。<br>　　官方题解还给出了更加优化的算法可以达到$O(K\log N)$，有兴趣可以去看下，不过需要用到一些组合数学的推理，难度比较大，整体思想比较巧妙，他假设了另外一个问题，给定T次移动和K个鸡蛋，能够达到最大的层数f(T, K)是多少，于是问题变为找到最小的T使得f(T, K)≥N，而T又是可以二分查找的。　　</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　空间复杂度为$O(KN)$。<br>　　时间复杂度为$O(KN)$，因为只跟上一层子状态有关，如果使用滚动数组可以优化到$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">11000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxK = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxK][kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">f[<span class="number">1</span>][i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= K; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> u = max(f[i - <span class="number">1</span>][x - <span class="number">1</span>], f[i][j - x]);</span><br><span class="line"><span class="keyword">while</span> (x &lt; j &amp;&amp; u &gt; max(f[i - <span class="number">1</span>][x], f[i][j - x - <span class="number">1</span>])) &#123;</span><br><span class="line">x++;</span><br><span class="line">u = max(f[i - <span class="number">1</span>][x - <span class="number">1</span>], f[i][j - x]);</span><br><span class="line">&#125;</span><br><span class="line">f[i][j] = u + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[K][N];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/super-egg-drop/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;887. Super Egg Drop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;You are given K eggs, and you have access to a building with N floors from 1 to N.&lt;br&gt;Each egg is identical in function, and if an egg breaks, you cannot drop it again.&lt;br&gt;You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.&lt;br&gt;Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 &amp;lt;= X &amp;lt;= N).&lt;br&gt;Your goal is to know with certainty what the value of F is.&lt;br&gt;What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;Input: K = 1, N = 2&lt;br&gt;Output: 2&lt;br&gt;Explanation:&lt;br&gt;Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.&lt;br&gt;Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.&lt;br&gt;If it didn’t break, then we know with certainty F = 2.&lt;br&gt;Hence, we needed 2 moves in the worst case to know what F is with certainty.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;Input: K = 2, N = 6&lt;br&gt;Output: 3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;br&gt;Input: K = 3, N = 14&lt;br&gt;Output: 4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= K &amp;lt;= 100&lt;br&gt;1 &amp;lt;= N &amp;lt;= 10000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数学" scheme="http://tashi711.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分查找" scheme="http://tashi711.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>「891. Sum of Subsequence Widths」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-891/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-891/</id>
    <published>2018-09-18T03:57:02.000Z</published>
    <updated>2018-10-04T07:55:21.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/sum-of-subsequence-widths/description/" target="_blank" rel="noopener">891. Sum of Subsequence Widths</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an array of integers A, consider all non-empty subsequences of A.<br>For any sequence S, let the width of S be the difference between the maximum and minimum element of S.<br>Return the sum of the widths of all subsequences of A.<br>As the answer may be very large, return the answer modulo 10^9 + 7.</p><p><strong>Example 1:</strong><br>Input: [2,1,3]<br>Output: 6<br>Explanation:<br>Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].<br>The corresponding widths are 0, 0, 0, 1, 1, 2, 2.<br>The sum of these widths is 6.</p><p><strong>Note:</strong><br>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= 20000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　一开始还看错了题，以为子串必须是连续的，导致想了个很复杂的算法，其实这里的子串应该理解为子集。<br>　　第一步要能想到用所有最大值减所有最小值即可，第二步再想到跟顺序无关。于是排序以后遍历每个数，第i个数作为最大值和最小值的子区间都一目了然（2的i次方个和2的n-i-1次方个，i从0到n-1）。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度主要是排序的复杂度，即$O(N \log N)$。<br>　　空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">22000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">a[i] = (a[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumSubseqWidths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(A.size());</span><br><span class="line">pre(n);</span><br><span class="line">sort(A.begin(), A.end());</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">ans = (ans + A[i] * (a[i] - a[n - i - <span class="number">1</span>])) % kModule;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ans + kModule) % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/sum-of-subsequence-widths/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;891. Sum of Subsequence Widths&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;Given an array of integers A, consider all non-empty subsequences of A.&lt;br&gt;For any sequence S, let the width of S be the difference between the maximum and minimum element of S.&lt;br&gt;Return the sum of the widths of all subsequences of A.&lt;br&gt;As the answer may be very large, return the answer modulo 10^9 + 7.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;Input: [2,1,3]&lt;br&gt;Output: 6&lt;br&gt;Explanation:&lt;br&gt;Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].&lt;br&gt;The corresponding widths are 0, 0, 0, 1, 1, 2, 2.&lt;br&gt;The sum of these widths is 6.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;br&gt;1 &amp;lt;= A[i] &amp;lt;= 20000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
      <category term="数学" scheme="http://tashi711.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「906. Super Palindromes」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-906/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-906/</id>
    <published>2018-09-16T03:57:02.000Z</published>
    <updated>2018-09-16T05:45:54.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/super-palindromes/description/" target="_blank" rel="noopener">906. Super Palindromes</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　Let’s say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.<br>　　Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].</p><p>　　Example 1:<br>　　Input: L = “4”, R = “1000”<br>　　Output: 4<br>　　Explanation: 4, 9, 121, and 484 are superpalindromes.<br>　　Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.</p><p>　　Note:<br>　　1 &lt;= len(L) &lt;= 18<br>　　1 &lt;= len(R) &lt;= 18<br>　　L and R are strings representing integers in the range [1, 10^18).<br>　　int(L) &lt;= int(R)</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　先写了一个暴力的方法观察一下答案的特点，发现除了3以外的基数都是由0、1、2组成的，然后分析了一下发现确实，回文且平方不能进位，只有可能有0、1、2了，假设有3（除了就是3），那么一个数的3一定跟另一个数的3都乘成9，然后再做加法，就一定进位非回文了。于是想到枚举基数的一半（因为基数也是回文的），即最多4位。然后再枚举中间位，可能为空（偶数位）或者0、1、2，相当于枚举5位（当然，要注意首末位不能为0），最后判断平方是否回文即可，假设数的范围为N（long long内），那么位数L的规模为$O(\log N)$，验证回文的复杂度也最多$O(L)$，也不用占多大的空间。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　如上分析。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span> &amp;u, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &gt; n) &#123;</span><br><span class="line"><span class="built_in">string</span> tot = u + s + v;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(tot)</span></span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> now;</span><br><span class="line">ss &gt;&gt; now;</span><br><span class="line"><span class="keyword">if</span> (is_palindrome(now * now)) &#123;</span><br><span class="line">all.push_back(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'0'</span>; i &lt;= <span class="string">'2'</span>; ++i) &#123;</span><br><span class="line">dfs(p + <span class="number">1</span>, n, u + i, s, i + v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">all.push_back(<span class="number">1</span>);</span><br><span class="line">all.push_back(<span class="number">2</span>);</span><br><span class="line">all.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">string</span> s[] = &#123; <span class="string">""</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">dfs(<span class="number">2</span>, i, <span class="string">"1"</span>, s[j], <span class="string">"1"</span>);</span><br><span class="line">dfs(<span class="number">2</span>, i, <span class="string">"2"</span>, s[j], <span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line">adj.push_back(k % <span class="number">10</span>);</span><br><span class="line">k /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(adj.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (adj[i] != adj[n - i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superpalindromesInRange</span><span class="params">(<span class="built_in">string</span> L, <span class="built_in">string</span> R)</span> </span>&#123;</span><br><span class="line">pre();</span><br><span class="line"><span class="built_in">stringstream</span> s1, s2;</span><br><span class="line">s1 &lt;&lt; L;</span><br><span class="line">s2 &lt;&lt; R;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> u, v;</span><br><span class="line">s1 &gt;&gt; u;</span><br><span class="line">s2 &gt;&gt; v;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="built_in">sqrt</span>(u + <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">if</span> (a * a &lt; u) &#123;</span><br><span class="line">a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="built_in">sqrt</span>(v + <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> k : all) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt;= a &amp;&amp; k &lt;= b) &#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">// cout &lt;&lt; "tot: " &lt;&lt; ans &lt;&lt; ", cur: " &lt;&lt; k * k &lt;&lt; " (" &lt;&lt; k &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/super-palindromes/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;906. Super Palindromes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　Let’s say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.&lt;br&gt;　　Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: L = “4”, R = “1000”&lt;br&gt;　　Output: 4&lt;br&gt;　　Explanation: 4, 9, 121, and 484 are superpalindromes.&lt;br&gt;　　Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= len(L) &amp;lt;= 18&lt;br&gt;　　1 &amp;lt;= len(R) &amp;lt;= 18&lt;br&gt;　　L and R are strings representing integers in the range [1, 10^18).&lt;br&gt;　　int(L) &amp;lt;= int(R)&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「895. Maximum Frequency Stack」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-895/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-895/</id>
    <published>2018-09-14T03:57:02.000Z</published>
    <updated>2018-09-13T17:02:35.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/maximum-frequency-stack/description/" target="_blank" rel="noopener">895. Maximum Frequency Stack</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　implement FreqStack, a class which simulates the operation of a stack-like data structure.<br>　　FreqStack has two functions:<br>　　push(int x), which pushes an integer x onto the stack.<br>　　pop(), which removes and returns the most frequent element in the stack.<br>　　If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.</p><p>　　Example:<br>　　Input:<br>　　[“FreqStack”,”push”,”push”,”push”,”push”,”push”,”push”,”pop”,”pop”,”pop”,”pop”],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]<br>　　Output: [null,null,null,null,null,null,null,5,7,5,4]<br>　　Explanation:<br>　　After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top. Then:<br>　　pop() -&gt; returns 5, as 5 is the most frequent.<br>　　The stack becomes [5,7,5,7,4].<br>　　pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.<br>　　The stack becomes [5,7,5,4].<br>　　pop() -&gt; returns 5.<br>　　The stack becomes [5,7,4].<br>　　pop() -&gt; returns 4.<br>　　The stack becomes [5,7].</p><p>　　Note：<br>　　Calls to FreqStack.push(int x) will be such that 0 &lt;= x &lt;= 10^9.<br>　　It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements.<br>　　The total number of FreqStack.push calls will not exceed 10000 in a single test case.<br>　　The total number of FreqStack.pop calls will not exceed 10000 in a single test case.<br>　　The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　这道题有个非常巧妙的解法，可以实现单次push和pop都是$O(1)$的时间，我做完之后看官方题解是那样做的，这里先讲我自己的方法，巧妙的解法放在后面解题心得中。<br>　　首先想到push操作得记录好这个数的次数以及所有出现的位置（因为之后pop后要能追踪到上一个位置），这样用一个unordered_map&lt;int, vector<int>&gt;来保存，另外pop的时候要能找到最大的次数以及最顶端的位置，这样用一个map&lt;node, int&gt;来存，其中node是类似于pair的有序的二元组，保存着次数与位置。push与pop的时候互相更新就好了。</int></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　空间复杂度为$O(N)$。<br>　　单次push或pop的时间复杂度为$O(\log N)$（map的操作）。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">node(<span class="keyword">int</span> _cnt = <span class="number">0</span>, <span class="keyword">int</span> _pos = <span class="number">0</span>, <span class="keyword">int</span> _k = <span class="number">0</span>)</span><br><span class="line">: cnt(_cnt), pos(_pos), k(_k) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; r) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt != r.cnt) &#123;</span><br><span class="line"><span class="keyword">return</span> cnt &gt; r.cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos &gt; r.pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pos;</span><br><span class="line"><span class="built_in">map</span>&lt;node, <span class="keyword">int</span>&gt; f;</span><br><span class="line"></span><br><span class="line">FreqStack() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">pos[x].push_back(++idx);</span><br><span class="line"><span class="keyword">int</span> cur = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pos[x].size());</span><br><span class="line"><span class="keyword">if</span> (cur &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> pre = pos[x][cur - <span class="number">2</span>];</span><br><span class="line">f.erase(node(cur - <span class="number">1</span>, pre));</span><br><span class="line">&#125;</span><br><span class="line">f[node(cur, idx)] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max_c = f.begin()-&gt;first.cnt;</span><br><span class="line"><span class="keyword">int</span> cur_k = f.begin()-&gt;second;</span><br><span class="line">f.erase(f.begin());</span><br><span class="line">pos[cur_k].pop_back();</span><br><span class="line"><span class="keyword">if</span> (!pos[cur_k].empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> now_p = pos[cur_k].back();</span><br><span class="line">f[node(max_c - <span class="number">1</span>, now_p)] = cur_k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur_k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>　　看了下官方的题解，觉得非常巧妙，定义了数字到次数的map以及次数到栈的map，第k次对应的栈保存第k次入栈的元素，这样做的好处是，每个数字第k次出现都在第k个栈里，直接可以拿到，而且顺序又刚好是进栈的顺序，这样的map可以是无序的（hash map），因此无论是整体结构还是时间复杂度都优化了不少。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/maximum-frequency-stack/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;895. Maximum Frequency Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　implement FreqStack, a class which simulates the operation of a stack-like data structure.&lt;br&gt;　　FreqStack has two functions:&lt;br&gt;　　push(int x), which pushes an integer x onto the stack.&lt;br&gt;　　pop(), which removes and returns the most frequent element in the stack.&lt;br&gt;　　If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.&lt;/p&gt;
&lt;p&gt;　　Example:&lt;br&gt;　　Input:&lt;br&gt;　　[“FreqStack”,”push”,”push”,”push”,”push”,”push”,”push”,”pop”,”pop”,”pop”,”pop”],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]&lt;br&gt;　　Output: [null,null,null,null,null,null,null,5,7,5,4]&lt;br&gt;　　Explanation:&lt;br&gt;　　After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top. Then:&lt;br&gt;　　pop() -&amp;gt; returns 5, as 5 is the most frequent.&lt;br&gt;　　The stack becomes [5,7,5,7,4].&lt;br&gt;　　pop() -&amp;gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.&lt;br&gt;　　The stack becomes [5,7,5,4].&lt;br&gt;　　pop() -&amp;gt; returns 5.&lt;br&gt;　　The stack becomes [5,7,4].&lt;br&gt;　　pop() -&amp;gt; returns 4.&lt;br&gt;　　The stack becomes [5,7].&lt;/p&gt;
&lt;p&gt;　　Note：&lt;br&gt;　　Calls to FreqStack.push(int x) will be such that 0 &amp;lt;= x &amp;lt;= 10^9.&lt;br&gt;　　It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements.&lt;br&gt;　　The total number of FreqStack.push calls will not exceed 10000 in a single test case.&lt;br&gt;　　The total number of FreqStack.pop calls will not exceed 10000 in a single test case.&lt;br&gt;　　The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="栈" scheme="http://tashi711.xyz/tags/%E6%A0%88/"/>
    
      <category term="巧妙" scheme="http://tashi711.xyz/tags/%E5%B7%A7%E5%A6%99/"/>
    
  </entry>
  
  <entry>
    <title>「899. Orderly Queue」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-899/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-899/</id>
    <published>2018-09-13T03:57:02.000Z</published>
    <updated>2018-09-12T18:33:35.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/orderly-queue/description/" target="_blank" rel="noopener">899. Orderly Queue</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　A string S of lowercase letters is given.  Then, we may make any number of moves.<br>　　In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string.<br>　　Return the lexicographically smallest string we could have after any number of moves.</p><p>　　Example 1:<br>　　Input: S = “cba”, K = 1<br>　　Output: “acb”<br>　　Explanation:<br>　　In the first move, we move the 1st character (“c”) to the end, obtaining the string “bac”.<br>　　In the second move, we move the 1st character (“b”) to the end, obtaining the final result “acb”.</p><p>　　Example 2:<br>　　Input: S = “baaca”, K = 3<br>　　Output: “aaabc”<br>　　Explanation:<br>　　In the first move, we move the 1st character (“b”) to the end, obtaining the string “aacab”.<br>　　In the second move, we move the 3rd character (“c”) to the end, obtaining the final result “aaabc”.</p><p>　　Note:<br>　　1 &lt;= K &lt;= S.length &lt;= 1000<br>　　S consists of lowercase letters only.</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　说这是一道思考题是因为确实只要想通了编码上毫无难度。说这是一道水题是因为确实不难想通。<br>　　很容易想到如果K &gt; 1的时候可以实现任意连续位置的K个字母随意交换，具体做法就是先将要交换的K个字母放到最前面（将前面的字母依次移走），然后按照要交换的顺序将这K的字母移走，最后再依次移动其他字母直到这K个字母回到原先的这段位置。又容易想到如果能交换任意连续2个字母，可以做到（冒泡）排序。于是K &gt; 1时一定能达到所有字母从小到大排列。K = 1时也容易想到最优解就是枚举所有S.length种可能，找到最小的那个。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　令N为S.length。<br>　　空间复杂度为$O(N)$。<br>　　时间复杂度为$O(N^2)$，主要是K = 1时的复杂度，K &gt; 1时只需排序复杂度$O(N \log N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">orderlyQueue</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">ans = S;</span><br><span class="line"><span class="built_in">string</span> cur = S;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(S.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cur = cur.substr(<span class="number">1</span>) + cur[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (cur &lt; ans) &#123;</span><br><span class="line">ans = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans = S;</span><br><span class="line">sort(ans.begin(), ans.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/orderly-queue/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;899. Orderly Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　A string S of lowercase letters is given.  Then, we may make any number of moves.&lt;br&gt;　　In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string.&lt;br&gt;　　Return the lexicographically smallest string we could have after any number of moves.&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: S = “cba”, K = 1&lt;br&gt;　　Output: “acb”&lt;br&gt;　　Explanation:&lt;br&gt;　　In the first move, we move the 1st character (“c”) to the end, obtaining the string “bac”.&lt;br&gt;　　In the second move, we move the 1st character (“b”) to the end, obtaining the final result “acb”.&lt;/p&gt;
&lt;p&gt;　　Example 2:&lt;br&gt;　　Input: S = “baaca”, K = 3&lt;br&gt;　　Output: “aaabc”&lt;br&gt;　　Explanation:&lt;br&gt;　　In the first move, we move the 1st character (“b”) to the end, obtaining the string “aacab”.&lt;br&gt;　　In the second move, we move the 3rd character (“c”) to the end, obtaining the final result “aaabc”.&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= K &amp;lt;= S.length &amp;lt;= 1000&lt;br&gt;　　S consists of lowercase letters only.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://tashi711.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「902. Numbers At Most N Given Digit Set」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-902/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-902/</id>
    <published>2018-09-12T03:57:02.000Z</published>
    <updated>2018-10-04T07:53:51.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/numbers-at-most-n-given-digit-set/description/" target="_blank" rel="noopener">902. Numbers At Most N Given Digit Set</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　We have a sorted set of digits D, a non-empty subset of {‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}.  (Note that ‘0’ is not included.)<br>　　Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {‘1’,’3’,’5’}, we may write numbers such as ‘13’, ‘551’, ‘1351315’.<br>　　Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.</p><p>　　Example 1:<br>　　Input: D = [“1”,”3”,”5”,”7”], N = 100<br>　　Output: 20<br>　　Explanation:<br>　　The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</p><p>　　Example 2:<br>　　Input: D = [“1”,”4”,”9”], N = 1000000000<br>　　Output: 29523<br>　　Explanation:<br>　　We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.</p><p>　　Note:<br>　　D is a subset of digits ‘1’-‘9’ in sorted order.<br>　　1 &lt;= N &lt;= 10^9</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　最简单的模拟一下就好了，注意题目比较坑，他的描述容易被误解成每个数只能用D中的3个，其实那句话的意思是他举的例子是取了3个数（不然这道题其实暴力枚举也不会超时）。<br>　　那么就从头到尾扫，当前位置摆更小的数，后面就可以随意摆，当前位置正好摆相同的数（如果有），就扫到下一位做同样的判断累加。最后记得累加摆比N位数少的数的个数就好（任意摆），这个累和可以先初始化出来，包括D的size的所有次方。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(\log N)$，即N的位数，如果将D的size考虑为常数的话（不超过9）。<br>　　空间复杂度为$O(\log N)$，同理。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> sum[kMaxN];</span><br><span class="line"><span class="keyword">bool</span> have[kMaxN];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">a[i] = a[i - <span class="number">1</span>] * tot;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(have, <span class="number">0</span>, <span class="keyword">sizeof</span> have);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = s[p] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; u; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (have[i]) &#123;</span><br><span class="line">ans += a[n - p - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (have[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (p + <span class="number">1</span> == n) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dfs(s, p + <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atMostNGivenDigitSet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; D, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">tot = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(D.size());</span><br><span class="line">pre();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> s : D) &#123;</span><br><span class="line">have[s[<span class="number">0</span>] - <span class="string">'0'</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; N;</span><br><span class="line"><span class="built_in">string</span> n;</span><br><span class="line">ss &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(n.size());</span><br><span class="line">dfs(n, <span class="number">0</span>, len);</span><br><span class="line">ans += sum[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/numbers-at-most-n-given-digit-set/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;902. Numbers At Most N Given Digit Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　We have a sorted set of digits D, a non-empty subset of {‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}.  (Note that ‘0’ is not included.)&lt;br&gt;　　Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {‘1’,’3’,’5’}, we may write numbers such as ‘13’, ‘551’, ‘1351315’.&lt;br&gt;　　Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: D = [“1”,”3”,”5”,”7”], N = 100&lt;br&gt;　　Output: 20&lt;br&gt;　　Explanation:&lt;br&gt;　　The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.&lt;/p&gt;
&lt;p&gt;　　Example 2:&lt;br&gt;　　Input: D = [“1”,”4”,”9”], N = 1000000000&lt;br&gt;　　Output: 29523&lt;br&gt;　　Explanation:&lt;br&gt;　　We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　D is a subset of digits ‘1’-‘9’ in sorted order.&lt;br&gt;　　1 &amp;lt;= N &amp;lt;= 10^9&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="模拟" scheme="http://tashi711.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>「903. Valid Permutations for DI Sequence」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-903/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-903/</id>
    <published>2018-09-11T03:57:02.000Z</published>
    <updated>2018-09-11T15:47:18.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/valid-permutations-for-di-sequence/description/" target="_blank" rel="noopener">903. Valid Permutations for DI Sequence</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　We are given S, a length n string of characters from the set {‘D’, ‘I’}. (These letters stand for “decreasing” and “increasing”.)<br>　　A valid permutation is a permutation P[0], P[1], …, P[n] of integers {0, 1, …, n}, such that for all i:<br>　　If S[i] == ‘D’, then P[i] &gt; P[i+1], and;<br>　　If S[i] == ‘I’, then P[i] &lt; P[i+1].<br>　　How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.</p><p>　　Example:<br>　　Input: “DID”<br>　　Output: 5<br>　　Explanation:<br>　　The 5 valid permutations of (0, 1, 2, 3) are:<br>　　(1, 0, 3, 2)<br>　　(2, 0, 3, 1)<br>　　(2, 1, 3, 0)<br>　　(3, 0, 2, 1)<br>　　(3, 1, 2, 0)</p><p>　　Note:<br>　　1 &lt;= S.length &lt;= 200<br>　　S consists only of characters from the set {‘D’, ‘I’}.</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　因为很容易想到从子状态递推过去，典型的DP题。<br>　　用f[i][j]表示算到字符串第i个位置结尾为j的方案个数。<br>　　容易得到，如果当前S[i]为“D”，那么f[i][j] = sigma(f[i-1][k])，k从j到i，因为如果当前位置放j，那么等价的方案是前面放的1到j-1不变，j到i分别变成j+1到i+1，而需要的是前一个结尾为j+1到i+1的，那么枚举的k为j到i；同理，如果当前S[i]为“I”，那么f[i][j] = sigma(f[i-1][k])，k从1到j-1，因为需要的是前一个结尾为1到j-1（在等价方案中不变）。<br>　　容易想到初始状态为f[0][1] = 1，每次计算f[i][j]时j要从1枚举到i+1。<br>　　最终答案为sigma(f[n][i])，i从1到n+1。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　空间复杂度为状态复杂度，即$O(N^2)$。<br>　　时间复杂度为状态复杂度×转移复杂度，即$O(N^3)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">220</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_add_equal</span><span class="params">(<span class="keyword">int</span>&amp; s, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">s = (s + p) % kModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numPermsDISequence</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(S.size());</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">'\0'</span> + S;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> u = (s[i] == <span class="string">'D'</span> ? j : <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> v = (s[i] == <span class="string">'D'</span> ? i : j - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = u; k &lt;= v; ++k) &#123;</span><br><span class="line">my_add_equal(f[i][j], f[i - <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">my_add_equal(ans, f[n][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>　　看了下官方的题解，时间可以优化到N方，有个启发就是枚举k的时候其实都是连续的一段和，那么其实可以在枚举j之前先把f[i][1]到f[i][k]，k从1到i的累和算出来，之后可以直接用了（相减），时间就可以降一维。题解上说的是通过观察直接得到了没有累加的转移方程，其实自己琢磨一下那个方程会发现是有实际意义在里面的，道理差不多，利用连续和均摊复杂度。至于题解中的分治做法就没有太研究了，时间也可以到N方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/valid-permutations-for-di-sequence/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;903. Valid Permutations for DI Sequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　We are given S, a length n string of characters from the set {‘D’, ‘I’}. (These letters stand for “decreasing” and “increasing”.)&lt;br&gt;　　A valid permutation is a permutation P[0], P[1], …, P[n] of integers {0, 1, …, n}, such that for all i:&lt;br&gt;　　If S[i] == ‘D’, then P[i] &amp;gt; P[i+1], and;&lt;br&gt;　　If S[i] == ‘I’, then P[i] &amp;lt; P[i+1].&lt;br&gt;　　How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.&lt;/p&gt;
&lt;p&gt;　　Example:&lt;br&gt;　　Input: “DID”&lt;br&gt;　　Output: 5&lt;br&gt;　　Explanation:&lt;br&gt;　　The 5 valid permutations of (0, 1, 2, 3) are:&lt;br&gt;　　(1, 0, 3, 2)&lt;br&gt;　　(2, 0, 3, 1)&lt;br&gt;　　(2, 1, 3, 0)&lt;br&gt;　　(3, 0, 2, 1)&lt;br&gt;　　(3, 1, 2, 0)&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= S.length &amp;lt;= 200&lt;br&gt;　　S consists only of characters from the set {‘D’, ‘I’}.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「C++ Primer (5th) 第4章」小结</title>
    <link href="http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-4/"/>
    <id>http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-4/</id>
    <published>2018-09-11T03:17:59.000Z</published>
    <updated>2018-09-19T17:50:48.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-Primer-5th"><a href="#C-Primer-5th" class="headerlink" title="C++ Primer (5th)"></a>C++ Primer (5th)</h2><blockquote><ul><li>第一部分：C++基础</li><li>第4章</li></ul></blockquote><a id="more"></a><h3 id="第一部分：C-基础-第4章"><a href="#第一部分：C-基础-第4章" class="headerlink" title="第一部分：C++基础 (第4章)"></a>第一部分：C++基础 (第4章)</h3><ul><li><code>decltype</code>会判断左值与右值：假设<code>p</code>为<code>int*</code>，那么<code>decltype(*p)</code>为<code>int&amp;</code>，<code>decltype(&amp;p)</code>为<code>int**</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-Primer-5th&quot;&gt;&lt;a href=&quot;#C-Primer-5th&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer (5th)&quot;&gt;&lt;/a&gt;C++ Primer (5th)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：C++基础&lt;/li&gt;
&lt;li&gt;第4章&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「C++ Primer (5th) 第3章」小结</title>
    <link href="http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-3/"/>
    <id>http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-3/</id>
    <published>2018-09-11T03:17:59.000Z</published>
    <updated>2018-09-18T17:18:43.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-Primer-5th"><a href="#C-Primer-5th" class="headerlink" title="C++ Primer (5th)"></a>C++ Primer (5th)</h2><blockquote><ul><li>第一部分：C++基础</li><li>第3章</li></ul></blockquote><a id="more"></a><h3 id="第一部分：C-基础-第3章"><a href="#第一部分：C-基础-第3章" class="headerlink" title="第一部分：C++基础 (第3章)"></a>第一部分：C++基础 (第3章)</h3><ul><li><p>初始化时使用花括号但提供的值不能用来列表初始化，那么就会调用构造函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1&#123;<span class="number">10</span>&#125;; <span class="comment">// 10个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2(<span class="number">10</span>, <span class="string">"hi"</span>&#125;; <span class="comment">// 10个"hi"</span></span><br></pre></td></tr></table></figure></li><li><p><code>vector&lt;int&gt;</code>的size type为<code>vector&lt;int&gt;::size_type</code></p></li><li>容器是常量只能用const_iterator，不是的话iterator、const_iterator都可以用</li><li>如果对象是常量，begin、end返回const_iterator，否则是iterator，而cbegin、cend永远返回const_iterator</li><li>不能在for中、或者使用迭代器时push_back</li><li>可以相减的迭代器相减结果为difference_type（带符号整数）</li><li>数组不能用auto声明，元素只能是对象不能是引用（与vector一样）</li><li><p>数组的指针与引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> (*parr)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// parr指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;rarr)[<span class="number">10</span>] = arr;  <span class="comment">// rarr引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *(&amp;rptrs)[<span class="number">10</span>] = ptrs;  <span class="comment">// rptrs引用一个含有10个指针的数组</span></span><br></pre></td></tr></table></figure></li><li><p>auto 数组：指针</p></li><li>decltype(数组)：含有X个元素的数组</li><li>begin(数组)：指向首元素的指针，end(数组)：指向尾元素下一位置的指针</li><li>尾指针不能自增，指向之后的指针会出错</li><li>指针相减的type为ptrdiff_t，带符号</li><li>内置下标运算时有符的，标准库是无符的</li><li>c_str返回的的数组不一定一直有效，需拷贝</li><li>令<code>int a[3][4]</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : a) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : r) &#123;</span><br><span class="line">  <span class="comment">// c: 引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;r : a) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : r) &#123;</span><br><span class="line">  <span class="comment">// c: 非引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> r : a) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> c : r) &#123;</span><br><span class="line">  <span class="comment">// 无法编译，因为r为int*，那么内层循环没有意义</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = a; p != a + <span class="number">3</span>; ++p) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q) &#123;</span><br><span class="line">  <span class="comment">// *q</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = begin(a); p != end(a); ++p) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> q = begin(*p); q != end(*p); ++q) &#123;</span><br><span class="line">  <span class="comment">// *q</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> ia = <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ia[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (ia *p = a; p != a + <span class="number">3</span>; ++p) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q != *p + <span class="number">4</span>; ++q) &#123;</span><br><span class="line">  <span class="comment">// *q</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-Primer-5th&quot;&gt;&lt;a href=&quot;#C-Primer-5th&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer (5th)&quot;&gt;&lt;/a&gt;C++ Primer (5th)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：C++基础&lt;/li&gt;
&lt;li&gt;第3章&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「Effective C++ (3rd) 第一、二、三部分」小结</title>
    <link href="http://tashi711.xyz/programming/notes/effective-cpp/effective-cpp/"/>
    <id>http://tashi711.xyz/programming/notes/effective-cpp/effective-cpp/</id>
    <published>2018-09-08T03:17:59.000Z</published>
    <updated>2018-09-20T18:08:14.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-C-3rd"><a href="#Effective-C-3rd" class="headerlink" title="Effective C++ (3rd)"></a>Effective C++ (3rd)</h2><blockquote><ul><li>第一部分：Accustoming Yourself to C++</li><li>第二部分：Constructors, Destructors, and Assignment Operators</li><li>第三部分：Resource Management</li></ul></blockquote><a id="more"></a><h3 id="第一部分：Accustoming-Yourself-to-C"><a href="#第一部分：Accustoming-Yourself-to-C" class="headerlink" title="第一部分：Accustoming Yourself to C++"></a>第一部分：Accustoming Yourself to C++</h3><ul><li><p>使用enum定义常数不占空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; Num = <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> a[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>const xxx::iterator</code>相当于<code>T* const</code>，<code>xxx::const_iterator</code>相当于<code>const T*</code></p></li><li>mutable成员变量可以在const成员变量中改变</li><li><p>const与non-const成员函数避免代码重复，non-const调用const：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> <span class="comment">// same as before</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[position];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="comment">// now just calls const op[]</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;( <span class="comment">// cast away const on op[]’s return type;</span></span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>) <span class="comment">// add const to *this’s type;</span></span><br><span class="line">          [position] <span class="comment">// call const version of op[]</span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>成员变量总是以声明顺序初始化，与初始化列表顺序无关</p></li><li>因为跨编译单元初始化顺序问题，用local static代替non-local static对象</li></ul><h3 id="第二部分：Constructors-Destructors-and-Assignment-Operators"><a href="#第二部分：Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="第二部分：Constructors, Destructors, and Assignment Operators"></a>第二部分：Constructors, Destructors, and Assignment Operators</h3><ul><li>内含引用成员或const成员的类不能自动生成拷贝赋值函数</li><li>如果基类的拷贝赋值函数是为私有的，派生类不会自动生成拷贝赋值函数</li><li>为了删除自动生成的成员函数，可以声明为private或者继承有这样private成员函数的类</li><li>一般，类中有至少一个virtual时才把析构声明成virtual</li><li>使用纯虚析构可以让类成为纯虚类，但必须有虚构函数的定义</li><li>某些不是为了多态的基类（比如上面说的将成员函数声明为private来删除自动生成的成员函数）不应该声明virtual的析构。</li><li>析构函数不能抛出异常，如果析构函数中被调用的函数抛出异常，析构函数应该捕捉到，吞下它（不传播）或者结束程序（<code>std::abort()</code>）</li><li>构造、析构函数类不要调用virtual函数或者调用了virtual函数的函数，因为在子类构造时会先构造父类，此时virtual以及dynamic_cast都是父类的，为了防止访问还没有初始化的子类local的成员变量，析构同理</li><li>构造中使用的函数声明为static，防止使用未初始化的成员变量</li><li>赋值操作符返回<code>*this</code>的引用</li><li>确保赋值操作符在自我赋值时不会出错（比较两个对象的地址、先复制后delete、copy-and-swap）</li><li>copying函数（copy构造和copy赋值）应该确保base class的部分也复制</li><li>copy赋值函数中基类的赋值：<code>Base::operator=(rhs)</code></li><li>在某个copying函数里面不能调用另一个copying函数（可以写第三个函数、两者共同调用）</li></ul><h3 id="第三部分：Resource-Management"><a href="#第三部分：Resource-Management" class="headerlink" title="第三部分：Resource Management"></a>第三部分：Resource Management</h3><ul><li>RAII: auto_ptr（copy后指向null）、shared_ptr，这两者不能用于数组，因为是delete操作而不是delete[]操作</li><li>RAII的copy时要复制其管理的资源，可以：1、禁止复制（private）；2、引用计数（shared_ptr）；3、深度复制；4、转交拥有权（auto_ptr）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Effective-C-3rd&quot;&gt;&lt;a href=&quot;#Effective-C-3rd&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ (3rd)&quot;&gt;&lt;/a&gt;Effective C++ (3rd)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：Accustoming Yourself to C++&lt;/li&gt;
&lt;li&gt;第二部分：Constructors, Destructors, and Assignment Operators&lt;/li&gt;
&lt;li&gt;第三部分：Resource Management&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective-C/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「C++ Primer (5th) 第1、2章」小结</title>
    <link href="http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-1-2/"/>
    <id>http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-1-2/</id>
    <published>2018-09-06T03:17:59.000Z</published>
    <updated>2018-09-11T15:49:37.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-Primer-5th"><a href="#C-Primer-5th" class="headerlink" title="C++ Primer (5th)"></a>C++ Primer (5th)</h2><blockquote><ul><li>第一部分：C++基础</li><li>第1、2章</li></ul></blockquote><a id="more"></a><h3 id="第一部分：C-基础-第1、2章"><a href="#第一部分：C-基础-第1、2章" class="headerlink" title="第一部分：C++基础 (第1、2章)"></a>第一部分：C++基础 (第1、2章)</h3><ul><li>char不一定是signed char，可能是unsigned char</li><li>double有时比float效率更高</li><li>给一个无符号类型赋值超过其表示范围，得到的是取余的结果，但对有符号类型而言结果未定义，且程序可能崩溃</li><li>int与unsigned int的算术运算得到的是unsigned int</li><li>十进制的字面类型是int，八进制、十六进制的字面类型是能容纳其数值的int、unsigned int、long、unsigned long、long long、unsigned long long中尺寸最小者</li><li>初始化列表在存在信息丢失的风险时编译器会报错</li><li><p>显式访问全局变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ::x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;</span><br></pre></td></tr></table></figure></li><li><p>如果想在多个文件间共享const对象，必须在变量定义前也添加extern</p></li><li>非常量引用不能指向常量对象</li><li><p>引用的特殊情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = r1 * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> y = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = y; <span class="comment">// 等价于 const int t = y; const int &amp;r3 = t;</span></span><br></pre></td></tr></table></figure></li><li><p>顶层（top-level）const：指针等任意对象本身是常量</p></li><li>底层（low-level）const：指针所指的（包括引用）对象是const</li><li><code>constexpr int *q = nullptr</code>中q是一个指向整数的常量指针（与<code>const int *q</code>不同）</li><li><p>constexpr也可以指向常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</span><br></pre></td></tr></table></figure></li><li><p>typedef指针后const是常量指针而不是指向常量的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">const</span> p c; 等价于 <span class="keyword">char</span> *<span class="keyword">const</span> c;</span><br></pre></td></tr></table></figure></li><li><p>auto能在一条语句中声明多个变量，但只能是同一个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>, *p = &amp;i; <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">2</span>, k = <span class="number">3.14</span>; <span class="comment">// no</span></span><br></pre></td></tr></table></figure></li><li><p>auto引用是引用对象的类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a是一个整数</span></span><br></pre></td></tr></table></figure></li><li><p>auto会忽略顶层const，保留底层const：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i <span class="comment">// d是一个整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci <span class="comment">// e是一个指向整数常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci <span class="comment">// f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p = &amp;ci <span class="comment">// 是错的，因为i推演是int，&amp;ci推演是const int</span></span><br></pre></td></tr></table></figure></li><li><p><code>const int ci = 1, &amp;cj = ci;</code>中，<code>decltype(ci)</code>是const int、<code>decltype(cj)</code>是const int&amp;</p></li><li><code>int i = 1, *p = &amp;i, &amp;r = i;</code>中，<code>decltype(r + 0)</code>是int、<code>decltype(*p)</code>是int&amp;</li><li>如果给变量加上括号编译器会把其变为表达式，则会变为引用类型：<code>decltype(i)</code>是int，<code>decltype((i))</code>是int&amp;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-Primer-5th&quot;&gt;&lt;a href=&quot;#C-Primer-5th&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer (5th)&quot;&gt;&lt;/a&gt;C++ Primer (5th)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：C++基础&lt;/li&gt;
&lt;li&gt;第1、2章&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「854. K-Similar Strings」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-854/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-854/</id>
    <published>2018-08-28T03:57:02.000Z</published>
    <updated>2018-08-28T03:12:48.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/k-similar-strings/description/" target="_blank" rel="noopener">854. K-Similar Strings</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B.<br>　　Given two anagrams A and B, return the smallest K for which A and B are K-similar.</p><p>　　Example 1:<br>　　Input: A = “ab”, B = “ba”<br>　　Output: 1</p><p>　　Example 2:<br>　　Input: A = “abc”, B = “bca”<br>　　Output: 2</p><p>　　Example 3:<br>　　Input: A = “abac”, B = “baca”<br>　　Output: 2</p><p>　　Example 4:<br>　　Input: A = “aabc”, B = “abca”<br>　　Output: 2</p><p>　　Note:<br>　　1 &lt;= A.length == B.length &lt;= 20<br>　　A and B contain only lowercase letters from the set {‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’}</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　数据范围很小，考虑用回溯爆搜。<br>　　此处考虑两个剪枝：<br>　　一是最基本的当前累计交换次数达到目前的最优解就停止；<br>　　二是交换与顺序某种意义上是无关的，因此从前往后扫，遇到第一个不一样的位置就一定试着与后面所有可能的位置交换，将当前位置交换正确，再往后扫。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　因为爆搜的复杂度很难估计，尤其是有剪枝的时候，此处不展开分析，官方题解中有分析复杂度，可以参考。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> min_ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">++res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; min_ans &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">min_ans = ans;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans == min_ans) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] == a[j]) &#123;</span><br><span class="line">swap(a[i], a[j]);</span><br><span class="line">++ans;</span><br><span class="line">dfs(u + <span class="number">1</span>);</span><br><span class="line">--ans;</span><br><span class="line">swap(a[i], a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kSimilarity</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(A.size());</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">min_ans = <span class="number">20</span>;</span><br><span class="line">a = A;</span><br><span class="line">b = B;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> min_ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/k-similar-strings/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;854. K-Similar Strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　Strings A and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly K times so that the resulting string equals B.&lt;br&gt;　　Given two anagrams A and B, return the smallest K for which A and B are K-similar.&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: A = “ab”, B = “ba”&lt;br&gt;　　Output: 1&lt;/p&gt;
&lt;p&gt;　　Example 2:&lt;br&gt;　　Input: A = “abc”, B = “bca”&lt;br&gt;　　Output: 2&lt;/p&gt;
&lt;p&gt;　　Example 3:&lt;br&gt;　　Input: A = “abac”, B = “baca”&lt;br&gt;　　Output: 2&lt;/p&gt;
&lt;p&gt;　　Example 4:&lt;br&gt;　　Input: A = “aabc”, B = “abca”&lt;br&gt;　　Output: 2&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= A.length == B.length &amp;lt;= 20&lt;br&gt;　　A and B contain only lowercase letters from the set {‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’}&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="回溯" scheme="http://tashi711.xyz/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>「シド - バタフライエフェクト」鑑賞</title>
    <link href="http://tashi711.xyz/nihongo/uta/sid-butterfly-effect/"/>
    <id>http://tashi711.xyz/nihongo/uta/sid-butterfly-effect/</id>
    <published>2018-08-27T17:03:54.000Z</published>
    <updated>2018-08-28T02:43:30.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="歌曲信息"><a href="#歌曲信息" class="headerlink" title="歌曲信息"></a>歌曲信息</h2><blockquote><ul><li>歌曲：バタフライエフェクト</li><li>歌手：シド</li><li>作词：マオ</li><li>作曲：ゆうや</li><li>专辑：バタフライエフェクト（2017年5月10日由Ki/oon Music Inc.发行）</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近シド15周年发久违的新专，不过翻译一首去年的一直想翻译的非常好听的歌。</p><a id="more"></a><h2 id="假名歌词"><a href="#假名歌词" class="headerlink" title="假名歌词"></a>假名歌词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">通（とお）り雨（あめ）にうたれただけ　言（い）い聞（き）かせていた</span><br><span class="line">錆（さ）びたガラクタ　になるよりはましだと</span><br><span class="line">眠（ねむ）れない夜（よる）　瞑（つむ）る　怒（いか）り抱（だ）いて</span><br><span class="line"></span><br><span class="line">嵐（あらし）の前（まえ）のような　不適切（ふてきせつ）な　笑（え）み　浮（う）かべ</span><br><span class="line">その急所（きゅうしょ）を　狙（ねら）えよ</span><br><span class="line"></span><br><span class="line">空高（そらたか）くまで　助（たす）け　乞（こ）う声（こえ）</span><br><span class="line">今（いま）はまだ　届（とど）かない　そこに救（すく）いの手（て）もない</span><br><span class="line">賢者（けんじゃ）になれない　愚（おろ）かな君（きみ）</span><br><span class="line">頭（あたま）の中（なか）　溢（あふ）れ　イツカミテロ　溢（あふ）れだす</span><br><span class="line">何（なに）もかもを全（すべ）て　おれが捻（ね）じ曲（ま）げよう</span><br><span class="line"></span><br><span class="line">氷（こおり）が溶（と）ける音（おと）に　ただ　耳（みみ）を澄（す）ませてた</span><br><span class="line">我慢（がまん）のときを　じっと　楽（たの）しむように</span><br><span class="line">いつか来（く）る　朝（あさ）を　待（ま）ち望（のぞ）んで</span><br><span class="line"></span><br><span class="line">嫌悪（けんお）で　塗（ぬ）り潰（つぶ）す　少（すこ）しだけ　闇（やみ）　浮（う）かべ</span><br><span class="line">その隙（すき）みて　奪（うば）えよ</span><br><span class="line"></span><br><span class="line">空高（そらたか）くまで　助（たす）け　乞（こ）う声（こえ）</span><br><span class="line">今（いま）はまだ　届（とど）かない　そこに救（すく）いの手（て）もない</span><br><span class="line">賢者（けんじゃ）になれない　愚（おろ）かな君（きみ）</span><br><span class="line">頭（あたま）の中（なか）　溢（あふ）れ　イツカミテロ　溢（あふ）れだす</span><br><span class="line">何（なに）もかもを全（すべ）て　おれが捻（ね）じ曲（ま）げよう</span><br><span class="line"></span><br><span class="line">空高（そらたか）くまで　助（たす）け　乞（こ）う声（こえ）</span><br><span class="line">今（いま）はもう　届（とど）かない　そこに救（すく）いの手（て）もない</span><br><span class="line">賢者（けんじゃ）になれない　愚（おろ）かな君（きみ）</span><br><span class="line">頭（あたま）の中（なか）　溢（あふ）れ　イマニミテロ　溢（あふ）れだす</span><br><span class="line">何（なに）もかもを全（すべ）て　おれが捻（ね）じ曲（ま）げよう</span><br><span class="line">深紅（しんく）の羽（はね）　広（ひろ）げ　おれが変（か）えてみせよう</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;歌曲信息&quot;&gt;&lt;a href=&quot;#歌曲信息&quot; class=&quot;headerlink&quot; title=&quot;歌曲信息&quot;&gt;&lt;/a&gt;歌曲信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌曲：バタフライエフェクト&lt;/li&gt;
&lt;li&gt;歌手：シド&lt;/li&gt;
&lt;li&gt;作词：マオ&lt;/li&gt;
&lt;li&gt;作曲：ゆうや&lt;/li&gt;
&lt;li&gt;专辑：バタフライエフェクト（2017年5月10日由Ki/oon Music Inc.发行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近シド15周年发久违的新专，不过翻译一首去年的一直想翻译的非常好听的歌。&lt;/p&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ウタ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%82%A6%E3%82%BF/"/>
    
    
      <category term="シド" scheme="http://tashi711.xyz/tags/%E3%82%B7%E3%83%89/"/>
    
  </entry>
  
  <entry>
    <title>「850. Rectangle Area II」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-850/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-850/</id>
    <published>2018-06-10T03:57:02.000Z</published>
    <updated>2018-06-10T04:08:18.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/rectangle-area-ii/description/" target="_blank" rel="noopener">850. Rectangle Area II</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　给定N（1到200）个矩形，坐标范围在0到10^9，求这N个矩形覆盖的面积，结果对10^9+7取模，题目保证总的覆盖范围不超过2^63-1。<br>　　样例1：输入[[0,0,2,2],[1,0,2,3],[1,0,3,1]]，输出6。<br>　　样例2：输入[[0,0,1000000000,1000000000]]，输出49。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　数据范围很大，但分布很稀疏，比较裸的离散化了。</p><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>　　主要是判断离散化后的某个单独小块在原图中的面积比较麻烦，画个图就清楚了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^3)$。<br>　　空间复杂度为$O(N^2)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">220</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN][kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rectangles.size());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : rectangles) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">adj.push_back(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(adj.begin(), adj.end());</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="keyword">int</span> tot = n * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) &#123;</span><br><span class="line">f[adj[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : rectangles) &#123;</span><br><span class="line"><span class="keyword">int</span> ux = f[i[<span class="number">0</span>]], uy = f[i[<span class="number">1</span>]], vx = f[i[<span class="number">2</span>]], vy = f[i[<span class="number">3</span>]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ux; j &lt; vx; ++j) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = uy; k &lt; vy; ++k) &#123;</span><br><span class="line">a[j][k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">ans += <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(adj[i + <span class="number">1</span>] - adj[i]) * ((adj[j + <span class="number">1</span>] - adj[j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>这道题也能用二维线段树解，复杂度可以达到$O(N \log N)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/rectangle-area-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;850. Rectangle Area II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　给定N（1到200）个矩形，坐标范围在0到10^9，求这N个矩形覆盖的面积，结果对10^9+7取模，题目保证总的覆盖范围不超过2^63-1。&lt;br&gt;　　样例1：输入[[0,0,2,2],[1,0,2,3],[1,0,3,1]]，输出6。&lt;br&gt;　　样例2：输入[[0,0,1000000000,1000000000]]，输出49。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="离散化" scheme="http://tashi711.xyz/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>「843. Guess the Word」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-843/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-843/</id>
    <published>2018-06-08T12:39:10.000Z</published>
    <updated>2018-06-08T12:56:22.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/guess-the-word/description/" target="_blank" rel="noopener">843. Guess the Word</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　交互题目：<br>　　给定N（样例为4，测试数据为100）个不同单词的list，都是小写，6位长，采样随机，其中有一个是secret的，通过调用master.guess(word)可以猜词并返回word与secret单词匹配的个数（值和位置都要匹配），但word必须是给定的list里面的，否则返回-1。小于等于10次猜对即为正确。<br>　　样例：secret = “acckzz”，wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”]：<br>　　master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.<br>　　master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.<br>　　master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.<br>　　master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.<br>　　master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.<br>　　上面猜了5次，有一次猜对了，即为正确。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　尝试了随机的方法，即每次都取满足目前猜过的情况中随机的词猜，结果猜不出来，因此需要更加有启发性的算法。参考了题解，其中有一句非常精妙：每次都应该使得保留的词尽可能少。而这个值因为可能是跟目前猜的词匹配数为0到6的任意情况，因此要使得最坏的情况（匹配后留下最多的长度）最优（最少），那么可以先预处理出两两的匹配情况，每次猜词的时候选使得其他所有可能单词匹配最多的时候最少。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^2)$。<br>　　空间复杂度为$O(N^2)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kNumTry = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kLenStr = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; u, <span class="keyword">const</span> <span class="built_in">string</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kLenStr; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (u[i] == v[i]) &#123;</span><br><span class="line">++res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordlist)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">f[i][j] = match(wordlist[i], wordlist[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; adj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">-1</span>, min_max = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : adj) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt[kLenStr + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : adj) &#123;</span><br><span class="line">++cnt[f[i][j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur_max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= kLenStr; ++j) &#123;</span><br><span class="line">cur_max = max(cur_max, cnt[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur_max &lt; min_max) &#123;</span><br><span class="line">min_max = cur_max;</span><br><span class="line">res = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findSecretWord</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordlist, Master&amp; master)</span> </span>&#123;</span><br><span class="line">n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(wordlist.size());</span><br><span class="line">pre(wordlist);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">adj.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">1</span>; cnt &lt;= kNumTry; ++cnt) &#123;</span><br><span class="line"><span class="keyword">int</span> cur_idx = calc(adj);</span><br><span class="line"><span class="keyword">int</span> cur_match = master.guess(wordlist[cur_idx]);</span><br><span class="line"><span class="keyword">if</span> (cur_match == kLenStr) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : adj) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[cur_idx][i] == cur_match &amp;&amp; i != cur_idx) &#123;</span><br><span class="line">pos.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">adj = pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/guess-the-word/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;843. Guess the Word&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　交互题目：&lt;br&gt;　　给定N（样例为4，测试数据为100）个不同单词的list，都是小写，6位长，采样随机，其中有一个是secret的，通过调用master.guess(word)可以猜词并返回word与secret单词匹配的个数（值和位置都要匹配），但word必须是给定的list里面的，否则返回-1。小于等于10次猜对即为正确。&lt;br&gt;　　样例：secret = “acckzz”，wordlist = [“acckzz”,”ccbazz”,”eiowzz”,”abcczz”]：&lt;br&gt;　　master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist.&lt;br&gt;　　master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches.&lt;br&gt;　　master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches.&lt;br&gt;　　master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches.&lt;br&gt;　　master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches.&lt;br&gt;　　上面猜了5次，有一次猜对了，即为正确。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="交互题" scheme="http://tashi711.xyz/tags/%E4%BA%A4%E4%BA%92%E9%A2%98/"/>
    
  </entry>
  
</feed>
