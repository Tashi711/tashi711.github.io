<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tashi711的博客</title>
  
  <subtitle>過去（きのう）に傷付きながらも、信じ続ける理想（ゆめ）を求める。いつか無限（なないろ）に輝き放って、青空（そら）に橋を描く。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tashi711.xyz/"/>
  <updated>2019-01-22T16:29:57.147Z</updated>
  <id>http://tashi711.xyz/</id>
  
  <author>
    <name>Tashi711</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「LeetCode 968. Binary Tree Cameras」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-968/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-968/</id>
    <published>2019-01-23T03:57:03.000Z</published>
    <updated>2019-01-22T16:29:57.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/binary-tree-cameras/description/" target="_blank" rel="noopener">LeetCode 968. Binary Tree Cameras</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong><br>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。</p><p><strong>示例 2：</strong><br>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p><p><strong>提示：</strong><br>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实题不难，不过笔者思考的有点纠结。一开始看出是一道树形DP，但写着写着发现自己思维上的错误。<br>之后想着想着想到贪心是成立的，于是写了个贪心，也就是越往上靠越好，非常坎坷的过了。<br>建议可以看下官方题解，DP和贪心都是很简洁的思维。<br>另外说下空间，我这里用了他自带的没用的node的val变量，虽然省了空间，不过不算是很好的做法。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            dfs(p-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line">                cur = <span class="number">2</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left-&gt;val == <span class="number">2</span>) &#123;</span><br><span class="line">                cur = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            dfs(p-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line">                    cur = <span class="number">2</span>;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;right-&gt;val == <span class="number">2</span>) &#123;</span><br><span class="line">                    cur = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;val = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;left-&gt;val == <span class="number">0</span> ||</span><br><span class="line">                root-&gt;right &amp;&amp; root-&gt;right-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(root-&gt;left &amp;&amp; root-&gt;left-&gt;val == <span class="number">2</span> ||</span><br><span class="line">                root-&gt;right &amp;&amp; root-&gt;right-&gt;val == <span class="number">2</span>)) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">n1_r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n1_1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n1_2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n1_3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    n1_r.left = &amp;n1_1;</span><br><span class="line">    n1_1.left = &amp;n1_2;</span><br><span class="line">    n1_1.right = &amp;n1_3;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">n2_4</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    n2_r.left = &amp;n2_1;</span><br><span class="line">    n2_1.left = &amp;n2_2;</span><br><span class="line">    n2_2.left = &amp;n2_3;</span><br><span class="line">    n2_3.right = &amp;n2_4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.minCameraCover(&amp;n1_r) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.minCameraCover(&amp;n2_r) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/binary-tree-cameras/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 968. Binary Tree Cameras&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个二叉树，我们在树的节点上安装摄像头。&lt;br&gt;节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。&lt;br&gt;计算监控树的所有节点所需的最小摄像头数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[0,0,null,0,0]&lt;br&gt;输出：1&lt;br&gt;解释：如图所示，一台摄像头足以监控所有节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[0,0,null,0,null,0,null,null,0]&lt;br&gt;输出：2&lt;br&gt;解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;给定树的节点数的范围是 [1, 1000]。&lt;br&gt;每个节点的值都是 0。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="树形DP" scheme="http://tashi711.xyz/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="贪心" scheme="http://tashi711.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 52. N-Queens II」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-52/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-52/</id>
    <published>2019-01-13T03:57:03.000Z</published>
    <updated>2019-01-13T09:36:41.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/n-queens-ii/description/" target="_blank" rel="noopener">LeetCode 52. N-Queens II</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><p><strong>示例:</strong><br>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br>[<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>n皇后问题应该是比较经典的回溯题了，学回溯的时候应该都了解过位运算版。<br>总之就是因为np的问题阶层复杂度，那么输入规模最多也就十几，完全可以用一个数储存状态。<br>当然优化到极致就是每次枚举时都不是O(n)遍历而是直接取lowbit。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N!)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dale = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; ~(col | hill &gt;&gt; r | dale &gt;&gt; (n - <span class="number">1</span> - r));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur; now; now ^= cur) &#123;</span><br><span class="line">            cur = lowbit(now);</span><br><span class="line">            col |= cur;</span><br><span class="line">            hill |= cur &lt;&lt; r;</span><br><span class="line">            dale |= cur &lt;&lt; (n - <span class="number">1</span> - r);</span><br><span class="line">            dfs(r + <span class="number">1</span>, n);</span><br><span class="line">            col ^= cur;</span><br><span class="line">            hill ^= cur &lt;&lt; r;</span><br><span class="line">            dale ^= cur &lt;&lt; (n - <span class="number">1</span> - r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.totalNQueens(<span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/n-queens-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 52. N-Queens II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;br&gt;给定一个整数 n，返回 n 皇后不同的解决方案的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: 4&lt;br&gt;输出: 2&lt;br&gt;解释: 4 皇后问题存在如下两个不同的解法。&lt;br&gt;[&lt;br&gt; [“.Q..”,  // 解法 1&lt;br&gt;  “…Q”,&lt;br&gt;  “Q…”,&lt;br&gt;  “..Q.”],&lt;/p&gt;
&lt;p&gt; [“..Q.”,  // 解法 2&lt;br&gt;  “Q…”,&lt;br&gt;  “…Q”,&lt;br&gt;  “.Q..”]&lt;br&gt;]&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="回溯" scheme="http://tashi711.xyz/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 214. Shortest Palindrome」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-214/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-214/</id>
    <published>2019-01-13T03:57:03.000Z</published>
    <updated>2019-01-13T08:48:49.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/shortest-palindrome/description/" target="_blank" rel="noopener">LeetCode 214. Shortest Palindrome</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p><p><strong>示例 1:</strong><br>输入: “aacecaaa”<br>输出: “aaacecaaa”</p><p><strong>示例 2:</strong><br>输入: “abcd”<br>输出: “dcbabcd”</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实这道题不是很容易想出，因此之后遇到字符串的题目也可以得到启发，看能不能往KMP方向靠一靠。<br>这道题其实并不是一道字符串匹配的问题，但用到了KMP的思想，就是“深入理解”KMP当中的p数组。<br>也是就p[i]可以理解为“i位置结尾最多能匹配到从位置0开始的子串长度”，且p能线性得到。<br>于是答案就是”s+分隔符+reverse(s)”的p[最后位置]了，其中分隔符是为了防止s本身就是回文时全匹配了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> inited = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> sp;</span><br><span class="line">    <span class="keyword">int</span> nsp = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matched_idx;</span><br><span class="line"></span><br><span class="line">    KMP(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s = <span class="string">""</span>) &#123;</span><br><span class="line">        init(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        inited = <span class="literal">true</span>;</span><br><span class="line">        sp = s;</span><br><span class="line">        nsp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sp.size());</span><br><span class="line">        p.resize(nsp);</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nsp; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sp[j + <span class="number">1</span>] != sp[i]) &#123;</span><br><span class="line">                j = p[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sp[j + <span class="number">1</span>] == sp[i]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            p[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> rs = s;</span><br><span class="line">        reverse(rs.begin(), rs.end());</span><br><span class="line">        <span class="built_in">string</span> sp = s + <span class="string">"#"</span> + rs;</span><br><span class="line">        <span class="function">KMP <span class="title">kmp</span><span class="params">(sp)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> rs.substr(<span class="number">0</span>, n - kmp.p[<span class="number">2</span> * n] - <span class="number">1</span>) + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.shortestPalindrome(<span class="string">"aacecaaa"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.shortestPalindrome(<span class="string">"abcd"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/shortest-palindrome/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 214. Shortest Palindrome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: “aacecaaa”&lt;br&gt;输出: “aaacecaaa”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: “abcd”&lt;br&gt;输出: “dcbabcd”&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="KMP" scheme="http://tashi711.xyz/tags/KMP/"/>
    
      <category term="巧妙" scheme="http://tashi711.xyz/tags/%E5%B7%A7%E5%A6%99/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 164. Maximum Gap」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-164/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-164/</id>
    <published>2019-01-10T03:57:03.000Z</published>
    <updated>2019-01-09T16:19:49.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/maximum-gap/description/" target="_blank" rel="noopener">LeetCode 164. Maximum Gap</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>如果数组元素个数小于 2，则返回 0。</p><p><strong>示例 1:</strong><br>输入: [3,6,9,1]<br>输出: 3<br>解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</p><p><strong>示例 2:</strong><br>输入: [10]<br>输出: 0<br>解释: 数组元素个数小于 2，因此返回 0。</p><p><strong>说明:</strong><br>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较interview oriented的一道题目。<br>难得官方题解可以拜读下、而且难得cpp的max_element、partial_sum什么的学起来鸭。<br>先讲讲为什么可以优化、首先已知通过交换的排序是不会小于nlogn的。<br>但是呢、像基数排序之类的居然就可以做到线性、原因是这类排序利用了“数字”的“特性”，而不是单纯的比较大小。<br>会发现，这类排序只能用于整数，像浮点或者甚至一些复合类型就只能nlogn了。<br>基数排序被认为是线性的、基于基数（通常是10）和数的范围（int整型2^32）是常数规模。<br>数值范围这个规模其实还挺大，但是做的轮数是这个规模的log级别、因此还是可忽略的常数。<br>拓展：当数值规模与数量规模有关时（比如n的k次方，k为常数），那么可以在基数上做点文章。<br>比如取基数为n、因为只要基数是O(n)及以下、一轮（计数）排序还是线性的，但轮数就为常数k了。<br>此外、题解还有一只解法、思想相当巧妙、可以悟一下。<br>而那个解法优化点在于、他并没有做全部的排序、而是仅比较了需要能够得出正确解的轮次。<br>当然啦、最终这个解法是线性的还是基于数值规模是线性的、且不是log级别、是反函数。<br>那么其实稍微有点问题、n太小的时候可能还是会很慢、因此应该多一个特判（毕竟n小的话直接排序又不费功夫了）。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N)$。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> kRadix = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_num = *max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; aux(n);</span><br><span class="line">        <span class="keyword">while</span> (max_num / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(kRadix, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                count[(nums[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            partial_sum(count.cbegin(), count.cend(), count.begin());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                aux[--count[(nums[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            copy(aux.cbegin(), aux.cend(), nums.begin());</span><br><span class="line">            <span class="built_in">exp</span> *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ret = max(ret, nums[i + <span class="number">1</span>] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj1 = &#123; <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj2 = &#123; <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.maximumGap(adj1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.maximumGap(adj2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/maximum-gap/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 164. Maximum Gap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。&lt;br&gt;如果数组元素个数小于 2，则返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: [3,6,9,1]&lt;br&gt;输出: 3&lt;br&gt;解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: [10]&lt;br&gt;输出: 0&lt;br&gt;解释: 数组元素个数小于 2，因此返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。&lt;br&gt;请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="排序" scheme="http://tashi711.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 233. Number of Digit One」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-233/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-233/</id>
    <published>2019-01-04T03:57:03.000Z</published>
    <updated>2019-01-04T14:42:30.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/number-of-digit-one/description/" target="_blank" rel="noopener">LeetCode 233. Number of Digit One</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p><p><strong>示例:</strong><br>输入: 13<br>输出: 6<br>解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题解很清楚了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(\log N)$。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> div = i * <span class="number">10</span>;</span><br><span class="line">            cnt += (n / div) * i + min(max(n % div - i + <span class="number">1</span>, <span class="number">0L</span>L), i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution sol;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sol.countDigitOne(<span class="number">13</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/number-of-digit-one/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 233. Number of Digit One&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: 13&lt;br&gt;输出: 6&lt;br&gt;解释: 数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 943. Find the Shortest Superstring」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-943/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-943/</id>
    <published>2019-01-01T03:57:03.000Z</published>
    <updated>2019-01-09T14:21:39.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/find-the-shortest-superstring/description/" target="_blank" rel="noopener">LeetCode 943. Find the Shortest Superstring</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。<br>我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。</p><p><strong>示例 1：</strong><br>输入：[“alex”,”loves”,”leetcode”]<br>输出：”alexlovesleetcode”<br>解释：”alex”，”loves”，”leetcode” 的所有排列都会被接受。</p><p><strong>示例 2：</strong><br>输入：[“catg”,”ctaagt”,”gcta”,”ttca”,”atgcatc”]<br>输出：”gctaagttcatgcatc”</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 12<br>1 &lt;= A[i].length &lt;= 20</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴搜复杂度是阶乘的，状态数很小，其实就是用状压DP解一个类TSP问题。<br>题解基本说明白了，可以参考，不过边界问题处理的很奇怪，下面的代码改良了边界处理。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N^2(2^N+W))$，W为字符串长度的规模。<br>空间复杂度为 $O(N(2^N+W))$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shortestSuperstring</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; overlaps(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">1</span> &lt;&lt; n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fa(<span class="number">1</span> &lt;&lt; n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> si = A[i].size();</span><br><span class="line">                    <span class="keyword">int</span> sj = A[j].size();</span><br><span class="line">                    <span class="keyword">int</span> m = min(si, sj);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = m; k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (A[i].substr(si - k, k) == A[j].substr(<span class="number">0</span>, k)) &#123;</span><br><span class="line">                            overlaps[i][j] = k;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">1</span>; mask &lt; (<span class="number">1</span> &lt;&lt; n); ++mask) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> bit = <span class="number">0</span>; bit &lt; n; ++bit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((mask &gt;&gt; bit) &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> pmask = mask ^ (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">                    <span class="keyword">if</span> (pmask == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[mask][bit] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (((pmask &gt;&gt; i) &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> val = dp[pmask][i] + overlaps[i][bit];</span><br><span class="line">                            <span class="keyword">if</span> (val &gt; dp[mask][bit]) &#123;</span><br><span class="line">                                dp[mask][bit] = val;</span><br><span class="line">                                fa[mask][bit] = i;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][j] &gt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][p]) &#123;</span><br><span class="line">                p = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; perm;</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            perm.push_back(p);</span><br><span class="line">            <span class="keyword">int</span> fa_p = fa[mask][p];</span><br><span class="line">            mask ^= <span class="number">1</span> &lt;&lt; p;</span><br><span class="line">            p = fa_p;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(perm.begin(), perm.end());</span><br><span class="line">        <span class="built_in">string</span> ans = A[perm[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_overlap = overlaps[perm[i - <span class="number">1</span>]][perm[i]];</span><br><span class="line">            ans += (A[perm[i]].substr(cur_overlap));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj1 = &#123; <span class="string">"alex"</span>, <span class="string">"loves"</span>, <span class="string">"leetcode"</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj2 = &#123; <span class="string">"catg"</span>, <span class="string">"ctaagt"</span>, <span class="string">"gcta"</span>, <span class="string">"ttca"</span>, <span class="string">"atgcatc"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.shortestSuperstring(adj1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.shortestSuperstring(adj2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/find-the-shortest-superstring/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 943. Find the Shortest Superstring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。&lt;br&gt;我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[“alex”,”loves”,”leetcode”]&lt;br&gt;输出：”alexlovesleetcode”&lt;br&gt;解释：”alex”，”loves”，”leetcode” 的所有排列都会被接受。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[“catg”,”ctaagt”,”gcta”,”ttca”,”atgcatc”]&lt;br&gt;输出：”gctaagttcatgcatc”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 12&lt;br&gt;1 &amp;lt;= A[i].length &amp;lt;= 20&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="状态压缩DP" scheme="http://tashi711.xyz/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    
      <category term="TSP问题" scheme="http://tashi711.xyz/tags/TSP%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 964. Least Operators to Express Number」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-964/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-964/</id>
    <published>2018-12-30T03:57:03.000Z</published>
    <updated>2019-01-09T14:22:19.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/least-operators-to-express-number/description/" target="_blank" rel="noopener">LeetCode 964. Least Operators to Express Number</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个正整数 x，我们将会写出一个形如 x (op1) x (op2) x (op3) x … 的表达式，其中每个运算符 op1，op2，… 可以是加、减、乘、除（+，-，*，或是 /）之一。例如，对于 x = 3，我们可以写出表达式 3 * 3 / 3 + 3 - 3，该式的值为 3 。<br>在写这样的表达式时，我们需要遵守下面的惯例：<br>除运算符（/）返回有理数。<br>任何地方都没有括号。<br>我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。<br>不允许使用一元否定运算符（-）。例如，“x - x” 是一个有效的表达式，因为它只使用减法，但是 “-x + x” 不是，因为它使用了否定运算符。<br>我们希望编写一个能使表达式等于给定的目标值 target 且运算符最少的表达式。返回所用运算符的最少数量。</p><p><strong>示例 1：</strong><br>输入：x = 3, target = 19<br>输出：5<br>解释：3 * 3 + 3 * 3 + 3 / 3 。表达式包含 5 个运算符。</p><p><strong>示例 2：</strong><br>输入：x = 5, target = 501<br>输出：8<br>解释：5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5 。表达式包含 8 个运算符。</p><p><strong>示例 3：</strong><br>输入：x = 100, target = 100000000<br>输出：3<br>解释：100 * 100 * 100 * 100 。表达式包含 3 个运算符。</p><p><strong>提示：</strong><br>2 &lt;= x &lt;= 100<br>1 &lt;= target &lt;= 2 * 10^8</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较难的一道题，感觉题解也说的云里雾里，可以拜读下最高赞的答案，非常清晰，<br>作者还在comment里面写了例子，不太清楚可以看一下。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(\log_x N)$，N为target的规模。<br>空间复杂度为 $O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastOpsExpressTarget</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>, neg = <span class="number">0</span>, k, new_pos, new_neg, cur;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; target &gt; <span class="number">0</span>; ++k, target /= x) &#123;</span><br><span class="line">            cur = target % x;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                new_pos = min(cur * k + pos, (cur + <span class="number">1</span>) * k + neg);</span><br><span class="line">                new_neg = min((x - cur) * k + pos, (x - cur - <span class="number">1</span>) * k + neg);</span><br><span class="line">                pos = new_pos, neg = new_neg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pos = cur * <span class="number">2</span>;</span><br><span class="line">                neg = (x - cur) * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(pos, k + neg) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.leastOpsExpressTarget(<span class="number">3</span>, <span class="number">19</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.leastOpsExpressTarget(<span class="number">5</span>, <span class="number">501</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.leastOpsExpressTarget(<span class="number">100</span>, <span class="number">100000000</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/least-operators-to-express-number/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 964. Least Operators to Express Number&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个正整数 x，我们将会写出一个形如 x (op1) x (op2) x (op3) x … 的表达式，其中每个运算符 op1，op2，… 可以是加、减、乘、除（+，-，*，或是 /）之一。例如，对于 x = 3，我们可以写出表达式 3 * 3 / 3 + 3 - 3，该式的值为 3 。&lt;br&gt;在写这样的表达式时，我们需要遵守下面的惯例：&lt;br&gt;除运算符（/）返回有理数。&lt;br&gt;任何地方都没有括号。&lt;br&gt;我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。&lt;br&gt;不允许使用一元否定运算符（-）。例如，“x - x” 是一个有效的表达式，因为它只使用减法，但是 “-x + x” 不是，因为它使用了否定运算符。&lt;br&gt;我们希望编写一个能使表达式等于给定的目标值 target 且运算符最少的表达式。返回所用运算符的最少数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：x = 3, target = 19&lt;br&gt;输出：5&lt;br&gt;解释：3 * 3 + 3 * 3 + 3 / 3 。表达式包含 5 个运算符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：x = 5, target = 501&lt;br&gt;输出：8&lt;br&gt;解释：5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5 。表达式包含 8 个运算符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：x = 100, target = 100000000&lt;br&gt;输出：3&lt;br&gt;解释：100 * 100 * 100 * 100 。表达式包含 3 个运算符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;2 &amp;lt;= x &amp;lt;= 100&lt;br&gt;1 &amp;lt;= target &amp;lt;= 2 * 10^8&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 960. Delete Columns to Make Sorted III」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-960/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-960/</id>
    <published>2018-12-30T03:57:03.000Z</published>
    <updated>2018-12-30T14:22:55.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/delete-columns-to-make-sorted-iii/description/" target="_blank" rel="noopener">LeetCode 960. Delete Columns to Make Sorted III</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。<br>选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。<br>比如，有 A = [“babca”,”bbazb”]，删除索引序列 {0, 1, 4}，删除后 A 为[“bc”,”az”]。<br>假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组的行中的每个元素都是按字典序排列的。<br>清楚起见，A[0] 是按字典序排列的（即，A[0][0] &lt;= A[0][1] &lt;= … &lt;= A[0][A[0].length - 1]），A[1] 是按字典序排列的（即，A[1][0] &lt;= A[1][1] &lt;= … &lt;= A[1][A[1].length - 1]），依此类推。<br>请你返回 D.length 的最小可能值。</p><p><strong>示例 1：</strong><br>输入：[“babca”,”bbazb”]<br>输出：3<br>解释：<br>删除 0、1 和 4 这三列后，最终得到的数组是 A = [“bc”, “az”]。<br>这两行是分别按字典序排列的（即，A[0][0] &lt;= A[0][1] 且 A[1][0] &lt;= A[1][1]）。<br>注意，A[0] &gt; A[1] —— 数组 A 不一定是按字典序排列的。</p><p><strong>示例 2：</strong><br>输入：[“edcba”]<br>输出：4<br>解释：如果删除的列少于 4 列，则剩下的行都不会按字典序排列。</p><p><strong>示例 3：</strong><br>输入：[“ghi”,”def”,”abc”]<br>输出：0<br>解释：所有行都已按字典序排列。</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 100</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>挺简单的，就是一个“n维向量”的最长不下降子序列。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(NM^2)$。<br>空间复杂度为 $O(M)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; dp[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> s : A) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (check(A, i, j)) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj1 = &#123; <span class="string">"babca"</span>, <span class="string">"bbazb"</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj2 = &#123; <span class="string">"edcba"</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj3 = &#123; <span class="string">"ghi"</span>, <span class="string">"def"</span>, <span class="string">"abc"</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj4 = &#123; <span class="string">"abbba"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.minDeletionSize(adj1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.minDeletionSize(adj2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.minDeletionSize(adj3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.minDeletionSize(adj4) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/delete-columns-to-make-sorted-iii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 960. Delete Columns to Make Sorted III&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。&lt;br&gt;选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。&lt;br&gt;比如，有 A = [“babca”,”bbazb”]，删除索引序列 {0, 1, 4}，删除后 A 为[“bc”,”az”]。&lt;br&gt;假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组的行中的每个元素都是按字典序排列的。&lt;br&gt;清楚起见，A[0] 是按字典序排列的（即，A[0][0] &amp;lt;= A[0][1] &amp;lt;= … &amp;lt;= A[0][A[0].length - 1]），A[1] 是按字典序排列的（即，A[1][0] &amp;lt;= A[1][1] &amp;lt;= … &amp;lt;= A[1][A[1].length - 1]），依此类推。&lt;br&gt;请你返回 D.length 的最小可能值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[“babca”,”bbazb”]&lt;br&gt;输出：3&lt;br&gt;解释：&lt;br&gt;删除 0、1 和 4 这三列后，最终得到的数组是 A = [“bc”, “az”]。&lt;br&gt;这两行是分别按字典序排列的（即，A[0][0] &amp;lt;= A[0][1] 且 A[1][0] &amp;lt;= A[1][1]）。&lt;br&gt;注意，A[0] &amp;gt; A[1] —— 数组 A 不一定是按字典序排列的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[“edcba”]&lt;br&gt;输出：4&lt;br&gt;解释：如果删除的列少于 4 列，则剩下的行都不会按字典序排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：[“ghi”,”def”,”abc”]&lt;br&gt;输出：0&lt;br&gt;解释：所有行都已按字典序排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 100&lt;br&gt;1 &amp;lt;= A[i].length &amp;lt;= 100&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 135. Candy」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-135/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-135/</id>
    <published>2018-12-25T03:57:03.000Z</published>
    <updated>2018-12-28T17:07:07.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/candy/description/" target="_blank" rel="noopener">LeetCode 135. Candy</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>示例 1:</strong><br>输入: [1,0,2]<br>输出: 5<br>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</p><p><strong>示例 2:</strong><br>输入: [1,2,2]<br>输出: 4<br>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>可以参考题解2、3，挺巧妙的，4感觉想得太复杂了一点，虽然能优化空间。<br>写了一个比较麻烦的，但毕竟是自己第一个想到的解法：<br>用一个类似拓扑排序的思路，从“低”的点开始更新，然后尝试更新临点。<br>每个点最多尝试两次（两边临点更新时），所以均摊也是线性的复杂度。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N)$。<br>空间复杂度为 $O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ratings.size());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r(n + <span class="number">2</span>);</span><br><span class="line">        copy(ratings.begin(), ratings.end(), r.begin() + <span class="number">1</span>);</span><br><span class="line">        r[<span class="number">0</span>] = r[<span class="number">1</span>];</span><br><span class="line">        r[n + <span class="number">1</span>] = r[n];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n + <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        ans[<span class="number">0</span>] = ans[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; inq(n + <span class="number">2</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r[i] &lt;= r[i - <span class="number">1</span>] &amp;&amp; r[i] &lt;= r[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ans[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inq[i - <span class="number">1</span>] &amp;&amp; ans[i - <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.push(i - <span class="number">1</span>);</span><br><span class="line">                    inq[i - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!inq[i + <span class="number">1</span>] &amp;&amp; ans[i + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.push(i + <span class="number">1</span>);</span><br><span class="line">                    inq[i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            inq[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans[u] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> now = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (r[u] &gt; r[u - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[u - <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    now = max(now, ans[u - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r[u] &gt; r[u + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[u + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    now = max(now, ans[u + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[u] = now;</span><br><span class="line">            <span class="keyword">if</span> (!inq[u - <span class="number">1</span>] &amp;&amp; ans[u - <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                q.push(u - <span class="number">1</span>);</span><br><span class="line">                inq[u - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!inq[u + <span class="number">1</span>] &amp;&amp; ans[u + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                q.push(u + <span class="number">1</span>);</span><br><span class="line">                inq[u + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(ans.begin() + <span class="number">1</span>, ans.end() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj1 = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.candy(adj1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.candy(adj2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/candy/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 135. Candy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。&lt;br&gt;你需要按照以下要求，帮助老师给这些孩子分发糖果：&lt;br&gt;每个孩子至少分配到 1 个糖果。&lt;br&gt;相邻的孩子中，评分高的孩子必须获得更多的糖果。&lt;br&gt;那么这样下来，老师至少需要准备多少颗糖果呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: [1,0,2]&lt;br&gt;输出: 5&lt;br&gt;解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: [1,2,2]&lt;br&gt;输出: 4&lt;br&gt;解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="巧妙" scheme="http://tashi711.xyz/tags/%E5%B7%A7%E5%A6%99/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 128. Longest Consecutive Sequence」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-128/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-128/</id>
    <published>2018-12-25T03:57:03.000Z</published>
    <updated>2018-12-27T13:57:02.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/longest-consecutive-sequence/description/" target="_blank" rel="noopener">LeetCode 128. Longest Consecutive Sequence</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个未排序的整数数组，找出最长连续序列的长度。<br>要求算法的时间复杂度为 O(n)。</p><p><strong>示例:</strong><br>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>感觉在玩文字游戏，这个O(n)。<br>其实第一反应基数排序之类的不也能实现吗，认为数位是常数（准确说是log(n)）？<br>用c++的unordered_set做了下。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N)$。<br>空间复杂度为 $O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(u - <span class="number">1</span>) == s.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (s.find(u + cnt) != s.end()) &#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj = &#123; <span class="number">100</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.longestConsecutive(adj) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>1、因为（可能但没必要？）的内存泄漏问题，之后的代码都用Solution s代替new。<br>2、之后的代码制表符都换为4个空格，缩进格式基本保持VS风。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/longest-consecutive-sequence/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 128. Longest Consecutive Sequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个未排序的整数数组，找出最长连续序列的长度。&lt;br&gt;要求算法的时间复杂度为 O(n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: [100, 4, 200, 1, 3, 2]&lt;br&gt;输出: 4&lt;br&gt;解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 140. Word Break II」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-140/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-140/</id>
    <published>2018-12-25T03:57:03.000Z</published>
    <updated>2018-12-29T19:11:51.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/word-break-ii/description/" target="_blank" rel="noopener">LeetCode 140. Word Break II</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><p><strong>说明：</strong><br>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><p><strong>示例 1：</strong><br>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]</p><p><strong>示例 2：</strong><br>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。</p><p><strong>示例 3：</strong><br>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>挺搞的一道题，首先没给数据范围所以也摸不透考点，题解又被吞掉了。<br>看了下居然暴力加点优化居然能过，而且最近刚好复习了KMP，想着用KMP先预处理然后暴力一下。<br>于是发现超时了（超时的数据在下面程序的main中给出了），可见暴力肯定超。<br>得出结论确实要用那个记录子状态的优化，甚至KMP与暴力匹配的差别可以忽略不计。<br>后来发现如果把返回的字符串数组看作是一个值的话，这不就是一个DP吗。<br>当然我更愿意叫它“记忆化搜索”，因为不是用的迭代，而且搜索位置随机。<br>思路跟那个最高赞回答一样，可以看下。<br>如果完全把原字符串长度当成一维N，字典单词数量当成一维M，<br>不考虑字符串间的操作复杂度（匹配、连接、各种拷贝等，当然匹配可以预处理），时间可以认为是单纯的DP复杂度O(NM)的。<br>空间就跟问题数据有关了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(NM)$。<br>空间复杂度为 $O(tN)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> inited = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> sp;</span><br><span class="line">    <span class="keyword">int</span> nsp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matched_idx;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        inited = <span class="literal">true</span>;</span><br><span class="line">        sp = s;</span><br><span class="line">        nsp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sp.size());</span><br><span class="line">        p.resize(nsp);</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nsp; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sp[j + <span class="number">1</span>] != sp[i]) &#123;</span><br><span class="line">                j = p[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sp[j + <span class="number">1</span>] == sp[i]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            p[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!inited) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not inited!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        matched_idx.clear();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sp[j + <span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">                j = p[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sp[j + <span class="number">1</span>] == s[i]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                <span class="keyword">if</span> (j == nsp - <span class="number">1</span>) &#123;</span><br><span class="line">                    matched_idx.push_back(i - nsp + <span class="number">1</span>);</span><br><span class="line">                    j = p[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_matched_idx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(matched_idx.size()); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; matched_idx[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; f;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vst;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dfs(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict, <span class="keyword">int</span> p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="string">""</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vst[p]) &#123;</span><br><span class="line">            <span class="keyword">return</span> f[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx : adj[p]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> dfs_res = dfs(wordDict, p + len[idx]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : dfs_res) &#123;</span><br><span class="line">                res.push_back(wordDict[idx] + (s.empty() ? <span class="string">""</span> : <span class="string">" "</span>) + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vst[p] = <span class="literal">true</span>;</span><br><span class="line">        f[p] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict) &#123;</span><br><span class="line">        n = s.size();</span><br><span class="line">        m = wordDict.size();</span><br><span class="line">        len.clear();</span><br><span class="line">        len.resize(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            len[i] = wordDict[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">        adj.clear();</span><br><span class="line">        adj.resize(n);</span><br><span class="line">        KMP kmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            kmp.init(wordDict[i]);</span><br><span class="line">            kmp.match(s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> idx : kmp.matched_idx) &#123;</span><br><span class="line">                adj[idx].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f.clear();</span><br><span class="line">        f.resize(n);</span><br><span class="line">        vst.clear();</span><br><span class="line">        vst.resize(n, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_ans</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : ans) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"catsanddog"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj1 = &#123; <span class="string">"cat"</span>, <span class="string">"cats"</span>, <span class="string">"and"</span>, <span class="string">"sand"</span>, <span class="string">"dog"</span> &#125;;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"pineapplepenapple"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj2 = &#123; <span class="string">"apple"</span>, <span class="string">"pen"</span>, <span class="string">"applepen"</span>, <span class="string">"pine"</span>, <span class="string">"pineapple"</span> &#125;;</span><br><span class="line">    <span class="built_in">string</span> s3 = <span class="string">"catsandog"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj3 = &#123; <span class="string">"cats"</span>, <span class="string">"dog"</span>, <span class="string">"sand"</span>, <span class="string">"and"</span>, <span class="string">"cat"</span> &#125;;</span><br><span class="line">    <span class="built_in">string</span> s4 = <span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; adj4 = &#123; <span class="string">"a"</span>, <span class="string">"aa"</span>, <span class="string">"aaa"</span>, <span class="string">"aaaa"</span>, <span class="string">"aaaaa"</span>, <span class="string">"aaaaaa"</span>, <span class="string">"aaaaaaa"</span>, <span class="string">"aaaaaaaa"</span>, <span class="string">"aaaaaaaaa"</span>, <span class="string">"aaaaaaaaaa"</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> ans1 = s.wordBreak(s1, adj1);</span><br><span class="line">    <span class="keyword">auto</span> ans2 = s.wordBreak(s2, adj2);</span><br><span class="line">    <span class="keyword">auto</span> ans3 = s.wordBreak(s3, adj3);</span><br><span class="line">    <span class="keyword">auto</span> ans4 = s.wordBreak(s4, adj4);</span><br><span class="line">    check_ans(ans1);</span><br><span class="line">    check_ans(ans2);</span><br><span class="line">    check_ans(ans3);</span><br><span class="line">    check_ans(ans4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/word-break-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 140. Word Break II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br&gt;分隔时可以重复使用字典中的单词。&lt;br&gt;你可以假设字典中没有重复的单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入:&lt;br&gt;s = “catsanddog”&lt;br&gt;wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]&lt;br&gt;输出:&lt;br&gt;[&lt;br&gt;  “cats and dog”,&lt;br&gt;  “cat sand dog”&lt;br&gt;]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入:&lt;br&gt;s = “pineapplepenapple”&lt;br&gt;wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]&lt;br&gt;输出:&lt;br&gt;[&lt;br&gt;  “pine apple pen apple”,&lt;br&gt;  “pineapple pen apple”,&lt;br&gt;  “pine applepen apple”&lt;br&gt;]&lt;br&gt;解释: 注意你可以重复使用字典中的单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入:&lt;br&gt;s = “catsandog”&lt;br&gt;wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]&lt;br&gt;输出:&lt;br&gt;[]&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="KMP" scheme="http://tashi711.xyz/tags/KMP/"/>
    
      <category term="记忆化搜索" scheme="http://tashi711.xyz/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 145. Binary Tree Postorder Traversal」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-145/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-145/</id>
    <published>2018-12-25T03:57:03.000Z</published>
    <updated>2018-12-30T06:42:05.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">LeetCode 145. Binary Tree Postorder Traversal</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个二叉树，返回它的 后序 遍历。</p><p><strong>示例:</strong><br>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3<br>输出: [3,2,1]</p><p><strong>进阶:</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>也挺搞，OJ没有算法，“分奴”做法也能AC。<br>不过既然都Hard了，还是尊重下题目。<br>理解下栈其实就很好解了。<br>这里有个<strong>拓展思路：</strong>下面程序中有个res.push_back(u-&gt;val)的地方，<br>如果换下这条语句位置其实可以直接实现先序、中序的版本（思考下？应该不难）。<br>注意判断输入可能为空即可。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(NM)$。<br>空间复杂度为 $O(tN)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            res.push_back(u-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;left) &#123;</span><br><span class="line">                s.push(u-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;right) &#123;</span><br><span class="line">                s.push(u-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    TreeNode *p1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode *p2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *p3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    p1-&gt;right = p2;</span><br><span class="line">    p2-&gt;left = p3;</span><br><span class="line">    <span class="keyword">auto</span> ans = s.postorderTraversal(p1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : ans) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/binary-tree-postorder-traversal/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 145. Binary Tree Postorder Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个二叉树，返回它的 后序 遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: [1,null,2,3]&lt;br&gt;   1&lt;br&gt;    \&lt;br&gt;     2&lt;br&gt;    /&lt;br&gt;   3&lt;br&gt;输出: [3,2,1]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt;递归算法很简单，你可以通过迭代算法完成吗？&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 97. Interleaving String」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-97/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-97/</id>
    <published>2018-12-25T03:57:03.000Z</published>
    <updated>2018-12-24T17:24:20.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/interleaving-string/description/" target="_blank" rel="noopener">LeetCode 97. Interleaving String</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p><p><strong>示例 1:</strong><br>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>输出: true</p><p><strong>示例 2:</strong><br>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”<br>输出: false</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>平方的算法基本还是秒想到了。<br>比较裸而且容易的DP吧，f[i][j]：s3的前i个字母用到s1的前j个字母是否可行。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N^2)$，认为字符串规模都是N的话。<br>空间复杂度为 $O(N^2)$，可以优化一维。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s1.size());</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s2.size());</span><br><span class="line"><span class="keyword">int</span> n3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s3.size());</span><br><span class="line"><span class="keyword">if</span> (n1 + n2 != n3) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; f(n3 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n1 + <span class="number">1</span>));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p3 = <span class="number">1</span>; p3 &lt;= n3; ++p3) &#123;</span><br><span class="line"><span class="keyword">int</span> max_p1 = min(p3, n1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>; p1 &lt;= max_p1; ++p1) &#123;</span><br><span class="line"><span class="keyword">int</span> p2 = p3 - p1;</span><br><span class="line"><span class="keyword">if</span> (p2 &gt; n2) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p1 != <span class="number">0</span> &amp;&amp; s3[p3 - <span class="number">1</span>] == s1[p1 - <span class="number">1</span>] &amp;&amp; f[p3 - <span class="number">1</span>][p1 - <span class="number">1</span>]) &#123;</span><br><span class="line">f[p3][p1] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p2 != <span class="number">0</span> &amp;&amp; s3[p3 - <span class="number">1</span>] == s2[p2 - <span class="number">1</span>] &amp;&amp; f[p3 - <span class="number">1</span>][p1]) &#123;</span><br><span class="line">f[p3][p1] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n3][n1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">string</span> s1, s2, s3;</span><br><span class="line">s1 = <span class="string">"aabcc"</span>;</span><br><span class="line">s2 = <span class="string">"dbbca"</span>;</span><br><span class="line">s3 = <span class="string">"aadbbcbcac"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;isInterleave(s1, s2, s3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s1 = <span class="string">"aabcc"</span>;</span><br><span class="line">s2 = <span class="string">"dbbca"</span>;</span><br><span class="line">s3 = <span class="string">"aadbbbaccc"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;isInterleave(s1, s2, s3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/interleaving-string/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 97. Interleaving String&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”&lt;br&gt;输出: true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”&lt;br&gt;输出: false&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 84. Largest Rectangle in Histogram」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-84/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-84/</id>
    <published>2018-12-25T03:57:02.000Z</published>
    <updated>2018-12-24T16:51:48.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank" rel="noopener">LeetCode 84. Largest Rectangle in Histogram</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例:</strong><br>输入: [2,1,5,6,2,3]<br>输出: 10</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较值得思考的一道题，隐隐记得被人问过。<br>只是官方题解居然被抠掉了？可以看看高赞的几个回答。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N)$。<br>空间复杂度为 $O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">heights.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(heights.size());</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!s.empty() &amp;&amp; heights[s.top()] &gt;= heights[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> h = heights[s.top()];</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">int</span> bf = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">res = max(res, h * (i - bf - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj&#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;largestRectangleArea(adj) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 84. Largest Rectangle in Histogram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。&lt;br&gt;求在该柱状图中，能够勾勒出来的矩形的最大面积。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: [2,1,5,6,2,3]&lt;br&gt;输出: 10&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 72. Edit Distance」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-72/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-72/</id>
    <published>2018-12-23T03:57:02.000Z</published>
    <updated>2018-12-22T17:14:33.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">LeetCode 72. Edit Distance</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p><p><strong>示例 1:</strong><br>输入: word1 = “horse”, word2 = “ros”<br>输出: 3<br>解释:<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p><p><strong>示例 2:</strong><br>输入: word1 = “intention”, word2 = “execution”<br>输出: 5<br>解释:<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>算是DP的最经典的题了，不多说。<br>注意到如果word1[i]余word2[j]相同，其实f[i][j]可以直接等于f[i-1][j-1]。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(NM)$，其中N、M分别为两个字符串的长度。<br>空间复杂度为 $O(NM)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(word1.size());</span><br><span class="line"><span class="keyword">int</span> m = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(word2.size());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">f[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">f[<span class="number">0</span>][j] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">f[i][j] = min(min(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]), f[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minDistance(<span class="string">"horse"</span>, <span class="string">"ros"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minDistance(<span class="string">"intention"</span>, <span class="string">"execution"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/edit-distance/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 72. Edit Distance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;br&gt;你可以对一个单词进行如下三种操作：&lt;br&gt;插入一个字符&lt;br&gt;删除一个字符&lt;br&gt;替换一个字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;输入: word1 = “horse”, word2 = “ros”&lt;br&gt;输出: 3&lt;br&gt;解释:&lt;br&gt;horse -&amp;gt; rorse (将 ‘h’ 替换为 ‘r’)&lt;br&gt;rorse -&amp;gt; rose (删除 ‘r’)&lt;br&gt;rose -&amp;gt; ros (删除 ‘e’)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;输入: word1 = “intention”, word2 = “execution”&lt;br&gt;输出: 5&lt;br&gt;解释:&lt;br&gt;intention -&amp;gt; inention (删除 ‘t’)&lt;br&gt;inention -&amp;gt; enention (将 ‘i’ 替换为 ‘e’)&lt;br&gt;enention -&amp;gt; exention (将 ‘n’ 替换为 ‘x’)&lt;br&gt;exention -&amp;gt; exection (将 ‘n’ 替换为 ‘c’)&lt;br&gt;exection -&amp;gt; execution (插入 ‘u’)&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 76. Minimum Window Substring」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-76/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-76/</id>
    <published>2018-12-23T03:57:02.000Z</published>
    <updated>2018-12-23T15:02:14.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">LeetCode 76. Minimum Window Substring</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。</p><p><strong>示例：</strong><br>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”</p><p><strong>说明：</strong><br>如果 S 中不存这样的子串，则返回空字符串 “”。<br>如果 S 中存在这样的子串，我们保证它是唯一的答案。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很裸的滑动窗口吧，当然说是O(n)的复杂度是认为了字母的个数为常数。<br>有几个题目没说清楚的坑点注意：<br>1、可能出现小写字母<br>2、包含的字母个数也要足够<br>另外题解的优化算法也很迷，没get到它的必要性（优化常数？）……</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N)$，如果认为字母种类为常数。<br>空间复杂度为 $O(1)$，如果认为字母种类为常数。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kInf = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> have[kMaxN];</span><br><span class="line"><span class="keyword">int</span> cnt[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">'A'</span>; i &lt;= <span class="string">'z'</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[i] &lt; have[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(have, <span class="number">0</span>, <span class="keyword">sizeof</span> have);</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : t) &#123;</span><br><span class="line">++have[c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ns = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">0</span>, v = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans_u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min_len = kInf;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">bool</span> over = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (v &lt; ns - <span class="number">1</span>) &#123;</span><br><span class="line">++cnt[s[++v]];</span><br><span class="line"><span class="keyword">if</span> (check()) &#123;</span><br><span class="line">over = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (over) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (v - u + <span class="number">1</span> &lt; min_len) &#123;</span><br><span class="line">min_len = v - u + <span class="number">1</span>;</span><br><span class="line">ans_u = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> rem = s[u++];</span><br><span class="line"><span class="keyword">if</span> (--cnt[rem] &lt; have[rem]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min_len == kInf ? <span class="string">""</span> : s.substr(ans_u, min_len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minWindow(<span class="string">"ADOBECODEBANC"</span>, <span class="string">"ABC"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/minimum-window-substring/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 76. Minimum Window Substring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br&gt;输入: S = “ADOBECODEBANC”, T = “ABC”&lt;br&gt;输出: “BANC”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;br&gt;如果 S 中不存这样的子串，则返回空字符串 “”。&lt;br&gt;如果 S 中存在这样的子串，我们保证它是唯一的答案。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「KMP算法」浅析</title>
    <link href="http://tashi711.xyz/programming/dsaa/kmp/"/>
    <id>http://tashi711.xyz/programming/dsaa/kmp/</id>
    <published>2018-12-23T03:17:59.000Z</published>
    <updated>2018-12-23T10:35:29.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>Note：本文转自Matrix67博客，有改动。</p><h3 id="KMP思想"><a href="#KMP思想" class="headerlink" title="KMP思想"></a>KMP思想</h3><p>A = “abababaababacb”；<br>B = “ababacb”。</p><p>我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]!=B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B = a b a b a c bj = 1 2 3 4 5 6 7</code></pre><a id="more"></a><p>此时，A[6]!=B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j’。j’可能是多少呢？仔细想一下，我们发现，j’必须要使得B[1..j]中的头j’个字母和末j’个字母完全相等（这样j变成了j’后才能继续保持i和j的性质）。这个j’当然要越大越好。在这里，B [1..5]=”ababa”，头3个字母和末3个字母都是”aba”。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =     a b a b a c bj =     1 2 3 4 5 6 7</code></pre><p>从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]!=B[j+1]的情况：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =     a b a b a c bj =     1 2 3 4 5 6 7</code></pre><p>由于P[5]=3，因此新的j=3：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =         a b a b a c bj =         1 2 3 4 5 6 7</code></pre><p>这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =             a b a b a c bj =             1 2 3 4 5 6 7</code></pre><p>现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：</p><pre><code>i = 1 2 3 4 5 6 7 8 9 ……A = a b a b a b a a b a b …B =               a b a b a c bj =             0 1 2 3 4 5 6 7</code></pre><p>终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]=”d”时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。</p><p>这个过程的代码很短（真的很短），我们在这里给出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">j=0;</span><br><span class="line">for i=1 to n do</span><br><span class="line">begin</span><br><span class="line">   while (j&gt;0) and (B[j+1]!=A[i]) do j=P[j];</span><br><span class="line">   if B[j+1]=A[i] then j=j+1;</span><br><span class="line">   if j=m then</span><br><span class="line">   begin</span><br><span class="line">      writeln(&apos;Pattern occurs with shift &apos;,i-m);</span><br><span class="line">      j=P[j];</span><br><span class="line">   end;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>最后的j=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。</p><p>这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。</p><p>现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。</p><p>为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。</p><p>预处理不需要按照P的定义写成O(m^2)甚至O(m^3)的。我们可以通过P[1],P[2],…,P[j-1]的值来获得P[j]的值。对于刚才的B=”ababacb”，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]!=B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：</p><pre><code>    1 2 3 4 5 6 7B = a b a b a c bP = 0 0 1 2 3 ?</code></pre><p>P[5]=3是因为B[1..3]和B[3..5]都是”aba”；而P[3]=1则告诉我们，B[1]、B[3]和B[5]都是”a”。既然P[6]不能由P[5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]!=B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。</p><p>怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P[1]=0;</span><br><span class="line">j=0;</span><br><span class="line">for i=2 to m do</span><br><span class="line">begin</span><br><span class="line">   while (j&gt;0) and (B[j+1]!=B[i]) do j=P[j];</span><br><span class="line">   if B[j+1]=B[i] then j=j+1;</span><br><span class="line">   P[i]=j;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。</p><h3 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h3><p>Note：下面代码实现是考虑下标从0开始，与上述代码略有差别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">bool</span> inited = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">string</span> sp;</span><br><span class="line"><span class="keyword">int</span> nsp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matched_idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">inited = <span class="literal">true</span>;</span><br><span class="line">sp = s;</span><br><span class="line">nsp = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(sp.size());</span><br><span class="line">p.resize(nsp);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nsp; ++i) &#123;</span><br><span class="line"><span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sp[j + <span class="number">1</span>] != sp[i]) &#123;</span><br><span class="line">j = p[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sp[j + <span class="number">1</span>] == sp[i]) &#123;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">p[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!inited) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not inited!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">matched_idx.clear();</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s.size());</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sp[j + <span class="number">1</span>] != s[i]) &#123;</span><br><span class="line">j = p[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sp[j + <span class="number">1</span>] == s[i]) &#123;</span><br><span class="line">++j;</span><br><span class="line"><span class="keyword">if</span> (j == nsp - <span class="number">1</span>) &#123;</span><br><span class="line">matched_idx.push_back(i - nsp + <span class="number">1</span>);</span><br><span class="line">j = p[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_matched_idx</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(matched_idx.size()); ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; matched_idx[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *kmp = <span class="keyword">new</span> KMP;</span><br><span class="line">kmp-&gt;init(<span class="string">"ababacb"</span>);</span><br><span class="line">kmp-&gt;match(<span class="string">"abababaababacb"</span>);</span><br><span class="line">kmp-&gt;show_matched_idx();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;p&gt;Note：本文转自Matrix67博客，有改动。&lt;/p&gt;
&lt;h3 id=&quot;KMP思想&quot;&gt;&lt;a href=&quot;#KMP思想&quot; class=&quot;headerlink&quot; title=&quot;KMP思想&quot;&gt;&lt;/a&gt;KMP思想&lt;/h3&gt;&lt;p&gt;A = “abababaababacb”；&lt;br&gt;B = “ababacb”。&lt;/p&gt;
&lt;p&gt;我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]!=B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 1 2 3 4 5 6 7 8 9 ……
A = a b a b a b a a b a b …
B = a b a b a c b
j = 1 2 3 4 5 6 7
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据结构与算法" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="KMP" scheme="http://tashi711.xyz/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 952. Largest Component Size by Common Factor」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-952/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-952/</id>
    <published>2018-12-22T14:57:02.000Z</published>
    <updated>2018-12-21T17:43:15.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/largest-component-size-by-common-factor/description/" target="_blank" rel="noopener">LeetCode 952. Largest Component Size by Common Factor</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一个由不同正整数的组成的非空数组 A，考虑下面的图：<br>有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；<br>只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。<br>返回图中最大连通组件的大小。</p><p><strong>示例 1：</strong><br>输入：[4,6,15,35]<br>输出：4</p><p><strong>示例 2：</strong><br>输入：[20,50,9,63]<br>输出：2</p><p><strong>示例 3：</strong><br>输入：[2,3,6,7,4,12,21,39]<br>输出：8</p><p><strong>提示：</strong><br>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= 100000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>很简单的一道题，将一个数的所有因数用并查集合并一下就好。<br>求因数就根号的时间就好（不一定非要是质因数）。<br>最后统计一下。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(N\sqrt{M})$，其中M为数值范围，考虑并查集复杂度为常数。<br>空间复杂度为$O(M)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">110000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[kMaxN];</span><br><span class="line"><span class="keyword">int</span> s[kMaxN];</span><br><span class="line"><span class="keyword">int</span> fact[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_p</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[k] != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> p[k] = find_p(p[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pu = find_p(u);</span><br><span class="line"><span class="keyword">int</span> pv = find_p(v);</span><br><span class="line"><span class="keyword">if</span> (pu != pv) &#123;</span><br><span class="line">p[pv] = pu;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestComponentSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">-1</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : A) &#123;</span><br><span class="line"><span class="keyword">int</span> rt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">sqrt</span>(k + <span class="number">0.5</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= rt; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (k % i == <span class="number">0</span>) &#123;</span><br><span class="line">adj.push_back(i);</span><br><span class="line">adj.push_back(k / i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (adj.empty()) &#123;</span><br><span class="line">adj.push_back(k);</span><br><span class="line">&#125;</span><br><span class="line">fact[k] = adj[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(adj.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">merge(adj[<span class="number">0</span>], adj[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : A) &#123;</span><br><span class="line"><span class="keyword">int</span> u = find_p(fact[k]);</span><br><span class="line"><span class="keyword">if</span> (++s[u] &gt; ans) &#123;</span><br><span class="line">ans = s[u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1&#123; <span class="number">4</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">35</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2&#123; <span class="number">20</span>, <span class="number">50</span>, <span class="number">9</span>, <span class="number">63</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a3&#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">39</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;largestComponentSize(a1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;largestComponentSize(a2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;largestComponentSize(a3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/largest-component-size-by-common-factor/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 952. Largest Component Size by Common Factor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定一个由不同正整数的组成的非空数组 A，考虑下面的图：&lt;br&gt;有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；&lt;br&gt;只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。&lt;br&gt;返回图中最大连通组件的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[4,6,15,35]&lt;br&gt;输出：4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[20,50,9,63]&lt;br&gt;输出：2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：[2,3,6,7,4,12,21,39]&lt;br&gt;输出：8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;br&gt;1 &amp;lt;= A[i] &amp;lt;= 100000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="并查集" scheme="http://tashi711.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 956. Tallest Billboard」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-956/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-956/</id>
    <published>2018-12-16T14:57:02.000Z</published>
    <updated>2018-12-21T17:18:59.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/tallest-billboard/description/" target="_blank" rel="noopener">LeetCode 956. Tallest Billboard</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。<br>你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。<br>返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。</p><p><strong>示例 1：</strong><br>输入：[1,2,3,6]<br>输出：6<br>解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。</p><p><strong>示例 2：</strong><br>输入：[1,2,3,4,5,6]<br>输出：10<br>解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。</p><p><strong>示例 3：</strong><br>输入：[1,2]<br>输出：0<br>解释：没法安装广告牌，所以返回 0。</p><p><strong>提示：</strong><br>0 &lt;= rods.length &lt;= 20<br>1 &lt;= rods[i] &lt;= 1000<br>钢筋的最大长度最多为 5000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>蛮不错的一道题，先说说暴力的改良，也就是官方第二种题解。<br>这种解法很神奇之处在于不需要题目中后两个限制。<br>之前有一道题跟这个很类似，也是全部枚举会超时，枚举一半不超时。<br>最后根据相等转换为和为0来线性合并。<br>当然这道题标准解法应该是DP，毕竟给了容量限制。<br>一个$O(NS^2)$的算法很容易想到，不过会超时。<br>其实也是通过和为0这种思想去优化了一维，具体看题解就会很明白了。<br>注意C++负下标处理一下。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(NS)$，其中S为和的限制。<br>空间复杂度为$O(NS)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxM = <span class="number">11000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kBias = <span class="number">5500</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxSum = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> k + kBias;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rods)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][idx(<span class="number">0</span>)] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rods.size());</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> r = rods[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = max(-sum, -kMaxSum); j &lt;= min(sum, kMaxSum); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[i - <span class="number">1</span>][idx(j)] != <span class="number">-1</span>) &#123;</span><br><span class="line">f[i][idx(j)] = max(f[i][idx(j)], f[i - <span class="number">1</span>][idx(j)]);</span><br><span class="line">f[i][idx(j + r)] = max(f[i][idx(j + r)], f[i - <span class="number">1</span>][idx(j)] + r);</span><br><span class="line">f[i][idx(j - r)] = max(f[i][idx(j - r)], f[i - <span class="number">1</span>][idx(j)]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum += r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n][idx(<span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a2&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a3&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;tallestBillboard(a1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;tallestBillboard(a2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;tallestBillboard(a3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/tallest-billboard/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 956. Tallest Billboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。&lt;br&gt;你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。&lt;br&gt;返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：[1,2,3,6]&lt;br&gt;输出：6&lt;br&gt;解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：[1,2,3,4,5,6]&lt;br&gt;输出：10&lt;br&gt;解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：[1,2]&lt;br&gt;输出：0&lt;br&gt;解释：没法安装广告牌，所以返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;0 &amp;lt;= rods.length &amp;lt;= 20&lt;br&gt;1 &amp;lt;= rods[i] &amp;lt;= 1000&lt;br&gt;钢筋的最大长度最多为 5000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode 42. Trapping Rain Water」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-42/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-42/</id>
    <published>2018-12-16T03:57:02.000Z</published>
    <updated>2018-12-16T11:02:59.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LeetCode 42. Trapping Rain Water</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><p><strong>示例:</strong><br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>比较水，基本稍微想想就能想到最优解，一开始还想过NlogN用RMQ来解，结果其实没必要。<br>官方题解没看了，因为对于在短时间内能想到最优解的水题，复杂度更高的解法就没什么意义了。<br>找到最高点，分别从左和从右扫到最高点，记录当前扫过的最高值，遇到更高就更新，遇到更低就填到目前的高度。<br>线性时间，且仅需要常数额外空间。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为 $O(N)$。<br>（额外）空间复杂度为 $O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(height.size());</span><br><span class="line"><span class="keyword">int</span> maxh = <span class="number">-1</span>, p = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (height[i] &gt; maxh) &#123;</span><br><span class="line">maxh = height[i];</span><br><span class="line">p = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (height[i] &lt;= cur) &#123;</span><br><span class="line">res += cur - height[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur = height[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; p; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (height[i] &lt;= cur) &#123;</span><br><span class="line">res += cur - height[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur = height[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *s = <span class="keyword">new</span> Solution;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;trap(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 42. Trapping Rain Water&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;br&gt;数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，可以接 6 个单位的雨水（蓝色部分表示雨水）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br&gt;输入: [0,1,0,2,1,0,1,3,2,1,2,1]&lt;br&gt;输出: 6&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
</feed>
