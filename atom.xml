<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tashi711的博客</title>
  
  <subtitle>過去（きのう）に傷付きながらも、信じ続ける理想（ゆめ）を求める。いつか無限（なないろ）に輝き放って、青空（そら）に橋を描く。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tashi711.xyz/"/>
  <updated>2018-10-19T17:43:10.058Z</updated>
  <id>http://tashi711.xyz/</id>
  
  <author>
    <name>Tashi711</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「hihoCoder - 1848, 1849」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/others/hihocoder-1848-1849/"/>
    <id>http://tashi711.xyz/programming/reports/others/hihocoder-1848-1849/</id>
    <published>2018-10-13T16:11:04.000Z</published>
    <updated>2018-10-19T17:43:10.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="http://hihocoder.com/problemset/problem/1848，[hihoCoder - 1849](http://hihocoder.com/problemset/problem/1849" target="_blank" rel="noopener">hihoCoder - 1848</a></li><li>来源：hihoCoder</li><li>场次：飞步无人驾驶2018届校园招聘在线笔试A轮</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><h4 id="1848-子数组的和"><a href="#1848-子数组的和" class="headerlink" title="1848 - 子数组的和"></a>1848 - 子数组的和</h4><p>给定一个包含N个整数的数组A = [A1, A2, … AN]，请你计算有多少个子数组B = [Ai, Ai+1, … Aj] (i ≤ j) 满足B中所有整数的和小于K。</p><p><strong>输入</strong><br>第一行包含两个整数N和K。<br>第二行包含N个整数A1, A2, … AN。<br>对于30%的数据，1 ≤ N ≤ 1000<br>对于另外30%的数据，0 &lt; Ai ≤ 100000<br>对于100%的数据，1 ≤ N ≤ 100000 -100000 ≤ Ai ≤ 100000</p><p><strong>输出</strong><br>一个整数，代表答案。</p><p><strong>样例输入</strong><br>4 -1<br>-2 1 -2 3</p><p><strong>样例输出</strong><br>3</p><p><strong>时间限制</strong><br>10000ms</p><p><strong>单点时限</strong><br>1000ms</p><p><strong>内存限制</strong><br>256MB</p><a id="more"></a><h4 id="1849-子数组的中位数"><a href="#1849-子数组的中位数" class="headerlink" title="1849 - 子数组的中位数"></a>1849 - 子数组的中位数</h4><p>给定一个包含N个整数的数组A = [A1, A2, … AN]，请你计算有多少个子数组B = [Ai, Ai+1, … Aj] (i ≤ j) 满足B的中位数是K。<br>注意，本题中位数的定义是：假设子数组B长度为m，那么B的中位数是将B从小到大排序后，第[(m+1)/2]小的数([x]指对x下取整)。这个定义与通常的中位数定义略有不同。</p><p><strong>输入</strong><br>第一行包含两个整数N和K。<br>第二行包含N个整数A1, A2, … AN。<br>对于30%的数据，1 ≤ N ≤ 100<br>对于60%的数据，1 ≤ N ≤ 5000<br>对于100%的数据，1 ≤ N ≤ 100000 -100000 ≤ Ai ≤ 100000</p><p><strong>输出</strong><br>一个整数，代表答案。</p><p><strong>样例输入</strong><br>5 2<br>1 9 2 8 10</p><p><strong>样例输出</strong><br>5</p><p><strong>时间限制</strong><br>10000ms</p><p><strong>单点时限</strong><br>1000ms</p><p><strong>内存限制</strong><br>256MB</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>两道题如出一辙，都是可以转换成动态单点更新询问前缀和的模型，因此考虑树状数组。<br>关于树状数组，可以参见<a href="tashi711.xyz/programming/tech-and-algos/binary-indexed-tree/">「树状数组」浅析</a>。</p><p><strong>1848 - 子数组的和</strong><br>这样子区间的个数其实就是前缀和的差小于k的个数。<br>与求逆序对很像，遍历一遍前缀和，当前前缀和为s[i]时，统计前面前缀和有多少个大于s[i]-k的。<br>由于树状数组也是求前缀和的过程（注意这里说的前缀和是树状数组的前缀和，不是前面说的题目中原数组的前缀和，为了区别，后面都将树状数组的前缀和叫做“bit前缀和”），因此可以先求出有多少个小于等于s[i]-k的前缀和（设为cnt），最后累加到答案上的为i-cnt。<br>然后在s[i]的位置加个1就好。<br>注意下面几个细节：<br>1、前缀和的范围太大，不能直接用作树状数组的下标，因此需要离散化的过程，但是又不能完全像求逆序对那样完全利用离散化的结果，因为这些前缀和的绝对大小关系是有用的，因此两个信息（大小和顺序位置）都要保留。<br>2、求小于等于的时候s[i]-k的位置的时候要用upper_bound的前一个位置，因为“等于”的时候是要去掉的（其实分别模拟一下s[i]-k存在与不存在两种情况就知道该用lower_bound的当前位置还是upper_bound的前一个位置）。当然这个时候就会出现取bit前缀和sum(0)的情况，注意边界。<br>3、注意前缀和的边界，因为这里所有的区间都是两个前缀和的差得到的，注意到当一个区间从数组头开始，那么其实会出现“空前缀和”的情况，因此总共应该有n+1个前缀和，其中包含一个和为0的“空前缀和”，这个0也要参与排序离散化，这也是为什么每次统计bit前缀和之后累加到答案上的为i-cnt而不是i-1-cnt，因为位置i前面本来就应该产生i个前缀和而不是i-1个。下面的代码中直接用了前缀和s[0]=0作为“空前缀和”，那么要注意下标范围，因为前缀和的下标为0到n，而树状数组的下标范围为1到n+1。<br>复杂度也就排序、离散化、树状数组的复杂度$O(N\log N)$。</p><p><strong>1849 - 子数组的中位数</strong><br>满足要求的子区间有这样的性质：如果将小于等于k的数看成1，大于k的数看成-1，那么这个区间的和一定大于等于0（条件1），且如果将小于k的数看成1，大于等于k的数看成-1，那么这个区间的和一定小于0（条件2）。<br>那么很容易受到上一道题的启发，先求满足条件1的区间：首先按照将小于等于k的数看成1，大于k的数看成-1求出前缀和s[i]，以这个前缀和为下标（不用离散化，因为范围最多是-n到n，可以统一加上n+1使得下标均为正数，即开一个2n+1大小的树状数组），有多少个小于等于s[i]的前缀和就有多少个这样的区间，然后在s[i]的位置加个1就好。<br>跟上一道题一样，注意“空前缀和”，一开始先在0的位置（即n+1）加1。<br>对于条件2，其实有个小trick，满足条件2的，其实等价于去掉如果将小于k的数看成1，大于等于k的数看成-1，区间和大于等于0的，而将小于k的数看成1，大于等于k的数看成-1又等价于将小于等于k-1的数看成1，大于k-1的数看成-1，也就正好是条件1中将k改为k-1，这样就可以减少一半的代码量。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度均为$O(N\log N)$。<br>空间复杂度均为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><h3 id="1848-子数组的和-1"><a href="#1848-子数组的和-1" class="headerlink" title="1848 - 子数组的和"></a>1848 - 子数组的和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxN = <span class="number">110000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">BinaryIndexedTree(<span class="keyword">int</span> n)</span><br><span class="line">: n(n), a(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= <span class="number">0</span> || p &gt; n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"add("</span> &lt;&lt; p &lt;&lt; <span class="string">", "</span> &lt;&lt; k &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">a[p] += k;</span><br><span class="line">p += lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"get_sum("</span> &lt;&lt; p &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">sum += a[p];</span><br><span class="line">p ^= lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> s[kMaxN];</span><br><span class="line"><span class="keyword">int</span> c[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">c[i] = s[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(c, c + n + <span class="number">1</span>);</span><br><span class="line"><span class="function">BinaryIndexedTree <span class="title">bit</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">int</span> pos_0 = lower_bound(c, c + n + <span class="number">1</span>, <span class="number">0</span>) - c;</span><br><span class="line">bit.add(pos_0 + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> u = upper_bound(c, c + n + <span class="number">1</span>, s[i] - k) - c - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = bit.get_sum(u + <span class="number">1</span>);</span><br><span class="line">ans += i - cnt;</span><br><span class="line"><span class="keyword">int</span> v = lower_bound(c, c + n + <span class="number">1</span>, s[i]) - c;</span><br><span class="line">bit.add(v + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1849-子数组的中位数-1"><a href="#1849-子数组的中位数-1" class="headerlink" title="1849 - 子数组的中位数"></a>1849 - 子数组的中位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxN = <span class="number">110000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">BinaryIndexedTree(<span class="keyword">int</span> n)</span><br><span class="line">: n(n), a(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= <span class="number">0</span> || p &gt; n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"add("</span> &lt;&lt; p &lt;&lt; <span class="string">", "</span> &lt;&lt; k &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">a[p] += k;</span><br><span class="line">p += lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; n) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"get_sum("</span> &lt;&lt; p &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">sum += a[p];</span><br><span class="line">p ^= lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> s[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="keyword">sizeof</span> s, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + (a[i] &lt;= k ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinaryIndexedTree <span class="title">bit</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>)</span></span>;</span><br><span class="line">bit.add(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">ans += bit.get_sum(s[i] + n + <span class="number">1</span>);</span><br><span class="line">bit.add(s[i] + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; calc(k) - calc(k - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;http://hihocoder.com/problemset/problem/1848，[hihoCoder - 1849](http://hihocoder.com/problemset/problem/1849&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hihoCoder - 1848&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：hihoCoder&lt;/li&gt;
&lt;li&gt;场次：飞步无人驾驶2018届校园招聘在线笔试A轮&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;h4 id=&quot;1848-子数组的和&quot;&gt;&lt;a href=&quot;#1848-子数组的和&quot; class=&quot;headerlink&quot; title=&quot;1848 - 子数组的和&quot;&gt;&lt;/a&gt;1848 - 子数组的和&lt;/h4&gt;&lt;p&gt;给定一个包含N个整数的数组A = [A1, A2, … AN]，请你计算有多少个子数组B = [Ai, Ai+1, … Aj] (i ≤ j) 满足B中所有整数的和小于K。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;&lt;br&gt;第一行包含两个整数N和K。&lt;br&gt;第二行包含N个整数A1, A2, … AN。&lt;br&gt;对于30%的数据，1 ≤ N ≤ 1000&lt;br&gt;对于另外30%的数据，0 &amp;lt; Ai ≤ 100000&lt;br&gt;对于100%的数据，1 ≤ N ≤ 100000 -100000 ≤ Ai ≤ 100000&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;br&gt;一个整数，代表答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样例输入&lt;/strong&gt;&lt;br&gt;4 -1&lt;br&gt;-2 1 -2 3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样例输出&lt;/strong&gt;&lt;br&gt;3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间限制&lt;/strong&gt;&lt;br&gt;10000ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单点时限&lt;/strong&gt;&lt;br&gt;1000ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存限制&lt;/strong&gt;&lt;br&gt;256MB&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="树状数组" scheme="http://tashi711.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「POJ 2299 - Ultra-QuickSort」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/others/poj-2299/"/>
    <id>http://tashi711.xyz/programming/reports/others/poj-2299/</id>
    <published>2018-10-12T16:11:04.000Z</published>
    <updated>2018-10-19T17:38:27.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="http://poj.org/problem?id=2299" target="_blank" rel="noopener">POJ 2299 - Ultra-QuickSort</a></li><li>来源：POJ</li><li>场次：Waterloo local 2005.02.05</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给出n个不重复的整数，现在你可以交换任意相邻的两个数，使得最后这n个数保持递增的顺序，求你需要的最少的交换次数。<br>输入数据包含多组测试数据：每一组数据以n开始，（n &lt; 500000，表示这组数据的个数），接下来n个数，表示这一组数据。这些数都是不大于999999999的非负整数。如果n为0，表示结束。这组数据不需处理。</p><p><strong>输入样例：</strong><br>5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0</p><p><strong>输出样例：</strong><br>6<br>0</p><p><strong>时间限制：</strong><br>7s</p><p><strong>空间限制：</strong><br>64M</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题其实是求逆序对的个数。<br>给出两个思路：</p><p><strong>1、归并排序</strong><br>做一次归并排序的过程即可求得所有逆序对的个数，方法就是在合并的过程中如果发现还未合并的前半已序段的首元素比后半已序段的首元素大的话，那么一定会产生目前未合并的前半已序段的个数个逆序对（因为这未合并的前半已序段的元素都比这个后半已序段的首元素大），且很容易发现任何逆序对一定在这两个元素被合并的时候有且仅有一次被统计到（注意到任何两个元素有且仅有一次被合并）。<br>代码就是普通的归并排序加一行代码（下面的“ans += mid - l + 1;”）即可，复杂度也就是排序的复杂度$O(N\log N)$。</p><p><strong>2、树状数组</strong><br>关于树状数组，可以参见<a href="tashi711.xyz/programming/tech-and-algos/binary-indexed-tree/">「树状数组」浅析</a>。<br>先将数据离散化，这样不影响结果，既能保证树状数组存的下，又能有意义（数值大小同时也是顺序序号）。<br>遍历一遍数组，那么如果将出现过的数字的位置都放一个1的话，当前数字（a[i]）所能产生的逆序对即为a[i] - 1 - sum(a[i] - 1)，其中sum为前缀和，因为a[i]前面的a[i] - 1个数的位置没有放1的话意味着那个数出现在i后面。<br>然后在a[i]的位置放上1。<br>复杂度为排序、离散化、树状数组的复杂度，即$O(N\log N)$。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度均为$O(N\log N)$。<br>空间复杂度均为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><h3 id="1、归并排序"><a href="#1、归并排序" class="headerlink" title="1、归并排序"></a>1、归并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxN = <span class="number">550000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> c[kMaxN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> mid, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = u;</span><br><span class="line"><span class="keyword">int</span> l = u, r = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= v) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[l] &lt;= a[r]) &#123;</span><br><span class="line">c[p++] = a[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans += mid - l + <span class="number">1</span>;</span><br><span class="line">c[p++] = a[r++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">c[p++] = a[l++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (r &lt;= v) &#123;</span><br><span class="line">c[p++] = a[r++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt;= v; ++i) &#123;</span><br><span class="line">a[i] = c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == v) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> mid = u + (v - u) / <span class="number">2</span>;</span><br><span class="line">merge_sort(u, mid);</span><br><span class="line">merge_sort(mid + <span class="number">1</span>, v);</span><br><span class="line">merge(u, mid, v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">0L</span>L;</span><br><span class="line">merge_sort(<span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、树状数组"><a href="#2、树状数组" class="headerlink" title="2、树状数组"></a>2、树状数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kMaxN = <span class="number">550000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">BinaryIndexedTree(<span class="keyword">int</span> n)</span><br><span class="line">: n(n), a(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">a[p] += k;</span><br><span class="line">p += lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">sum += a[p];</span><br><span class="line">p ^= lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> c[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">c[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">a[i] = lower_bound(c + <span class="number">1</span>, c + n + <span class="number">1</span>, a[i]) - c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinaryIndexedTree <span class="title">bit</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">ans += a[i] - <span class="number">1</span> - bit.get_sum(a[i] - <span class="number">1</span>);</span><br><span class="line">bit.add(a[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;http://poj.org/problem?id=2299&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;POJ 2299 - Ultra-QuickSort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：POJ&lt;/li&gt;
&lt;li&gt;场次：Waterloo local 2005.02.05&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给出n个不重复的整数，现在你可以交换任意相邻的两个数，使得最后这n个数保持递增的顺序，求你需要的最少的交换次数。&lt;br&gt;输入数据包含多组测试数据：每一组数据以n开始，（n &amp;lt; 500000，表示这组数据的个数），接下来n个数，表示这一组数据。这些数都是不大于999999999的非负整数。如果n为0，表示结束。这组数据不需处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例：&lt;/strong&gt;&lt;br&gt;5&lt;br&gt;9&lt;br&gt;1&lt;br&gt;0&lt;br&gt;5&lt;br&gt;4&lt;br&gt;3&lt;br&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出样例：&lt;/strong&gt;&lt;br&gt;6&lt;br&gt;0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间限制：&lt;/strong&gt;&lt;br&gt;7s&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间限制：&lt;/strong&gt;&lt;br&gt;64M&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="树状数组" scheme="http://tashi711.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="归并排序" scheme="http://tashi711.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="逆序对" scheme="http://tashi711.xyz/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
  </entry>
  
  <entry>
    <title>「树状数组」浅析</title>
    <link href="http://tashi711.xyz/programming/tech-and-algos/binary-indexed-tree/"/>
    <id>http://tashi711.xyz/programming/tech-and-algos/binary-indexed-tree/</id>
    <published>2018-10-10T03:15:34.000Z</published>
    <updated>2018-10-19T17:38:26.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>已知数组a[]，元素个数为n，现在要求a数组中i到j区间内的和(1&lt;=i&lt;=j&lt;=n)。</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>我们完全可以存储sum[1,k]，其中k=1,2,……，然后对任意给定的查找区间[i,j]，返回sum[1,j]-sum[1,i-1]。<br>当然这只是没有元素改变的情况下的比较优化的解法，那么对于对于数组中的元素随时变更的情况下呢？</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如果仍然采取这样的方法，则每次数据有更新，则需要将更新的元素后的sum值全部再求一次。假设有m次查询或者更新操作，则时间复杂度将达到m*n了。<br>可以想一下，每次更改的元素可能是比较少的，有时候甚至每次只改变一个元素，但是在用暴力方法求区间和的时候，却对区间内所有的元素都累加了一遍，这样其实造成了许多无谓的运算。这时候也许会想到如果能把一些结果存起来会不会减少很多运算。</p><a id="more"></a><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>构造一种树：Binary Index Tree。</p><h3 id="树的构造"><a href="#树的构造" class="headerlink" title="树的构造"></a>树的构造</h3><p>令这棵树的结点编号为C1,C2,……,Cn，令每个结点的值为如下值的总和：<br>C1 = A1<br>C2 = A1 + A2<br>C3 = A3<br>C4 = A1 + A2 + A3 + A4<br>C5 = A5<br>C6 = A5 + A6<br>C7 = A7<br>C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8<br>……<br>C16 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10 + A11 + A12 + A13 + A14 + A15 + A16<br>其中A为原数组，C为树状数组。<br>这里有一个有趣的性质：设节点编号为x，那么这个节点管辖的区间为2^k（其中k为x二进制末尾0的个数）个元素。<br>因为这个区间最后一个元素必然为Ax，所以有：<br>Cn = A(n – 2^k + 1) + …… + An<br>算这个2^k有一个快捷的办法，即经典的lowbit操作（取最后一个1的位置）：<br>x &amp; (x ^ (x – 1)) 或者 x &amp; -x （通常使用后者）</p><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>当想要查询一个前缀和sum[1,n]时，可以依据如下算法即可：<br>step1：令sum = 0，转到step2；<br>step2：假如n &lt;= 0，算法结束，返回sum值，否则sum = sum + Cn，转到step3；<br>step3：令n = n – lowbit(n)，转到step2。（这里可以用异或运算加快速度。）<br>可以看出，这个算法就是将这一个个区间的和全部加起来，因为n的二进制里最多有log(n)个1，所以查询效率是log(n)的。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>如果更新一个节点，必须更新其所有祖先，最坏情况下为更新第一个元素，最多有log(n)的祖先。<br>给某个结点i加上x的算法如下：<br>step1：当i &gt; n时，算法结束，否则转到step2；<br>step2：Ci = Ci + x，i = i + lowbit(i)，转到step1。</p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryIndexedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">BinaryIndexedTree(<span class="keyword">int</span> n)</span><br><span class="line">: n(n), a(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">a[p] += k;</span><br><span class="line">p += lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">sum += a[p];</span><br><span class="line">p ^= lowbit(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他拓展"><a href="#其他拓展" class="headerlink" title="其他拓展"></a>其他拓展</h2><p>树状数组虽然只是解决一类问题（单点更新与区间求和询问），但是由于许多问题都可以巧妙的转变成动态的在单点插值（通常为1）然后随时询问区间和（1的个数）（可以参见<a href="tashi711.xyz/programming/reports/others/hihocoder-1848-1849/">「hihoCoder - 1848, 1849」解题报告</a>），并且虽然类似线段树之类的数据结构能够以相同的复杂度处理同样甚至更复杂的问题，但是相比之下树状数组更为简洁，方便coding，因此能够使用到树状数组的地方还是有很多的。<br>可以利用树状数组在O(NlogN)的时间复杂度内巧妙地求出一个规模为N的数组中逆序对的个数（可以参见<a href="tashi711.xyz/programming/reports/others/poj-2299/">「POJ 2299 - Ultra-QuickSort」解题报告</a>解法2），此外，树状数组也可以方便的拓展到二维，感兴趣的话可以多多探索。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题提出&quot;&gt;&lt;a href=&quot;#问题提出&quot; class=&quot;headerlink&quot; title=&quot;问题提出&quot;&gt;&lt;/a&gt;问题提出&lt;/h2&gt;&lt;p&gt;已知数组a[]，元素个数为n，现在要求a数组中i到j区间内的和(1&amp;lt;=i&amp;lt;=j&amp;lt;=n)。&lt;/p&gt;
&lt;h3 id=&quot;前缀和&quot;&gt;&lt;a href=&quot;#前缀和&quot; class=&quot;headerlink&quot; title=&quot;前缀和&quot;&gt;&lt;/a&gt;前缀和&lt;/h3&gt;&lt;p&gt;我们完全可以存储sum[1,k]，其中k=1,2,……，然后对任意给定的查找区间[i,j]，返回sum[1,j]-sum[1,i-1]。&lt;br&gt;当然这只是没有元素改变的情况下的比较优化的解法，那么对于对于数组中的元素随时变更的情况下呢？&lt;/p&gt;
&lt;h3 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h3&gt;&lt;p&gt;如果仍然采取这样的方法，则每次数据有更新，则需要将更新的元素后的sum值全部再求一次。假设有m次查询或者更新操作，则时间复杂度将达到m*n了。&lt;br&gt;可以想一下，每次更改的元素可能是比较少的，有时候甚至每次只改变一个元素，但是在用暴力方法求区间和的时候，却对区间内所有的元素都累加了一遍，这样其实造成了许多无谓的运算。这时候也许会想到如果能把一些结果存起来会不会减少很多运算。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="技术与算法" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E6%8A%80%E6%9C%AF%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树状数组" scheme="http://tashi711.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「4. Median of Two Sorted Arrays」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-4/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-4/</id>
    <published>2018-10-09T03:57:02.000Z</published>
    <updated>2018-10-09T16:34:53.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">4. Median of Two Sorted Arrays</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。<br>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。<br>你可以假设 nums1 和 nums2 不同时为空。</p><p><strong>示例 1:</strong><br>nums1 = [1, 3]<br>nums2 = [2]<br>中位数是 2.0</p><p><strong>示例 2:</strong><br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>中位数是 (2 + 3)/2 = 2.5</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>基本按照官方题解走就行了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(\log(m+n))$。<br>空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(nums1.size());</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(nums2.size());</span><br><span class="line"><span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">swap(nums1, nums2);</span><br><span class="line">swap(m, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">0</span>, v = m, mid = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (u &lt;= v) &#123;</span><br><span class="line"><span class="keyword">int</span> i = (u + v) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> j = mid - i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; m &amp;&amp; nums2[j - <span class="number">1</span>] &gt; nums1[i]) &#123;</span><br><span class="line">u = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">v = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ml = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">ml = nums2[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">ml = nums1[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ml = max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ml;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">mr = nums2[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">mr = nums1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">mr = min(nums1[i], nums2[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ml + mr) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;4. Median of Two Sorted Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。&lt;br&gt;请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。&lt;br&gt;你可以假设 nums1 和 nums2 不同时为空。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;br&gt;nums1 = [1, 3]&lt;br&gt;nums2 = [2]&lt;br&gt;中位数是 2.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;br&gt;nums1 = [1, 2]&lt;br&gt;nums2 = [3, 4]&lt;br&gt;中位数是 (2 + 3)/2 = 2.5&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="二分查找" scheme="http://tashi711.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>「920. Number of Music Playlists」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-920/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-920/</id>
    <published>2018-10-08T03:57:02.000Z</published>
    <updated>2018-10-08T15:18:31.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/number-of-music-playlists/description/" target="_blank" rel="noopener">920. Number of Music Playlists</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：<br>每首歌至少播放一次。<br>一首歌只有在其他 K 首歌播放完之后才能再次播放。<br>返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。</p><p><strong>示例 1：</strong><br>输入：N = 3, L = 3, K = 1<br>输出：6<br>解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].</p><p><strong>示例 2：</strong><br>输入：N = 2, L = 3, K = 0<br>输出：6<br>解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]</p><p><strong>示例 3：</strong><br>输入：N = 2, L = 3, K = 1<br>输出：2<br>解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]</p><p><strong>提示：</strong><br>0 &lt;= K &lt; N &lt;= L &lt;= 100</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>努力去想数学的close解反而陷进去了，其实利用好“程序”而不是单纯的“数学”这是一道很简单的DP罢了。<br>令f[i][j]为长度为i时有j首歌的方案数，那么考虑最后一首歌，要是之前没出现过的，那就是f[i-1][j-1] * (N-j+1)种，要是之前出现过的，那就是f[i-1][j] * max(j-K, 0)。<br>边界条件：f[0][0] = 1，最终需要的解为f[L][N]。<br>官方题解中还给了偏数学的方法，可以用母函数优化，建议有余力去学习学习（我这种老年智力就あきらめた）。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为$O(NL)$。<br>空间复杂度为$O(NL)$，当然考虑滚动数组之类的可以优化一维。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[kMaxN][kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numMusicPlaylists</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> L, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] * (N - j + <span class="number">1</span>) + f[i - <span class="number">1</span>][j] * max(j - K, <span class="number">0</span>)) % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f[L][N]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/number-of-music-playlists/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;920. Number of Music Playlists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：&lt;br&gt;每首歌至少播放一次。&lt;br&gt;一首歌只有在其他 K 首歌播放完之后才能再次播放。&lt;br&gt;返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;br&gt;输入：N = 3, L = 3, K = 1&lt;br&gt;输出：6&lt;br&gt;解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;br&gt;输入：N = 2, L = 3, K = 0&lt;br&gt;输出：6&lt;br&gt;解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;br&gt;输入：N = 2, L = 3, K = 1&lt;br&gt;输出：2&lt;br&gt;解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;0 &amp;lt;= K &amp;lt; N &amp;lt;= L &amp;lt;= 100&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数学" scheme="http://tashi711.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「Γ函数」小结</title>
    <link href="http://tashi711.xyz/programming/notes/others/gamma-function/"/>
    <id>http://tashi711.xyz/programming/notes/others/gamma-function/</id>
    <published>2018-10-07T04:17:59.000Z</published>
    <updated>2018-10-07T05:55:00.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分治算法复杂度分析"><a href="#分治算法复杂度分析" class="headerlink" title="分治算法复杂度分析"></a>分治算法复杂度分析</h2><p>Γ函数，也叫做伽玛函数（Gamma函数），是阶乘函数在实数与复数域上的扩展。<br>此处给出一些常见结论。</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于实数部分为正的复数z，伽玛函数定义为：<br>$$\Gamma(z)=\int_0^{+\infty} {x^{z-1}e^{-x}} \,{\rm d}x$$<br>特别地，对于正实数s&gt;0，伽玛函数定义为：<br>$$\Gamma(s)=\int_0^{+\infty} {x^{s-1}e^{-x}} \,{\rm d}x$$<br>容易得到：<br>$$\Gamma(1)=1$$</p><h3 id="递推结论"><a href="#递推结论" class="headerlink" title="递推结论"></a>递推结论</h3><p>对于正实数s&gt;0：<br>$$\Gamma(s+1)=s\Gamma(s)$$<br>特别地，如果n为非负整数，则：<br>$$\Gamma(n+1)=n!\Gamma(1)=n!$$</p><h3 id="数值性质"><a href="#数值性质" class="headerlink" title="数值性质"></a>数值性质</h3><p>对非正整数，Γ函数没有定义。<br>如果n为非负整数，则：<br>$$\Gamma(\frac{1}{2}+n)=\frac{(2n-1)!!}{2^n}\sqrt{\pi}=\frac{(2n)!}{4^nn!}\sqrt{\pi}$$<br>$$\Gamma(\frac{1}{2}-n)=\frac{(-2)^n}{(2n-1)!!}\sqrt{\pi}=\frac{(-4)^nn!}{(2n)!}\sqrt{\pi}$$<br>特别地，n=0时：<br>$$\Gamma(\frac{1}{2})=\sqrt{\pi}$$<br>一些其他特殊值：<br>$$\Gamma(\frac{3}{2})=\frac{1}{2}\sqrt{\pi}$$<br>$$\Gamma(\frac{5}{2})=\frac{3}{4}\sqrt{\pi}$$<br>$$\Gamma(\frac{7}{2})=\frac{15}{8}\sqrt{\pi}$$<br>$$\Gamma(-\frac{1}{2})=-2\sqrt{\pi}$$<br>$$\Gamma(-\frac{3}{2})=\frac{3}{4}\sqrt{\pi}$$<br>$$\Gamma(-\frac{5}{2})=-\frac{8}{15}\sqrt{\pi}$$</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zh.wikipedia.org/wiki/%CE%93%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">Γ函数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分治算法复杂度分析&quot;&gt;&lt;a href=&quot;#分治算法复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;分治算法复杂度分析&quot;&gt;&lt;/a&gt;分治算法复杂度分析&lt;/h2&gt;&lt;p&gt;Γ函数，也叫做伽玛函数（Gamma函数），是阶乘函数在实数与复数域上的扩展。&lt;br&gt;此处给出一些常见结论。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Γ函数" scheme="http://tashi711.xyz/tags/%CE%93%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>「分治算法」复杂度分析</title>
    <link href="http://tashi711.xyz/programming/notes/others/divide-and-conquer/"/>
    <id>http://tashi711.xyz/programming/notes/others/divide-and-conquer/</id>
    <published>2018-10-07T03:17:59.000Z</published>
    <updated>2018-10-06T13:47:24.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分治算法复杂度分析"><a href="#分治算法复杂度分析" class="headerlink" title="分治算法复杂度分析"></a>分治算法复杂度分析</h2><p>最近遇到许多分治的算法题，而分治算法的复杂度估计在《数据结构与算法分析》这本书中进行了推导，有兴趣可以跟着推导一下，此处给出结论。</p><a id="more"></a><h3 id="分治方程"><a href="#分治方程" class="headerlink" title="分治方程"></a>分治方程</h3><p>$$T(N) = aT(N/b) + O(N^k\log^pN), (a≥1, b&gt;1, p≥1)$$</p><h3 id="解（结论）"><a href="#解（结论）" class="headerlink" title="解（结论）"></a>解（结论）</h3><p>$$T(N) =<br>\begin{cases}<br>O(N^{\log_ba}), &amp; a&gt;b^k \\<br>O(N^k\log^{p+1}N), &amp; a=b^k \\<br>O(N^k\log^pN), &amp; a&lt;b^k<br>\end{cases}$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分治算法复杂度分析&quot;&gt;&lt;a href=&quot;#分治算法复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;分治算法复杂度分析&quot;&gt;&lt;/a&gt;分治算法复杂度分析&lt;/h2&gt;&lt;p&gt;最近遇到许多分治的算法题，而分治算法的复杂度估计在《数据结构与算法分析》这本书中进行了推导，有兴趣可以跟着推导一下，此处给出结论。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="其他" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="分治" scheme="http://tashi711.xyz/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>「ONE OK ROCK - Deeper Deeper」鑑賞</title>
    <link href="http://tashi711.xyz/nihongo/uta/oor-deeper-deeper/"/>
    <id>http://tashi711.xyz/nihongo/uta/oor-deeper-deeper/</id>
    <published>2018-10-06T17:03:54.000Z</published>
    <updated>2018-10-07T06:44:15.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="歌曲信息"><a href="#歌曲信息" class="headerlink" title="歌曲信息"></a>歌曲信息</h2><blockquote><ul><li>歌曲：Deeper Deeper</li><li>歌手：ONE OK ROCK</li><li>作词：Taka</li><li>作曲：Tomoya/Ryota</li><li>专辑：Deeper Deeper / Nothing Helps（2013年1月9日发行）</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OOR最喜欢的一首歌，没有之一。<br>标准日式摇滚。</p><a id="more"></a><h2 id="假名歌词"><a href="#假名歌词" class="headerlink" title="假名歌词"></a>假名歌词</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Another step up, it&apos;s takin&apos; takin&apos; takin&apos; takin&apos; long</span><br><span class="line">Always digging, it&apos;s gettin&apos; getting&apos; getting&apos; get it on</span><br><span class="line">Wherever you stand just start to walk</span><br><span class="line">Everywhere you go goes round and round</span><br><span class="line">It&apos;s coming back to what I know</span><br><span class="line"></span><br><span class="line">The deep deep deeper we go</span><br><span class="line">Feeling alone, but it&apos;s oh so simple, let it go</span><br><span class="line">Dim dim dim the light&apos;s low</span><br><span class="line">But not blind, I can see the symbol, let it show</span><br><span class="line">Mighty story, don&apos;t hide it from me</span><br><span class="line">いつだって人（ひと）は迷（まよ）うんだって</span><br><span class="line">気付（きづ）いちゃったって知（し）らんぷりしていよう</span><br><span class="line">そしてgood good days</span><br><span class="line"></span><br><span class="line">僕（ぼく）らは生（う）まれてからso多（おお）くを学（まな）び</span><br><span class="line">死（し）に近（ちか）づくにつれて多（おお）くを忘（わす）れ</span><br><span class="line">気付（きづ）いた時（とき）にゃもう灰（はい）になってる</span><br><span class="line">生（い）きた証（あかし）を残（のこ）しておくにはモノじゃ無（な）くて</span><br><span class="line">「誰（だれ）かの記憶（きおく）に残（のこ）るような人生（じんせい）をお薦（すす）めします」</span><br><span class="line"></span><br><span class="line">The deep deep deeper we go</span><br><span class="line">Feeling alone, but it&apos;s oh so simple, let it go</span><br><span class="line">Dim dim dim the light&apos;s low</span><br><span class="line">But not blind, I can see the symbol, let it show</span><br><span class="line">Mighty story, don&apos;t hide it from me</span><br><span class="line">いつだって人（ひと）は迷（まよ）うんだって</span><br><span class="line">気付（きづ）いちゃったって知（し）らんぷりしていよう</span><br><span class="line">そしてgood good days</span><br><span class="line"></span><br><span class="line">物事（ものごと）にはsoどんな時（とき）だって</span><br><span class="line">オマケのノビシロがついていて</span><br><span class="line">何（なに）かを築（きず）きそして変（か）えて越（こ）えて</span><br><span class="line">奇跡（きせき）と言（い）う名（な）の必然（ひつぜん）を繰（く）り返（かえ）して</span><br><span class="line">上（うえ）へ</span><br><span class="line"></span><br><span class="line">We never we never we will not stop right here</span><br><span class="line"></span><br><span class="line">Do what you do gotta get through</span><br><span class="line">へたれてる時間（じかん）なんて微塵（みじん）も無（な）いぞ</span><br><span class="line">後悔（こうかい）しないように生（い）きる</span><br><span class="line">そんな風（ふう）に生（い）きたって悔（く）いは残（のこ）るさ</span><br><span class="line">長（なが）いものに巻（ま）かれて終（お）わる</span><br><span class="line">いやそれどころか巻（ま）いて終（お）わるのさ</span><br><span class="line">予測（よそく）すらできやしない猛（もう）スピードで</span><br><span class="line">ほらgood good bye</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;歌曲信息&quot;&gt;&lt;a href=&quot;#歌曲信息&quot; class=&quot;headerlink&quot; title=&quot;歌曲信息&quot;&gt;&lt;/a&gt;歌曲信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;歌曲：Deeper Deeper&lt;/li&gt;
&lt;li&gt;歌手：ONE OK ROCK&lt;/li&gt;
&lt;li&gt;作词：Taka&lt;/li&gt;
&lt;li&gt;作曲：Tomoya/Ryota&lt;/li&gt;
&lt;li&gt;专辑：Deeper Deeper / Nothing Helps（2013年1月9日发行）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;OOR最喜欢的一首歌，没有之一。&lt;br&gt;标准日式摇滚。&lt;/p&gt;
    
    </summary>
    
      <category term="ニホンゴ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/"/>
    
      <category term="ウタ" scheme="http://tashi711.xyz/categories/%E3%83%8B%E3%83%9B%E3%83%B3%E3%82%B4/%E3%82%A6%E3%82%BF/"/>
    
    
      <category term="ONE OK ROCK" scheme="http://tashi711.xyz/tags/ONE-OK-ROCK/"/>
    
  </entry>
  
  <entry>
    <title>「913. Cat and Mouse」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-913/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-913/</id>
    <published>2018-10-04T03:57:02.000Z</published>
    <updated>2018-10-04T07:51:26.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/cat-and-mouse/description/" target="_blank" rel="noopener">913. Cat and Mouse</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>两个玩家分别扮演猫（Cat）和老鼠（Mouse）在无向图上进行游戏，他们轮流行动。<br>该图按下述规则给出：graph[a] 是所有结点 b 的列表，使得 ab 是图的一条边。<br>老鼠从结点 1 开始并率先出发，猫从结点 2 开始且随后出发，在结点 0 处有一个洞。<br>在每个玩家的回合中，他们必须沿着与他们所在位置相吻合的图的一条边移动。例如，如果老鼠位于结点 1，那么它只能移动到 graph[1] 中的（任何）结点去。<br>此外，猫无法移动到洞（结点 0）里。<br>然后，游戏在出现以下三种情形之一时结束：<br>如果猫和老鼠占据相同的结点，猫获胜。<br>如果老鼠躲入洞里，老鼠获胜。<br>如果某一位置重复出现（即轮到某一玩家移动时，该玩家与其之前某一回合处于同一位置），游戏平局。<br>给定 graph，并假设两个玩家都以最佳状态参与游戏，如果老鼠获胜，则返回 1；如果猫获胜，则返回 2；如果平局，则返回 0。</p><p><strong>示例：</strong><br>输入：[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]<br>输出：0<br>解释：<br>4—3—1<br>|   |<br>2—5<br> \ /<br>  0</p><p><strong>提示：</strong><br>3 &lt;= graph.length &lt;= 50<br>graph[1] 保证不为空。<br>graph[2] 中保证有一个非零的元素。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　按照题解的思路，进行宽搜即可。或者可以用DP父状态子状态的思维理解，考虑使用记忆化搜索。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(N^3)$。<br>　　空间复杂度为$O(N^2)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> d[kMaxN][kMaxN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, b, w;</span><br><span class="line">node(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>)</span><br><span class="line">: u(u), v(v), b(b), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">catMouseGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(graph.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">a[i] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(graph[i].size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">d[i][j][<span class="number">0</span>] = a[i];</span><br><span class="line">d[i][j][<span class="number">1</span>] = a[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u : graph[j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (u == <span class="number">0</span>) &#123;</span><br><span class="line">d[i][j][<span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; ++b) &#123;</span><br><span class="line">f[<span class="number">0</span>][i][b] = <span class="number">1</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(<span class="number">0</span>, i, b, <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">f[i][i][b] = <span class="number">2</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(i, i, b, <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">node t = q.front();</span><br><span class="line"><span class="keyword">int</span> u = t.u, v = t.v, b = t.b, w = t.w;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : graph[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[i][v][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">1</span>) &#123;</span><br><span class="line">f[i][v][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(i, v, <span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">d[i][v][<span class="number">0</span>]--;</span><br><span class="line"><span class="keyword">if</span> (d[i][v][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">f[i][v][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(i, v, <span class="number">0</span>, <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : graph[v]) &#123;</span><br><span class="line"><span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; f[u][j][<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">2</span>) &#123;</span><br><span class="line">f[u][j][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(u, j, <span class="number">1</span>, <span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">d[u][j][<span class="number">1</span>]--;</span><br><span class="line"><span class="keyword">if</span> (d[u][j][<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">f[u][j][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">q.emplace(<span class="built_in">std</span>::move(node(u, j, <span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/cat-and-mouse/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;913. Cat and Mouse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;两个玩家分别扮演猫（Cat）和老鼠（Mouse）在无向图上进行游戏，他们轮流行动。&lt;br&gt;该图按下述规则给出：graph[a] 是所有结点 b 的列表，使得 ab 是图的一条边。&lt;br&gt;老鼠从结点 1 开始并率先出发，猫从结点 2 开始且随后出发，在结点 0 处有一个洞。&lt;br&gt;在每个玩家的回合中，他们必须沿着与他们所在位置相吻合的图的一条边移动。例如，如果老鼠位于结点 1，那么它只能移动到 graph[1] 中的（任何）结点去。&lt;br&gt;此外，猫无法移动到洞（结点 0）里。&lt;br&gt;然后，游戏在出现以下三种情形之一时结束：&lt;br&gt;如果猫和老鼠占据相同的结点，猫获胜。&lt;br&gt;如果老鼠躲入洞里，老鼠获胜。&lt;br&gt;如果某一位置重复出现（即轮到某一玩家移动时，该玩家与其之前某一回合处于同一位置），游戏平局。&lt;br&gt;给定 graph，并假设两个玩家都以最佳状态参与游戏，如果老鼠获胜，则返回 1；如果猫获胜，则返回 2；如果平局，则返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;br&gt;输入：[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]&lt;br&gt;输出：0&lt;br&gt;解释：&lt;br&gt;4—3—1&lt;br&gt;|   |&lt;br&gt;2—5&lt;br&gt; \ /&lt;br&gt;  0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;br&gt;3 &amp;lt;= graph.length &amp;lt;= 50&lt;br&gt;graph[1] 保证不为空。&lt;br&gt;graph[2] 中保证有一个非零的元素。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="BFS" scheme="http://tashi711.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>「878. Nth Magical Number」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-878/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-878/</id>
    <published>2018-09-30T03:57:02.000Z</published>
    <updated>2018-10-04T07:55:39.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/nth-magical-number/description/" target="_blank" rel="noopener">878. Nth Magical Number</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>A positive integer is magical if it is divisible by either A or B.<br>Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.</p><p><strong>Example 1:</strong><br>Input: N = 1, A = 2, B = 3<br>Output: 2</p><p><strong>Example 2:</strong><br>Input: N = 4, A = 2, B = 3<br>Output: 6</p><p><strong>Example 3:</strong><br>Input: N = 5, A = 2, B = 4<br>Output: 10</p><p><strong>Example 4:</strong><br>Input: N = 3, A = 6, B = 4<br>Output: 8</p><p><strong>Note:</strong><br>1 &lt;= N &lt;= 10^9<br>2 &lt;= A &lt;= 40000<br>2 &lt;= B &lt;= 40000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　第一反应就是二分答案，判定一个数x内有多少个Magical Number很容易，稍微容斥一下，即$$    \left\lfloor \frac{x}{A} + \frac{x}{B} - \frac{x}{lcm(A, B)}\right\rfloor$$<br>　　只需要二分$N*\min(A, B)$内的数即可，因为必有N个A或B。<br>　　其实之后才想到官方题解中复杂度更高的那个算法，也就是在每lcm(A, B)个数出现的Magical Number模式（个数）是一样的，因此可以看看lcm(A, B)内有多少个，然后取个模，枚举剩下的。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(\log (N*\min(A, B))$。<br>　　空间复杂度为$O(1)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gcd(v, u % v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthMagicalNumber</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> u = <span class="number">0</span>, v = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(N) * min(A, B);</span><br><span class="line"><span class="keyword">int</span> lcm = A / gcd(A, B) * B;</span><br><span class="line"><span class="keyword">while</span> (u &lt; v) &#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m = u + (v - u) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (m / A + m / B - m / lcm &lt; N) &#123;</span><br><span class="line">u = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> u % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/nth-magical-number/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;878. Nth Magical Number&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;A positive integer is magical if it is divisible by either A or B.&lt;br&gt;Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;Input: N = 1, A = 2, B = 3&lt;br&gt;Output: 2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;Input: N = 4, A = 2, B = 3&lt;br&gt;Output: 6&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;br&gt;Input: N = 5, A = 2, B = 4&lt;br&gt;Output: 10&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 4:&lt;/strong&gt;&lt;br&gt;Input: N = 3, A = 6, B = 4&lt;br&gt;Output: 8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= N &amp;lt;= 10^9&lt;br&gt;2 &amp;lt;= A &amp;lt;= 40000&lt;br&gt;2 &amp;lt;= B &amp;lt;= 40000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="二分答案" scheme="http://tashi711.xyz/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>「887. Super Egg Drop」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-887/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-887/</id>
    <published>2018-09-29T03:57:02.000Z</published>
    <updated>2018-09-29T17:02:52.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/super-egg-drop/description/" target="_blank" rel="noopener">887. Super Egg Drop</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>You are given K eggs, and you have access to a building with N floors from 1 to N.<br>Each egg is identical in function, and if an egg breaks, you cannot drop it again.<br>You know that there exists a floor F with 0 &lt;= F &lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.<br>Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 &lt;= X &lt;= N).<br>Your goal is to know with certainty what the value of F is.<br>What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?</p><p><strong>Example 1:</strong><br>Input: K = 1, N = 2<br>Output: 2<br>Explanation:<br>Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.<br>Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.<br>If it didn’t break, then we know with certainty F = 2.<br>Hence, we needed 2 moves in the worst case to know what F is with certainty.</p><p><strong>Example 2:</strong><br>Input: K = 2, N = 6<br>Output: 3</p><p><strong>Example 3:</strong><br>Input: K = 3, N = 14<br>Output: 4</p><p><strong>Note:</strong><br>1 &lt;= K &lt;= 100<br>1 &lt;= N &lt;= 10000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　很容易想到一个暴力的DP，$O(KN^2)$。也就是$$dp(k, n)=\min_{1 \le x \le n}\lbrace dp(k-1, x-1), dp(k, x-k)\rbrace$$<br>　　虽然超时，但是我们能发现min项里面前者随着x增大而增大，后者随着x增大而减小，因此使用二分查找就可以找到恰当的x，复杂度可以被优化到$O(KN\log N)$，已经可以满足解决这道问题了。进一步想想还可以做优化，dp项随着n增大，取到最优的x也会随着增大，因此其实可以寻找当前x时从上个阶段最优的x开始，而不是从1开始，这样均摊复杂度就只有$O(KN)$了。<br>　　官方题解还给出了更加优化的算法可以达到$O(K\log N)$，有兴趣可以去看下，不过需要用到一些组合数学的推理，难度比较大，整体思想比较巧妙，他假设了另外一个问题，给定T次移动和K个鸡蛋，能够达到最大的层数f(T, K)是多少，于是问题变为找到最小的T使得f(T, K)≥N，而T又是可以二分查找的。　　</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　空间复杂度为$O(KN)$。<br>　　时间复杂度为$O(KN)$，因为只跟上一层子状态有关，如果使用滚动数组可以优化到$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">11000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxK = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxK][kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">f[<span class="number">1</span>][i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= K; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">f[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> u = max(f[i - <span class="number">1</span>][x - <span class="number">1</span>], f[i][j - x]);</span><br><span class="line"><span class="keyword">while</span> (x &lt; j &amp;&amp; u &gt; max(f[i - <span class="number">1</span>][x], f[i][j - x - <span class="number">1</span>])) &#123;</span><br><span class="line">x++;</span><br><span class="line">u = max(f[i - <span class="number">1</span>][x - <span class="number">1</span>], f[i][j - x]);</span><br><span class="line">&#125;</span><br><span class="line">f[i][j] = u + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[K][N];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/super-egg-drop/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;887. Super Egg Drop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;You are given K eggs, and you have access to a building with N floors from 1 to N.&lt;br&gt;Each egg is identical in function, and if an egg breaks, you cannot drop it again.&lt;br&gt;You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.&lt;br&gt;Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 &amp;lt;= X &amp;lt;= N).&lt;br&gt;Your goal is to know with certainty what the value of F is.&lt;br&gt;What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;Input: K = 1, N = 2&lt;br&gt;Output: 2&lt;br&gt;Explanation:&lt;br&gt;Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.&lt;br&gt;Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.&lt;br&gt;If it didn’t break, then we know with certainty F = 2.&lt;br&gt;Hence, we needed 2 moves in the worst case to know what F is with certainty.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;Input: K = 2, N = 6&lt;br&gt;Output: 3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;br&gt;Input: K = 3, N = 14&lt;br&gt;Output: 4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= K &amp;lt;= 100&lt;br&gt;1 &amp;lt;= N &amp;lt;= 10000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="数学" scheme="http://tashi711.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分查找" scheme="http://tashi711.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>「891. Sum of Subsequence Widths」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-891/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-891/</id>
    <published>2018-09-18T03:57:02.000Z</published>
    <updated>2018-10-04T07:55:21.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/sum-of-subsequence-widths/description/" target="_blank" rel="noopener">891. Sum of Subsequence Widths</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an array of integers A, consider all non-empty subsequences of A.<br>For any sequence S, let the width of S be the difference between the maximum and minimum element of S.<br>Return the sum of the widths of all subsequences of A.<br>As the answer may be very large, return the answer modulo 10^9 + 7.</p><p><strong>Example 1:</strong><br>Input: [2,1,3]<br>Output: 6<br>Explanation:<br>Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].<br>The corresponding widths are 0, 0, 0, 1, 1, 2, 2.<br>The sum of these widths is 6.</p><p><strong>Note:</strong><br>1 &lt;= A.length &lt;= 20000<br>1 &lt;= A[i] &lt;= 20000</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　一开始还看错了题，以为子串必须是连续的，导致想了个很复杂的算法，其实这里的子串应该理解为子集。<br>　　第一步要能想到用所有最大值减所有最小值即可，第二步再想到跟顺序无关。于是排序以后遍历每个数，第i个数作为最大值和最小值的子区间都一目了然（2的i次方个和2的n-i-1次方个，i从0到n-1）。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度主要是排序的复杂度，即$O(N \log N)$。<br>　　空间复杂度为$O(N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">22000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">a[i] = (a[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumSubseqWidths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(A.size());</span><br><span class="line">pre(n);</span><br><span class="line">sort(A.begin(), A.end());</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">ans = (ans + A[i] * (a[i] - a[n - i - <span class="number">1</span>])) % kModule;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ans + kModule) % kModule;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/sum-of-subsequence-widths/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;891. Sum of Subsequence Widths&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;Given an array of integers A, consider all non-empty subsequences of A.&lt;br&gt;For any sequence S, let the width of S be the difference between the maximum and minimum element of S.&lt;br&gt;Return the sum of the widths of all subsequences of A.&lt;br&gt;As the answer may be very large, return the answer modulo 10^9 + 7.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;Input: [2,1,3]&lt;br&gt;Output: 6&lt;br&gt;Explanation:&lt;br&gt;Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].&lt;br&gt;The corresponding widths are 0, 0, 0, 1, 1, 2, 2.&lt;br&gt;The sum of these widths is 6.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;br&gt;1 &amp;lt;= A[i] &amp;lt;= 20000&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
      <category term="数学" scheme="http://tashi711.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「906. Super Palindromes」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-906/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-906/</id>
    <published>2018-09-16T03:57:02.000Z</published>
    <updated>2018-09-16T05:45:54.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/super-palindromes/description/" target="_blank" rel="noopener">906. Super Palindromes</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　Let’s say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.<br>　　Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].</p><p>　　Example 1:<br>　　Input: L = “4”, R = “1000”<br>　　Output: 4<br>　　Explanation: 4, 9, 121, and 484 are superpalindromes.<br>　　Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.</p><p>　　Note:<br>　　1 &lt;= len(L) &lt;= 18<br>　　1 &lt;= len(R) &lt;= 18<br>　　L and R are strings representing integers in the range [1, 10^18).<br>　　int(L) &lt;= int(R)</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　先写了一个暴力的方法观察一下答案的特点，发现除了3以外的基数都是由0、1、2组成的，然后分析了一下发现确实，回文且平方不能进位，只有可能有0、1、2了，假设有3（除了就是3），那么一个数的3一定跟另一个数的3都乘成9，然后再做加法，就一定进位非回文了。于是想到枚举基数的一半（因为基数也是回文的），即最多4位。然后再枚举中间位，可能为空（偶数位）或者0、1、2，相当于枚举5位（当然，要注意首末位不能为0），最后判断平方是否回文即可，假设数的范围为N（long long内），那么位数L的规模为$O(\log N)$，验证回文的复杂度也最多$O(L)$，也不用占多大的空间。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　如上分析。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">string</span> &amp;u, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &gt; n) &#123;</span><br><span class="line"><span class="built_in">string</span> tot = u + s + v;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(tot)</span></span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> now;</span><br><span class="line">ss &gt;&gt; now;</span><br><span class="line"><span class="keyword">if</span> (is_palindrome(now * now)) &#123;</span><br><span class="line">all.push_back(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'0'</span>; i &lt;= <span class="string">'2'</span>; ++i) &#123;</span><br><span class="line">dfs(p + <span class="number">1</span>, n, u + i, s, i + v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">all.push_back(<span class="number">1</span>);</span><br><span class="line">all.push_back(<span class="number">2</span>);</span><br><span class="line">all.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">string</span> s[] = &#123; <span class="string">""</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">dfs(<span class="number">2</span>, i, <span class="string">"1"</span>, s[j], <span class="string">"1"</span>);</span><br><span class="line">dfs(<span class="number">2</span>, i, <span class="string">"2"</span>, s[j], <span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line">adj.push_back(k % <span class="number">10</span>);</span><br><span class="line">k /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(adj.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (adj[i] != adj[n - i - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superpalindromesInRange</span><span class="params">(<span class="built_in">string</span> L, <span class="built_in">string</span> R)</span> </span>&#123;</span><br><span class="line">pre();</span><br><span class="line"><span class="built_in">stringstream</span> s1, s2;</span><br><span class="line">s1 &lt;&lt; L;</span><br><span class="line">s2 &lt;&lt; R;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> u, v;</span><br><span class="line">s1 &gt;&gt; u;</span><br><span class="line">s2 &gt;&gt; v;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="built_in">sqrt</span>(u + <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">if</span> (a * a &lt; u) &#123;</span><br><span class="line">a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="built_in">sqrt</span>(v + <span class="number">0.5</span>));</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> k : all) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &gt;= a &amp;&amp; k &lt;= b) &#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">// cout &lt;&lt; "tot: " &lt;&lt; ans &lt;&lt; ", cur: " &lt;&lt; k * k &lt;&lt; " (" &lt;&lt; k &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/super-palindromes/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;906. Super Palindromes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　Let’s say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.&lt;br&gt;　　Now, given two positive integers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: L = “4”, R = “1000”&lt;br&gt;　　Output: 4&lt;br&gt;　　Explanation: 4, 9, 121, and 484 are superpalindromes.&lt;br&gt;　　Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= len(L) &amp;lt;= 18&lt;br&gt;　　1 &amp;lt;= len(R) &amp;lt;= 18&lt;br&gt;　　L and R are strings representing integers in the range [1, 10^18).&lt;br&gt;　　int(L) &amp;lt;= int(R)&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「895. Maximum Frequency Stack」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-895/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-895/</id>
    <published>2018-09-14T03:57:02.000Z</published>
    <updated>2018-09-13T17:02:35.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/maximum-frequency-stack/description/" target="_blank" rel="noopener">895. Maximum Frequency Stack</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　implement FreqStack, a class which simulates the operation of a stack-like data structure.<br>　　FreqStack has two functions:<br>　　push(int x), which pushes an integer x onto the stack.<br>　　pop(), which removes and returns the most frequent element in the stack.<br>　　If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.</p><p>　　Example:<br>　　Input:<br>　　[“FreqStack”,”push”,”push”,”push”,”push”,”push”,”push”,”pop”,”pop”,”pop”,”pop”],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]<br>　　Output: [null,null,null,null,null,null,null,5,7,5,4]<br>　　Explanation:<br>　　After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top. Then:<br>　　pop() -&gt; returns 5, as 5 is the most frequent.<br>　　The stack becomes [5,7,5,7,4].<br>　　pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.<br>　　The stack becomes [5,7,5,4].<br>　　pop() -&gt; returns 5.<br>　　The stack becomes [5,7,4].<br>　　pop() -&gt; returns 4.<br>　　The stack becomes [5,7].</p><p>　　Note：<br>　　Calls to FreqStack.push(int x) will be such that 0 &lt;= x &lt;= 10^9.<br>　　It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements.<br>　　The total number of FreqStack.push calls will not exceed 10000 in a single test case.<br>　　The total number of FreqStack.pop calls will not exceed 10000 in a single test case.<br>　　The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　这道题有个非常巧妙的解法，可以实现单次push和pop都是$O(1)$的时间，我做完之后看官方题解是那样做的，这里先讲我自己的方法，巧妙的解法放在后面解题心得中。<br>　　首先想到push操作得记录好这个数的次数以及所有出现的位置（因为之后pop后要能追踪到上一个位置），这样用一个unordered_map&lt;int, vector<int>&gt;来保存，另外pop的时候要能找到最大的次数以及最顶端的位置，这样用一个map&lt;node, int&gt;来存，其中node是类似于pair的有序的二元组，保存着次数与位置。push与pop的时候互相更新就好了。</int></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　空间复杂度为$O(N)$。<br>　　单次push或pop的时间复杂度为$O(\log N)$（map的操作）。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">node(<span class="keyword">int</span> _cnt = <span class="number">0</span>, <span class="keyword">int</span> _pos = <span class="number">0</span>, <span class="keyword">int</span> _k = <span class="number">0</span>)</span><br><span class="line">: cnt(_cnt), pos(_pos), k(_k) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; r) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt != r.cnt) &#123;</span><br><span class="line"><span class="keyword">return</span> cnt &gt; r.cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pos &gt; r.pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pos;</span><br><span class="line"><span class="built_in">map</span>&lt;node, <span class="keyword">int</span>&gt; f;</span><br><span class="line"></span><br><span class="line">FreqStack() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">pos[x].push_back(++idx);</span><br><span class="line"><span class="keyword">int</span> cur = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pos[x].size());</span><br><span class="line"><span class="keyword">if</span> (cur &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> pre = pos[x][cur - <span class="number">2</span>];</span><br><span class="line">f.erase(node(cur - <span class="number">1</span>, pre));</span><br><span class="line">&#125;</span><br><span class="line">f[node(cur, idx)] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max_c = f.begin()-&gt;first.cnt;</span><br><span class="line"><span class="keyword">int</span> cur_k = f.begin()-&gt;second;</span><br><span class="line">f.erase(f.begin());</span><br><span class="line">pos[cur_k].pop_back();</span><br><span class="line"><span class="keyword">if</span> (!pos[cur_k].empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> now_p = pos[cur_k].back();</span><br><span class="line">f[node(max_c - <span class="number">1</span>, now_p)] = cur_k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur_k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>　　看了下官方的题解，觉得非常巧妙，定义了数字到次数的map以及次数到栈的map，第k次对应的栈保存第k次入栈的元素，这样做的好处是，每个数字第k次出现都在第k个栈里，直接可以拿到，而且顺序又刚好是进栈的顺序，这样的map可以是无序的（hash map），因此无论是整体结构还是时间复杂度都优化了不少。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/maximum-frequency-stack/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;895. Maximum Frequency Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　implement FreqStack, a class which simulates the operation of a stack-like data structure.&lt;br&gt;　　FreqStack has two functions:&lt;br&gt;　　push(int x), which pushes an integer x onto the stack.&lt;br&gt;　　pop(), which removes and returns the most frequent element in the stack.&lt;br&gt;　　If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.&lt;/p&gt;
&lt;p&gt;　　Example:&lt;br&gt;　　Input:&lt;br&gt;　　[“FreqStack”,”push”,”push”,”push”,”push”,”push”,”push”,”pop”,”pop”,”pop”,”pop”],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]&lt;br&gt;　　Output: [null,null,null,null,null,null,null,5,7,5,4]&lt;br&gt;　　Explanation:&lt;br&gt;　　After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top. Then:&lt;br&gt;　　pop() -&amp;gt; returns 5, as 5 is the most frequent.&lt;br&gt;　　The stack becomes [5,7,5,7,4].&lt;br&gt;　　pop() -&amp;gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.&lt;br&gt;　　The stack becomes [5,7,5,4].&lt;br&gt;　　pop() -&amp;gt; returns 5.&lt;br&gt;　　The stack becomes [5,7,4].&lt;br&gt;　　pop() -&amp;gt; returns 4.&lt;br&gt;　　The stack becomes [5,7].&lt;/p&gt;
&lt;p&gt;　　Note：&lt;br&gt;　　Calls to FreqStack.push(int x) will be such that 0 &amp;lt;= x &amp;lt;= 10^9.&lt;br&gt;　　It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements.&lt;br&gt;　　The total number of FreqStack.push calls will not exceed 10000 in a single test case.&lt;br&gt;　　The total number of FreqStack.pop calls will not exceed 10000 in a single test case.&lt;br&gt;　　The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="栈" scheme="http://tashi711.xyz/tags/%E6%A0%88/"/>
    
      <category term="巧妙" scheme="http://tashi711.xyz/tags/%E5%B7%A7%E5%A6%99/"/>
    
  </entry>
  
  <entry>
    <title>「899. Orderly Queue」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-899/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-899/</id>
    <published>2018-09-13T03:57:02.000Z</published>
    <updated>2018-09-12T18:33:35.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/orderly-queue/description/" target="_blank" rel="noopener">899. Orderly Queue</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　A string S of lowercase letters is given.  Then, we may make any number of moves.<br>　　In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string.<br>　　Return the lexicographically smallest string we could have after any number of moves.</p><p>　　Example 1:<br>　　Input: S = “cba”, K = 1<br>　　Output: “acb”<br>　　Explanation:<br>　　In the first move, we move the 1st character (“c”) to the end, obtaining the string “bac”.<br>　　In the second move, we move the 1st character (“b”) to the end, obtaining the final result “acb”.</p><p>　　Example 2:<br>　　Input: S = “baaca”, K = 3<br>　　Output: “aaabc”<br>　　Explanation:<br>　　In the first move, we move the 1st character (“b”) to the end, obtaining the string “aacab”.<br>　　In the second move, we move the 3rd character (“c”) to the end, obtaining the final result “aaabc”.</p><p>　　Note:<br>　　1 &lt;= K &lt;= S.length &lt;= 1000<br>　　S consists of lowercase letters only.</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　说这是一道思考题是因为确实只要想通了编码上毫无难度。说这是一道水题是因为确实不难想通。<br>　　很容易想到如果K &gt; 1的时候可以实现任意连续位置的K个字母随意交换，具体做法就是先将要交换的K个字母放到最前面（将前面的字母依次移走），然后按照要交换的顺序将这K的字母移走，最后再依次移动其他字母直到这K个字母回到原先的这段位置。又容易想到如果能交换任意连续2个字母，可以做到（冒泡）排序。于是K &gt; 1时一定能达到所有字母从小到大排列。K = 1时也容易想到最优解就是枚举所有S.length种可能，找到最小的那个。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　令N为S.length。<br>　　空间复杂度为$O(N)$。<br>　　时间复杂度为$O(N^2)$，主要是K = 1时的复杂度，K &gt; 1时只需排序复杂度$O(N \log N)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">orderlyQueue</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">ans = S;</span><br><span class="line"><span class="built_in">string</span> cur = S;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(S.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cur = cur.substr(<span class="number">1</span>) + cur[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (cur &lt; ans) &#123;</span><br><span class="line">ans = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans = S;</span><br><span class="line">sort(ans.begin(), ans.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/orderly-queue/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;899. Orderly Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　A string S of lowercase letters is given.  Then, we may make any number of moves.&lt;br&gt;　　In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string.&lt;br&gt;　　Return the lexicographically smallest string we could have after any number of moves.&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: S = “cba”, K = 1&lt;br&gt;　　Output: “acb”&lt;br&gt;　　Explanation:&lt;br&gt;　　In the first move, we move the 1st character (“c”) to the end, obtaining the string “bac”.&lt;br&gt;　　In the second move, we move the 1st character (“b”) to the end, obtaining the final result “acb”.&lt;/p&gt;
&lt;p&gt;　　Example 2:&lt;br&gt;　　Input: S = “baaca”, K = 3&lt;br&gt;　　Output: “aaabc”&lt;br&gt;　　Explanation:&lt;br&gt;　　In the first move, we move the 1st character (“b”) to the end, obtaining the string “aacab”.&lt;br&gt;　　In the second move, we move the 3rd character (“c”) to the end, obtaining the final result “aaabc”.&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= K &amp;lt;= S.length &amp;lt;= 1000&lt;br&gt;　　S consists of lowercase letters only.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="字符串" scheme="http://tashi711.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="思考题" scheme="http://tashi711.xyz/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
      <category term="水题" scheme="http://tashi711.xyz/tags/%E6%B0%B4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「902. Numbers At Most N Given Digit Set」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-902/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-902/</id>
    <published>2018-09-12T03:57:02.000Z</published>
    <updated>2018-10-04T07:53:51.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/numbers-at-most-n-given-digit-set/description/" target="_blank" rel="noopener">902. Numbers At Most N Given Digit Set</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　We have a sorted set of digits D, a non-empty subset of {‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}.  (Note that ‘0’ is not included.)<br>　　Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {‘1’,’3’,’5’}, we may write numbers such as ‘13’, ‘551’, ‘1351315’.<br>　　Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.</p><p>　　Example 1:<br>　　Input: D = [“1”,”3”,”5”,”7”], N = 100<br>　　Output: 20<br>　　Explanation:<br>　　The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</p><p>　　Example 2:<br>　　Input: D = [“1”,”4”,”9”], N = 1000000000<br>　　Output: 29523<br>　　Explanation:<br>　　We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.</p><p>　　Note:<br>　　D is a subset of digits ‘1’-‘9’ in sorted order.<br>　　1 &lt;= N &lt;= 10^9</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　最简单的模拟一下就好了，注意题目比较坑，他的描述容易被误解成每个数只能用D中的3个，其实那句话的意思是他举的例子是取了3个数（不然这道题其实暴力枚举也不会超时）。<br>　　那么就从头到尾扫，当前位置摆更小的数，后面就可以随意摆，当前位置正好摆相同的数（如果有），就扫到下一位做同样的判断累加。最后记得累加摆比N位数少的数的个数就好（任意摆），这个累和可以先初始化出来，包括D的size的所有次方。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　时间复杂度为$O(\log N)$，即N的位数，如果将D的size考虑为常数的话（不超过9）。<br>　　空间复杂度为$O(\log N)$，同理。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[kMaxN];</span><br><span class="line"><span class="keyword">int</span> sum[kMaxN];</span><br><span class="line"><span class="keyword">bool</span> have[kMaxN];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">a[i] = a[i - <span class="number">1</span>] * tot;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(have, <span class="number">0</span>, <span class="keyword">sizeof</span> have);</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = s[p] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; u; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (have[i]) &#123;</span><br><span class="line">ans += a[n - p - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (have[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (p + <span class="number">1</span> == n) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dfs(s, p + <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atMostNGivenDigitSet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; D, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">tot = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(D.size());</span><br><span class="line">pre();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> s : D) &#123;</span><br><span class="line">have[s[<span class="number">0</span>] - <span class="string">'0'</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; N;</span><br><span class="line"><span class="built_in">string</span> n;</span><br><span class="line">ss &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(n.size());</span><br><span class="line">dfs(n, <span class="number">0</span>, len);</span><br><span class="line">ans += sum[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/numbers-at-most-n-given-digit-set/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;902. Numbers At Most N Given Digit Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　We have a sorted set of digits D, a non-empty subset of {‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}.  (Note that ‘0’ is not included.)&lt;br&gt;　　Now, we write numbers using these digits, using each digit as many times as we want.  For example, if D = {‘1’,’3’,’5’}, we may write numbers such as ‘13’, ‘551’, ‘1351315’.&lt;br&gt;　　Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N.&lt;/p&gt;
&lt;p&gt;　　Example 1:&lt;br&gt;　　Input: D = [“1”,”3”,”5”,”7”], N = 100&lt;br&gt;　　Output: 20&lt;br&gt;　　Explanation:&lt;br&gt;　　The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.&lt;/p&gt;
&lt;p&gt;　　Example 2:&lt;br&gt;　　Input: D = [“1”,”4”,”9”], N = 1000000000&lt;br&gt;　　Output: 29523&lt;br&gt;　　Explanation:&lt;br&gt;　　We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D.&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　D is a subset of digits ‘1’-‘9’ in sorted order.&lt;br&gt;　　1 &amp;lt;= N &amp;lt;= 10^9&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="模拟" scheme="http://tashi711.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>「903. Valid Permutations for DI Sequence」解题报告</title>
    <link href="http://tashi711.xyz/programming/reports/leetcode/leetcode-903/"/>
    <id>http://tashi711.xyz/programming/reports/leetcode/leetcode-903/</id>
    <published>2018-09-11T03:57:02.000Z</published>
    <updated>2018-09-11T15:47:18.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><blockquote><ul><li>链接：<a href="https://leetcode.com/problems/valid-permutations-for-di-sequence/description/" target="_blank" rel="noopener">903. Valid Permutations for DI Sequence</a></li><li>来源：LeetCode</li><li>难度：Hard</li></ul></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>　　We are given S, a length n string of characters from the set {‘D’, ‘I’}. (These letters stand for “decreasing” and “increasing”.)<br>　　A valid permutation is a permutation P[0], P[1], …, P[n] of integers {0, 1, …, n}, such that for all i:<br>　　If S[i] == ‘D’, then P[i] &gt; P[i+1], and;<br>　　If S[i] == ‘I’, then P[i] &lt; P[i+1].<br>　　How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.</p><p>　　Example:<br>　　Input: “DID”<br>　　Output: 5<br>　　Explanation:<br>　　The 5 valid permutations of (0, 1, 2, 3) are:<br>　　(1, 0, 3, 2)<br>　　(2, 0, 3, 1)<br>　　(2, 1, 3, 0)<br>　　(3, 0, 2, 1)<br>　　(3, 1, 2, 0)</p><p>　　Note:<br>　　1 &lt;= S.length &lt;= 200<br>　　S consists only of characters from the set {‘D’, ‘I’}.</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>　　因为很容易想到从子状态递推过去，典型的DP题。<br>　　用f[i][j]表示算到字符串第i个位置结尾为j的方案个数。<br>　　容易得到，如果当前S[i]为“D”，那么f[i][j] = sigma(f[i-1][k])，k从j到i，因为如果当前位置放j，那么等价的方案是前面放的1到j-1不变，j到i分别变成j+1到i+1，而需要的是前一个结尾为j+1到i+1的，那么枚举的k为j到i；同理，如果当前S[i]为“I”，那么f[i][j] = sigma(f[i-1][k])，k从1到j-1，因为需要的是前一个结尾为1到j-1（在等价方案中不变）。<br>　　容易想到初始状态为f[0][1] = 1，每次计算f[i][j]时j要从1枚举到i+1。<br>　　最终答案为sigma(f[n][i])，i从1到n+1。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>　　空间复杂度为状态复杂度，即$O(N^2)$。<br>　　时间复杂度为状态复杂度×转移复杂度，即$O(N^3)$。</p><h2 id="AC代码（C-）"><a href="#AC代码（C-）" class="headerlink" title="AC代码（C++）"></a>AC代码（C++）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxN = <span class="number">220</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kModule = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[kMaxN][kMaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_add_equal</span><span class="params">(<span class="keyword">int</span>&amp; s, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">s = (s + p) % kModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numPermsDISequence</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(S.size());</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">'\0'</span> + S;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i + <span class="number">1</span>; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> u = (s[i] == <span class="string">'D'</span> ? j : <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> v = (s[i] == <span class="string">'D'</span> ? i : j - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = u; k &lt;= v; ++k) &#123;</span><br><span class="line">my_add_equal(f[i][j], f[i - <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">my_add_equal(ans, f[n][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><p>　　看了下官方的题解，时间可以优化到N方，有个启发就是枚举k的时候其实都是连续的一段和，那么其实可以在枚举j之前先把f[i][1]到f[i][k]，k从1到i的累和算出来，之后可以直接用了（相减），时间就可以降一维。题解上说的是通过观察直接得到了没有累加的转移方程，其实自己琢磨一下那个方程会发现是有实际意义在里面的，道理差不多，利用连续和均摊复杂度。至于题解中的分治做法就没有太研究了，时间也可以到N方。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目信息&quot;&gt;&lt;a href=&quot;#题目信息&quot; class=&quot;headerlink&quot; title=&quot;题目信息&quot;&gt;&lt;/a&gt;题目信息&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;链接：&lt;a href=&quot;https://leetcode.com/problems/valid-permutations-for-di-sequence/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;903. Valid Permutations for DI Sequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;来源：LeetCode&lt;/li&gt;
&lt;li&gt;难度：Hard&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;　　We are given S, a length n string of characters from the set {‘D’, ‘I’}. (These letters stand for “decreasing” and “increasing”.)&lt;br&gt;　　A valid permutation is a permutation P[0], P[1], …, P[n] of integers {0, 1, …, n}, such that for all i:&lt;br&gt;　　If S[i] == ‘D’, then P[i] &amp;gt; P[i+1], and;&lt;br&gt;　　If S[i] == ‘I’, then P[i] &amp;lt; P[i+1].&lt;br&gt;　　How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.&lt;/p&gt;
&lt;p&gt;　　Example:&lt;br&gt;　　Input: “DID”&lt;br&gt;　　Output: 5&lt;br&gt;　　Explanation:&lt;br&gt;　　The 5 valid permutations of (0, 1, 2, 3) are:&lt;br&gt;　　(1, 0, 3, 2)&lt;br&gt;　　(2, 0, 3, 1)&lt;br&gt;　　(2, 1, 3, 0)&lt;br&gt;　　(3, 0, 2, 1)&lt;br&gt;　　(3, 1, 2, 0)&lt;/p&gt;
&lt;p&gt;　　Note:&lt;br&gt;　　1 &amp;lt;= S.length &amp;lt;= 200&lt;br&gt;　　S consists only of characters from the set {‘D’, ‘I’}.&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="解题报告" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="LeetCode" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/LeetCode/"/>
    
    
      <category term="动态规划" scheme="http://tashi711.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>「C++ Primer (5th) 第4章」小结</title>
    <link href="http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-4/"/>
    <id>http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-4/</id>
    <published>2018-09-11T03:17:59.000Z</published>
    <updated>2018-09-19T17:50:48.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-Primer-5th"><a href="#C-Primer-5th" class="headerlink" title="C++ Primer (5th)"></a>C++ Primer (5th)</h2><blockquote><ul><li>第一部分：C++基础</li><li>第4章</li></ul></blockquote><a id="more"></a><h3 id="第一部分：C-基础-第4章"><a href="#第一部分：C-基础-第4章" class="headerlink" title="第一部分：C++基础 (第4章)"></a>第一部分：C++基础 (第4章)</h3><ul><li><code>decltype</code>会判断左值与右值：假设<code>p</code>为<code>int*</code>，那么<code>decltype(*p)</code>为<code>int&amp;</code>，<code>decltype(&amp;p)</code>为<code>int**</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-Primer-5th&quot;&gt;&lt;a href=&quot;#C-Primer-5th&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer (5th)&quot;&gt;&lt;/a&gt;C++ Primer (5th)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：C++基础&lt;/li&gt;
&lt;li&gt;第4章&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「C++ Primer (5th) 第3章」小结</title>
    <link href="http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-3/"/>
    <id>http://tashi711.xyz/programming/notes/cpp-primer/cpp-primer-3/</id>
    <published>2018-09-11T03:17:59.000Z</published>
    <updated>2018-09-18T17:18:43.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-Primer-5th"><a href="#C-Primer-5th" class="headerlink" title="C++ Primer (5th)"></a>C++ Primer (5th)</h2><blockquote><ul><li>第一部分：C++基础</li><li>第3章</li></ul></blockquote><a id="more"></a><h3 id="第一部分：C-基础-第3章"><a href="#第一部分：C-基础-第3章" class="headerlink" title="第一部分：C++基础 (第3章)"></a>第一部分：C++基础 (第3章)</h3><ul><li><p>初始化时使用花括号但提供的值不能用来列表初始化，那么就会调用构造函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1&#123;<span class="number">10</span>&#125;; <span class="comment">// 10个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2(<span class="number">10</span>, <span class="string">"hi"</span>&#125;; <span class="comment">// 10个"hi"</span></span><br></pre></td></tr></table></figure></li><li><p><code>vector&lt;int&gt;</code>的size type为<code>vector&lt;int&gt;::size_type</code></p></li><li>容器是常量只能用const_iterator，不是的话iterator、const_iterator都可以用</li><li>如果对象是常量，begin、end返回const_iterator，否则是iterator，而cbegin、cend永远返回const_iterator</li><li>不能在for中、或者使用迭代器时push_back</li><li>可以相减的迭代器相减结果为difference_type（带符号整数）</li><li>数组不能用auto声明，元素只能是对象不能是引用（与vector一样）</li><li><p>数组的指针与引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> (*parr)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// parr指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;rarr)[<span class="number">10</span>] = arr;  <span class="comment">// rarr引用一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *(&amp;rptrs)[<span class="number">10</span>] = ptrs;  <span class="comment">// rptrs引用一个含有10个指针的数组</span></span><br></pre></td></tr></table></figure></li><li><p>auto 数组：指针</p></li><li>decltype(数组)：含有X个元素的数组</li><li>begin(数组)：指向首元素的指针，end(数组)：指向尾元素下一位置的指针</li><li>尾指针不能自增，指向之后的指针会出错</li><li>指针相减的type为ptrdiff_t，带符号</li><li>内置下标运算时有符的，标准库是无符的</li><li>c_str返回的的数组不一定一直有效，需拷贝</li><li>令<code>int a[3][4]</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : a) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : r) &#123;</span><br><span class="line">  <span class="comment">// c: 引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;r : a) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : r) &#123;</span><br><span class="line">  <span class="comment">// c: 非引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> r : a) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> c : r) &#123;</span><br><span class="line">  <span class="comment">// 无法编译，因为r为int*，那么内层循环没有意义</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = a; p != a + <span class="number">3</span>; ++p) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q) &#123;</span><br><span class="line">  <span class="comment">// *q</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = begin(a); p != end(a); ++p) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> q = begin(*p); q != end(*p); ++q) &#123;</span><br><span class="line">  <span class="comment">// *q</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> ia = <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ia[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (ia *p = a; p != a + <span class="number">3</span>; ++p) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q != *p + <span class="number">4</span>; ++q) &#123;</span><br><span class="line">  <span class="comment">// *q</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-Primer-5th&quot;&gt;&lt;a href=&quot;#C-Primer-5th&quot; class=&quot;headerlink&quot; title=&quot;C++ Primer (5th)&quot;&gt;&lt;/a&gt;C++ Primer (5th)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：C++基础&lt;/li&gt;
&lt;li&gt;第3章&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>「Effective C++ (3rd) 第一、二、三部分」小结</title>
    <link href="http://tashi711.xyz/programming/notes/effective-cpp/effective-cpp/"/>
    <id>http://tashi711.xyz/programming/notes/effective-cpp/effective-cpp/</id>
    <published>2018-09-08T03:17:59.000Z</published>
    <updated>2018-09-20T18:08:14.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-C-3rd"><a href="#Effective-C-3rd" class="headerlink" title="Effective C++ (3rd)"></a>Effective C++ (3rd)</h2><blockquote><ul><li>第一部分：Accustoming Yourself to C++</li><li>第二部分：Constructors, Destructors, and Assignment Operators</li><li>第三部分：Resource Management</li></ul></blockquote><a id="more"></a><h3 id="第一部分：Accustoming-Yourself-to-C"><a href="#第一部分：Accustoming-Yourself-to-C" class="headerlink" title="第一部分：Accustoming Yourself to C++"></a>第一部分：Accustoming Yourself to C++</h3><ul><li><p>使用enum定义常数不占空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; Num = <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> a[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>const xxx::iterator</code>相当于<code>T* const</code>，<code>xxx::const_iterator</code>相当于<code>const T*</code></p></li><li>mutable成员变量可以在const成员变量中改变</li><li><p>const与non-const成员函数避免代码重复，non-const调用const：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> <span class="comment">// same as before</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[position];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="comment">// now just calls const op[]</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;( <span class="comment">// cast away const on op[]’s return type;</span></span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>) <span class="comment">// add const to *this’s type;</span></span><br><span class="line">          [position] <span class="comment">// call const version of op[]</span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>成员变量总是以声明顺序初始化，与初始化列表顺序无关</p></li><li>因为跨编译单元初始化顺序问题，用local static代替non-local static对象</li></ul><h3 id="第二部分：Constructors-Destructors-and-Assignment-Operators"><a href="#第二部分：Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="第二部分：Constructors, Destructors, and Assignment Operators"></a>第二部分：Constructors, Destructors, and Assignment Operators</h3><ul><li>内含引用成员或const成员的类不能自动生成拷贝赋值函数</li><li>如果基类的拷贝赋值函数是为私有的，派生类不会自动生成拷贝赋值函数</li><li>为了删除自动生成的成员函数，可以声明为private或者继承有这样private成员函数的类</li><li>一般，类中有至少一个virtual时才把析构声明成virtual</li><li>使用纯虚析构可以让类成为纯虚类，但必须有虚构函数的定义</li><li>某些不是为了多态的基类（比如上面说的将成员函数声明为private来删除自动生成的成员函数）不应该声明virtual的析构。</li><li>析构函数不能抛出异常，如果析构函数中被调用的函数抛出异常，析构函数应该捕捉到，吞下它（不传播）或者结束程序（<code>std::abort()</code>）</li><li>构造、析构函数类不要调用virtual函数或者调用了virtual函数的函数，因为在子类构造时会先构造父类，此时virtual以及dynamic_cast都是父类的，为了防止访问还没有初始化的子类local的成员变量，析构同理</li><li>构造中使用的函数声明为static，防止使用未初始化的成员变量</li><li>赋值操作符返回<code>*this</code>的引用</li><li>确保赋值操作符在自我赋值时不会出错（比较两个对象的地址、先复制后delete、copy-and-swap）</li><li>copying函数（copy构造和copy赋值）应该确保base class的部分也复制</li><li>copy赋值函数中基类的赋值：<code>Base::operator=(rhs)</code></li><li>在某个copying函数里面不能调用另一个copying函数（可以写第三个函数、两者共同调用）</li></ul><h3 id="第三部分：Resource-Management"><a href="#第三部分：Resource-Management" class="headerlink" title="第三部分：Resource Management"></a>第三部分：Resource Management</h3><ul><li>RAII: auto_ptr（copy后指向null）、shared_ptr，这两者不能用于数组，因为是delete操作而不是delete[]操作</li><li>RAII的copy时要复制其管理的资源，可以：1、禁止复制（private）；2、引用计数（shared_ptr）；3、深度复制；4、转交拥有权（auto_ptr）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Effective-C-3rd&quot;&gt;&lt;a href=&quot;#Effective-C-3rd&quot; class=&quot;headerlink&quot; title=&quot;Effective C++ (3rd)&quot;&gt;&lt;/a&gt;Effective C++ (3rd)&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：Accustoming Yourself to C++&lt;/li&gt;
&lt;li&gt;第二部分：Constructors, Destructors, and Assignment Operators&lt;/li&gt;
&lt;li&gt;第三部分：Resource Management&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="http://tashi711.xyz/categories/%E7%BC%96%E7%A8%8B/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective-C/"/>
    
    
      <category term="C++" scheme="http://tashi711.xyz/tags/C/"/>
    
  </entry>
  
</feed>
